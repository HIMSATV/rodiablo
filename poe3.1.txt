<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Oni Samurai</title>

  <style>
    :root{
      --uiScale: 1.2;
      --uiH: clamp(calc(84px * var(--uiScale)),  calc(16vh * var(--uiScale)),  calc(120px * var(--uiScale)));
      --pad: clamp(calc(66px * var(--uiScale)),  calc(12.5vw * var(--uiScale)), calc(90px  * var(--uiScale)));
      --stick:clamp(calc(28px * var(--uiScale)),  calc(5.6vw * var(--uiScale)),  calc(40px  * var(--uiScale)));
      --btn: clamp(calc(70px * var(--uiScale)),  calc(13vw * var(--uiScale)),   calc(90px  * var(--uiScale)));
    }

    body{ margin:0; background:black; overflow:hidden; touch-action:none; }
    canvas{ position:fixed; top:0; left:0; image-rendering:pixelated; }

    /* ============================= */
    /* âœ… í•˜ë‹¨ UI ë°” */
    /* ============================= */
    #ui{
      position:fixed;bottom:0;width:100%;height:var(--uiH);
      background:#111;border-top:3px solid #550000;
      display:flex;align-items:center;justify-content:space-between;
      padding:0 clamp(10px, 4vw, 25px);box-sizing:border-box;
      z-index:50;
    }

    #movePad{
      position:relative;
      width:var(--pad);height:var(--pad);
      border-radius:50%;
      background:#222;
    }
    #stick{
      position:absolute;
      width:var(--stick);
      height:var(--stick);
      border-radius:50%;
      background:#666;
      left: calc(50% - (var(--stick) / 2));
      top:  calc(50% - (var(--stick) / 2));
    }

    /* ì˜¤ë¥¸ìª½ ë²„íŠ¼ ì˜ì—­ */
    #rightBtns{
      position:relative;
      width:var(--btn);
      height:var(--btn);
      display:block;
      overflow:visible;
    }

    #attackBtn{
      position:absolute;
      right:0;
      bottom:0;
      width:var(--btn);height:var(--btn);
      border-radius:50%;
      background:#990000;border:3px solid #ff4444;
      display:flex;align-items:center;justify-content:center;
      font-size:26px;color:white;
      user-select:none;
      -webkit-user-select:none;
    }
    #attackBtn.active{background:red;transform:scale(.85);}

    #attackIcon{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
    }

    /* ============================= */
    /* âœ… ì•„ì´í…œ ì„ íƒ ì˜¤ë²„ë ˆì´ UI     */
    /* ============================= */
    #lootOverlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.75);
      z-index:9999;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    #lootPanel{
      width:min(92vw, 520px);
      background:#111;
      border:2px solid #444;
      border-radius:14px;
      padding:14px;
      box-shadow:0 0 30px rgba(0,0,0,0.6);
    }
    #lootTitle{
      color:#fff;
      font-weight:800;
      font-size:18px;
      margin:4px 2px 10px;
      text-align:center;
    }
    .lootCards{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .lootCard{
      background:#1a1a1a;
      border:2px solid #333;
      border-radius:12px;
      padding:12px;
      color:#eee;
      line-height:1.25;
    }
    .lootCard .name{
      font-weight:900;
      margin-bottom:6px;
    }
    .lootCard .desc{
      color:#cfcfcf;
      font-size:14px;
    }
    .lootCard button{
      margin-top:10px;
      width:100%;
      padding:10px 12px;
      border:0;
      border-radius:10px;
      background:#2d6cff;
      color:#fff;
      font-weight:800;
      font-size:15px;
    }
    .lootCard.common{
      border-color:#3a3a3a;
      box-shadow:0 0 8px rgba(255,255,255,0.1);
    }
    .lootCard.rare{
      border-color:#2f7bff;
      box-shadow:0 0 14px rgba(0,140,255,0.6);
    }
    .lootCard.epic{
      border-color:#b44dff;
      box-shadow:0 0 18px rgba(180,80,255,0.9);
      animation:epicGlow 1.5s infinite alternate;
    }
    @keyframes epicGlow{
      from{ box-shadow:0 0 10px rgba(180,80,255,0.6); }
      to{ box-shadow:0 0 25px rgba(255,120,255,1); }
    }

    /* ============================= */
    /* âœ… ì¥ë¹„/ê°€ë°©/ì¹´ì˜¤ìŠ¤: ë¶„ë¦¬ ì°½ UI */
    /* ============================= */
    #hudBtns{
      position:fixed;
      top:10px; left:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      z-index:80;
    }
    .hudBtn{
      width:44px;height:44px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(20,20,20,0.86);
      color:#fff;
      font-size:20px;
      box-shadow:0 0 14px rgba(0,0,0,0.45);
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
    }
    .hudBtn:active{ transform:scale(0.96); }

    /* ê³µí†µ ì˜¤ë²„ë ˆì´ */
    .panelOverlay{
      position:fixed;
      inset:0;
      display:none;
      background:rgba(0,0,0,0.55);
      z-index:9999;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
      align-items:center;
      justify-content:center;
    }

    /* ê³µí†µ íŒ¨ë„ */
    .panel{
      width:min(96vw, 980px);
      height:min(90vh, 760px);
      background:#141414;
      border:2px solid #3a3a3a;
      border-radius:14px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .panelTop{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:10px;
    }
    .panelClose{
      padding:8px 12px;
      border-radius:12px;
      border:1px solid #3a3a3a;
      background:#202020;
      color:#f0f0f0;
      cursor:pointer;
      font-size:13px;
    }
    .panelClose:hover{ border-color:#888; }

    /* ===== ì¥ë¹„/ìŠ¤í™ íŒ¨ë„ ===== */
    #equipPanelBody{
      flex:1 1 auto;
      display:flex;
      gap:12px;
      min-height:0;
    }
    #equipSlots{
      flex:0 0 44%;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      align-content:start;
    }
    .eSlot{
      border:1px solid #444;
      border-radius:12px;
      background:#1a1a1a;
      padding:10px;
      min-height:84px;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:6px;
    }
    .eSlot:hover{ border-color:#888; }
    .eSlot.selected{ outline:2px solid #ffd166; }
    .eSlot .label{ font-size:12px; color:#aaa; text-transform:uppercase; letter-spacing:0.06em; }
    .eSlot .item{ font-size:14px; color:#f2f2f2; line-height:1.2; word-break:break-word; }

    #specBox{
      flex:1 1 auto;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }
    #specText{
      flex:0 0 auto;
      white-space:pre-line;
      font-size:13px;
      color:#eee;
      background:#0f0f0f;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:10px;
    }
    #equipInfo{
      flex:1 1 auto;
      overflow:auto;
      white-space:pre-line;
      font-size:13px;
      color:#ddd;
      background:#0f0f0f;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:10px;
    }

    /* ===== ê°€ë°© íŒ¨ë„ ===== */
    #bagBody{
      flex:1 1 auto;
      display:flex;
      gap:12px;
      min-height:0;
    }
    #bagGrid{
      flex:0 0 60%;
      display:grid;
      grid-template-columns: repeat(6, 1fr);
      gap:8px;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:10px;
      box-sizing:border-box;
      align-content:start;
      min-height:0;
    }
    .bItem{
      border:1px solid #555;
      border-radius:12px;
      background:#171717;
      min-height:56px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }
    .bItem:hover{ border-color:#888; }
    .bItem.selected{ outline:2px solid #6bf178; }
    .bItem.unique{ border-color:#b89b00; }

    .iconCanvas{
      width:40px;height:40px;
      image-rendering:pixelated;
    }

    #bagInfo{
      flex:1 1 auto;
      overflow:auto;
      white-space:pre-line;
      font-size:13px;
      color:#ddd;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
    }

    /* ===== ì¹´ì˜¤ìŠ¤ íŒ¨ë„ ===== */
    #chaosBody{
      flex:1 1 auto;
      display:flex;
      gap:12px;
      min-height:0;
    }
    #chaosLeft{
      flex:1 1 auto;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    #chaosCount{
      font-size:18px;
      font-weight:900;
      color:#fff;
    }
    #chaosBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #3a3a3a;
      background:#2d6cff;
      color:#fff;
      font-weight:900;
      cursor:pointer;
    }
    #chaosBtn:active{ transform:scale(0.98); }

    #chaosInfo{
      flex:1 1 auto;
      overflow:auto;
      white-space:pre-line;
      font-size:13px;
      color:#ddd;
      background:#0f0f0f;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
    }

    /* ëª¨ë°”ì¼ */
    @media (max-width: 600px){
      #bagGrid{ grid-template-columns: repeat(4, 1fr); }
      #equipPanelBody{ flex-direction:column; }
      #equipSlots{ grid-template-columns:1fr 1fr; flex:0 0 auto; }
      #bagBody{ flex-direction:column; }
      #bagGrid{ flex:0 0 auto; }
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<!-- âœ… ìƒë‹¨ í€µ ë²„íŠ¼(ì¥ë¹„/ê°€ë°©/ì¹´ì˜¤ìŠ¤) -->
<div id="hudBtns">
  <button class="hudBtn" id="btnEquip" title="ì¥ë¹„/ìŠ¤í™">âš”ï¸</button>
  <button class="hudBtn" id="btnBag"   title="ê°€ë°©">ğŸ’</button>
  <button class="hudBtn" id="btnChaosWnd" title="ì¹´ì˜¤ìŠ¤">ğŸŒ€</button>
</div>

<!-- âœ… ì•„ì´í…œ ì„ íƒ UI -->
<div id="lootOverlay">
  <div id="lootPanel">
    <div id="lootTitle">ì•„ì´í…œ ì„ íƒ (1ê°œë§Œ)</div>
    <div class="lootCards" id="lootCards"></div>
    <div class="lootHint" style="color:#aaa;font-size:12px;margin-top:10px;text-align:center;">ì„ íƒí•˜ë©´ ì¦‰ì‹œ ì ìš©ë©ë‹ˆë‹¤.</div>
  </div>
</div>

<!-- âœ… ì¥ë¹„/ìŠ¤í™ íŒ¨ë„ -->
<div class="panelOverlay" id="equipOverlay">
  <div class="panel">
    <div class="panelTop">
      <button class="panelClose" id="btnEquipClose" type="button">ë‹«ê¸°</button>
    </div>
    <div id="equipPanelBody">
      <div id="equipSlots"></div>
      <div id="specBox">
        <div id="specText"></div>
        <div id="equipInfo"></div>
      </div>
    </div>
  </div>
</div>

<!-- âœ… ê°€ë°© íŒ¨ë„ -->
<div class="panelOverlay" id="bagOverlay">
  <div class="panel">
    <div class="panelTop">
      <button class="panelClose" id="btnBagClose" type="button">ë‹«ê¸°</button>
    </div>
    <div id="bagBody">
      <div id="bagGrid"></div>
      <div id="bagInfo"></div>
    </div>
  </div>
</div>

<!-- âœ… ì¹´ì˜¤ìŠ¤ íŒ¨ë„ -->
<div class="panelOverlay" id="chaosOverlay">
  <div class="panel">
    <div class="panelTop">
      <button class="panelClose" id="btnChaosClose" type="button">ë‹«ê¸°</button>
    </div>
    <div id="chaosBody">
      <div id="chaosLeft">
        <div id="chaosCount"></div>
        <button id="chaosBtn" type="button">ì¹´ì˜¤ìŠ¤</button>
      </div>
      <div id="chaosInfo"></div>
    </div>
  </div>
</div>

<div id="ui">
  <div id="movePad"><div id="stick"></div></div>
  <div id="rightBtns">
    <div id="attackBtn">
      <canvas id="attackIcon" width="60" height="60"></canvas>
    </div>
  </div>
</div>

<script>
let gamePaused = false;
let pauseOpts = { dim: 0.60, blur: 2 };
let resumeFade = 0;
let resumeFadeMax = 10;

const pauseCanvas = document.createElement("canvas");
const pauseCtx = pauseCanvas.getContext("2d");

function capturePausedFrame(opts = pauseOpts){
  pauseOpts = opts || pauseOpts;
  draw();
  pauseCanvas.width = canvas.width;
  pauseCanvas.height = canvas.height;

  pauseCtx.setTransform(1,0,0,1,0,0);
  pauseCtx.globalAlpha = 1;
  pauseCtx.filter = (pauseOpts.blur > 0) ? `blur(${pauseOpts.blur}px)` : "none";
  pauseCtx.drawImage(canvas, 0, 0);
  pauseCtx.filter = "none";

  if(pauseOpts.dim > 0){
    pauseCtx.globalAlpha = pauseOpts.dim;
    pauseCtx.fillStyle = "#000";
    pauseCtx.fillRect(0,0,pauseCanvas.width,pauseCanvas.height);
    pauseCtx.globalAlpha = 1;
  }
}

function pauseGame(opts){
  if(gamePaused) return;
  resumeFade = 0;
  capturePausedFrame(opts);
  gamePaused = true;
}

function resumeGame(){
  if(resumeFade > 0) return;
  resumeFade = resumeFadeMax;
  gamePaused = false;
}

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const ui = document.getElementById("ui");

let uiHeight = 120;

function resize(){
  uiHeight = ui.getBoundingClientRect().height || 120;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - uiHeight;
  if(gamePaused) capturePausedFrame(pauseOpts);
}
resize();
window.addEventListener("resize", ()=>requestAnimationFrame(resize));
requestAnimationFrame(resize);

/* ===== ì‚¬ìš´ë“œ ===== */
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let audioUnlocked = false;

function unlockAudio(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  audioCtx.resume().then(()=>{
    if(!bgmOsc) bgmOsc = startBGM();
  });
}
window.addEventListener("touchstart", unlockAudio, { once:true });
window.addEventListener("mousedown", unlockAudio, { once:true });
window.addEventListener("keydown", unlockAudio, { once:true });

function startBGM(){
  let isPlaying = true;
  function getTempo(){
    if(killCount >= 100) return 150;
    if(killCount >= 50) return 130;
    return 110;
  }
  function playBeat(){
    if(!isPlaying) return;

    let tempo = getTempo();
    let beatTime = 60 / tempo;
    let now = audioCtx.currentTime;

    let kick = audioCtx.createOscillator();
    let kickGain = audioCtx.createGain();
    kick.type = "triangle";
    kick.frequency.setValueAtTime(90, now);
    kick.frequency.exponentialRampToValueAtTime(50, now + 0.12);
    kickGain.gain.setValueAtTime(0.18, now);
    kickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    kick.connect(kickGain);
    kickGain.connect(audioCtx.destination);
    kick.start(now);
    kick.stop(now + 0.15);

    let tone = audioCtx.createOscillator();
    let toneGain = audioCtx.createGain();
    tone.type = "square";
    tone.frequency.value = 220;
    toneGain.gain.setValueAtTime(0.06, now + beatTime/2);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + beatTime/2 + 0.1);
    tone.connect(toneGain);
    toneGain.connect(audioCtx.destination);
    tone.start(now + beatTime/2);
    tone.stop(now + beatTime/2 + 0.1);

    setTimeout(playBeat, beatTime * 1000);
  }
  playBeat();
  return { stop: () => isPlaying = false };
}
let bgmOsc;

function swingSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="sawtooth";
  o.frequency.setValueAtTime(700,audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(200,audioCtx.currentTime+0.12);
  g.gain.value=0.15;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.12);
}
function bossUnsheatheSound(){
  let now = audioCtx.currentTime;

  let o1 = audioCtx.createOscillator();
  let g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(120, now);
  o1.frequency.exponentialRampToValueAtTime(600, now + 0.6);
  g1.gain.setValueAtTime(0.4, now);
  g1.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
  o1.connect(g1);
  g1.connect(audioCtx.destination);
  o1.start(now);
  o1.stop(now + 0.6);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(900, now);
  o2.frequency.exponentialRampToValueAtTime(200, now + 0.4);
  g2.gain.setValueAtTime(0.3, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.4);
}
function thudSound(){
  let now = audioCtx.currentTime;

  let o = audioCtx.createOscillator();
  let g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.setValueAtTime(120, now);
  o.frequency.exponentialRampToValueAtTime(55, now + 0.14);
  g.gain.setValueAtTime(0.32, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start(now);
  o.stop(now + 0.18);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(220, now);
  o2.frequency.exponentialRampToValueAtTime(90, now + 0.08);
  g2.gain.setValueAtTime(0.12, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.09);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.09);
}
function hitSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="square";
  o.frequency.value=100;
  g.gain.value=0.25;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.08);
}

/* ===== í”Œë ˆì´ì–´ ===== */
let player={
  x:0,y:0,
  dir:"left",
  speed:5,
  radius:14,

  hp:100,
  maxHp:100,
  baseMaxHp:100,

  baseArmor:0,
  invul:0,
  knockbackX:0,
  knockbackY:0,

  kiOrbs:0,
  maxOrbs:5,
  levelGlow:0,
  ultiActive:false,
  ultiCount:0,
  ultiTimer:0,

  buffs: { dmgMul:1, spdMul:1, atkSpdMul:1 },
  activeBuffs: []
};

player.weapon = {
  name: "Rusty Katana",
  min: 14,
  max: 20,
  critChance: 0.06,
  critMulti: 1.50
};

let map = [];
let mapSize = 30;
let tileSize = 48;

for(let y=0; y<mapSize; y++){
  let row = [];
  for(let x=0; x<mapSize; x++){
    if(x===0 || y===0 || x===mapSize-1 || y===mapSize-1) row.push(1);
    else row.push(0);
  }
  map.push(row);
}

player.x = mapSize * tileSize / 2;
player.y = mapSize * tileSize / 2;

let reachableMask = null;
let hpWaveOffset = 0;
let slowMotion = 0;
let spawnTimer = 0;
let spawnInterval = 90;
let enemies=[];
let packs = [];

/* ============================= */
/* âœ… ì•„ì´í…œ ë“œë/ì„ íƒ ì‹œìŠ¤í…œ     */
/* ============================= */
let loots = [];
let lootOverlayOpen = false;
let pendingLoot = null;

const lootOverlay = document.getElementById("lootOverlay");
const lootCardsEl = document.getElementById("lootCards");

/* ============================= */
/* âœ… POEì‹ Affix/Tier/ilvl ì‹œìŠ¤í…œ */
/* ============================= */
function getItemLevel(){
  return Math.floor(mapTier * 10 + level * 1.5);
}
function weightedPick(list, weightKey="weight"){
  let total = 0;
  for(const it of list) total += (it[weightKey] ?? 0);
  let r = Math.random() * total;
  for(const it of list){
    r -= (it[weightKey] ?? 0);
    if(r <= 0) return it;
  }
  return list[list.length - 1];
}

const AFFIX_DB = {
  prefix: [
    {
      id:"p_phys", name:"Brutal", group:"dmgMul", weight:100,
      tiers:[
        { t:1, minIlvl:70, min:0.22, max:0.30, w:20 },
        { t:2, minIlvl:50, min:0.16, max:0.21, w:35 },
        { t:3, minIlvl:30, min:0.10, max:0.15, w:60 },
        { t:4, minIlvl:1,  min:0.05, max:0.09, w:90 }
      ],
      apply:(data, roll)=>{ data.dmgMul *= (1 + roll); }
    },
    {
      id:"p_ulti", name:"Cataclysm", group:"ultiMul", weight:80,
      tiers:[
        { t:1, minIlvl:70, min:0.25, max:0.33, w:20 },
        { t:2, minIlvl:45, min:0.18, max:0.24, w:40 },
        { t:3, minIlvl:20, min:0.10, max:0.17, w:70 },
        { t:4, minIlvl:1,  min:0.06, max:0.09, w:90 }
      ],
      apply:(data, roll)=>{ data.ultiMul *= (1 + roll); }
    },
    {
      id:"p_range", name:"Wide", group:"rangeMul", weight:70,
      tiers:[
        { t:1, minIlvl:60, min:0.18, max:0.24, w:25 },
        { t:2, minIlvl:35, min:0.12, max:0.17, w:45 },
        { t:3, minIlvl:1,  min:0.06, max:0.11, w:80 }
      ],
      apply:(data, roll)=>{ data.rangeMul *= (1 + roll); }
    },
    {
      id:"p_crit", name:"Keen", group:"critChanceAdd", weight:55,
      tiers:[
        { t:1, minIlvl:65, min:0.04, max:0.06, w:20 },
        { t:2, minIlvl:40, min:0.025, max:0.039, w:45 },
        { t:3, minIlvl:1,  min:0.01, max:0.024, w:85 }
      ],
      apply:(data, roll)=>{ data.critChanceAdd += roll; }
    }
  ],
  suffix: [
    {
      id:"s_hp", name:"of Vitality", group:"maxHpAdd", weight:100,
      tiers:[
        { t:1, minIlvl:70, min:45, max:70, w:22 },
        { t:2, minIlvl:45, min:30, max:44, w:40 },
        { t:3, minIlvl:20, min:18, max:29, w:70 },
        { t:4, minIlvl:1,  min:10, max:17, w:95 }
      ],
      apply:(data, roll)=>{ data.maxHpAdd += roll; }
    },
    {
      id:"s_armor", name:"of Fortitude", group:"armorAdd", weight:85,
      tiers:[
        { t:1, minIlvl:70, min:18, max:26, w:22 },
        { t:2, minIlvl:45, min:12, max:17, w:40 },
        { t:3, minIlvl:20, min:7,  max:11, w:70 },
        { t:4, minIlvl:1,  min:3,  max:6,  w:95 }
      ],
      apply:(data, roll)=>{ data.armorAdd += roll; }
    },
    {
      id:"s_regen", name:"of Regeneration", group:"hpRegen", weight:60,
      tiers:[
        { t:1, minIlvl:65, min:2.2, max:3.4, w:22 },
        { t:2, minIlvl:35, min:1.4, max:2.1, w:45 },
        { t:3, minIlvl:1,  min:0.6, max:1.3, w:85 }
      ],
      apply:(data, roll)=>{ data.hpRegen += roll; }
    },
    {
      id:"s_critmulti", name:"of the Assassin", group:"critMultiAdd", weight:55,
      tiers:[
        { t:1, minIlvl:70, min:0.35, max:0.55, w:20 },
        { t:2, minIlvl:40, min:0.20, max:0.34, w:45 },
        { t:3, minIlvl:1,  min:0.10, max:0.19, w:85 }
      ],
      apply:(data, roll)=>{ data.critMultiAdd += roll; }
    }
  ]
};

function rollTierValue(affix, ilvl){
  const avail = affix.tiers.filter(t => ilvl >= t.minIlvl);
  const picked = weightedPick(avail.map(t=>({ ...t, weight:t.w })));
  const isInt = Number.isInteger(picked.min) && Number.isInteger(picked.max);
  let v = picked.min + Math.random() * (picked.max - picked.min);
  if(isInt) v = Math.floor(v);
  else v = Math.round(v * 1000) / 1000;
  return { tier:picked.t, value:v };
}
function affixCountsByRarity(r){
  if(r === "common") return { pre:1, suf:0, total:1 };
  if(r === "rare")   return { pre:1, suf:1, total:2 };
  if(r === "epic")   return { pre:2, suf:1, total:3 };
  return { pre:0, suf:0, total:0 };
}
function rollAffixesPOE(rarity, ilvl){
  const cnt = affixCountsByRarity(rarity);
  const pickedPre = [];
  const pickedSuf = [];
  const usedGroups = new Set();

  function pickFrom(pool, count){
    const out = [];
    let guard = 0;
    while(out.length < count && guard++ < 500){
      const cand = weightedPick(pool);
      if(usedGroups.has(cand.group)) continue;
      usedGroups.add(cand.group);
      out.push(cand);
    }
    return out;
  }

  pickedPre.push(...pickFrom(AFFIX_DB.prefix, cnt.pre));
  pickedSuf.push(...pickFrom(AFFIX_DB.suffix, cnt.suf));

  const rolled = [];
  for(const a of pickedPre){
    const rr = rollTierValue(a, ilvl);
    rolled.push({ kind:"prefix", affix:a, tier:rr.tier, value:rr.value });
  }
  for(const a of pickedSuf){
    const rr = rollTierValue(a, ilvl);
    rolled.push({ kind:"suffix", affix:a, tier:rr.tier, value:rr.value });
  }
  return rolled;
}

function makeEmptyItemData(){
  return {
    dmgMul: 1,
    ultiMul: 1,
    rangeMul: 1,
    spdMul: 1,
    armorAdd: 0,
    maxHpAdd: 0,
    hpRegen: 0,
    critChanceAdd: 0,
    critMultiAdd: 0
  };
}
function mergeItemData(baseData, affixData){
  const out = makeEmptyItemData();
  out.dmgMul   = (baseData.dmgMul   ?? 1) * (affixData.dmgMul   ?? 1);
  out.ultiMul  = (baseData.ultiMul  ?? 1) * (affixData.ultiMul  ?? 1);
  out.rangeMul = (baseData.rangeMul ?? 1) * (affixData.rangeMul ?? 1);
  out.spdMul   = (baseData.spdMul   ?? 1) * (affixData.spdMul   ?? 1);

  out.armorAdd      = (baseData.armorAdd      ?? 0) + (affixData.armorAdd      ?? 0);
  out.maxHpAdd      = (baseData.maxHpAdd      ?? 0) + (affixData.maxHpAdd      ?? 0);
  out.hpRegen       = (baseData.hpRegen       ?? 0) + (affixData.hpRegen       ?? 0);
  out.critChanceAdd = (baseData.critChanceAdd ?? 0) + (affixData.critChanceAdd ?? 0);
  out.critMultiAdd  = (baseData.critMultiAdd  ?? 0) + (affixData.critMultiAdd  ?? 0);
  return out;
}

function buildBaseDataFromItemId(itemId){
  const base = makeEmptyItemData();

  if(itemId === "dmg_up"){
    const v = Math.floor(8 + level * 1.2 + mapTier * 1.5);
    base.dmgMul *= (1 + v/100);
  }else if(itemId === "ulti_up"){
    const v = Math.floor(12 + level * 1.5 + mapTier * 2);
    base.ultiMul *= (1 + v/100);
  }else if(itemId === "hp"){
    const v = Math.floor(15 + level*3 + mapTier*4);
    base.maxHpAdd += v;
  }else if(itemId === "armor"){
    const v = Math.floor(5 + mapTier*2);
    base.armorAdd += v;
  }else if(itemId === "ring_crit"){
    const cc = (0.015 + mapTier*0.002 + level*0.0006);
    const cm = (0.10  + mapTier*0.01  + level*0.002);
    base.critChanceAdd += cc;
    base.critMultiAdd  += cm;
  }else if(itemId === "ring_regen"){
    const r = (0.6 + mapTier*0.08 + level*0.03);
    const hp = Math.floor(6 + mapTier*2 + level*1.2);
    base.hpRegen += r;
    base.maxHpAdd += hp;
  }else if(itemId === "ring_speed"){
    const ms = Math.floor(6 + mapTier*1.2 + level*0.8);
    base.spdMul *= (1 + ms/100);
  }
  return base;
}

const ITEM_POOL = [
  { id:"dmg_up",     slot:"weapon", name:"ê°•í™”ëœ ì¼ê²©", rarity:"common", descGen:(d)=>`í‰íƒ€ í”¼í•´ +${Math.round(((d.dmgMul ?? 1)-1)*100)}%` },
  { id:"ulti_up",    slot:"weapon", name:"í­ë°œ ê°•í™”",   rarity:"common", descGen:(d)=>`ê¶ê·¹ê¸° í”¼í•´ +${Math.round(((d.ultiMul ?? 1)-1)*100)}%` },
  { id:"hp",         slot:"chest",  name:"ìƒëª…ì˜ ì •ìˆ˜", rarity:"rare",   descGen:(d)=>`ìµœëŒ€ ì²´ë ¥ +${Math.floor(d.maxHpAdd ?? 0)}` },
  { id:"armor",      slot:"helm",   name:"ì² ë²½ ê°‘ì˜·",   rarity:"rare",   descGen:(d)=>`ë°©ì–´ë ¥ +${Math.floor(d.armorAdd ?? 0)}` },
  { id:"ring_crit",  slot:"ring",   name:"ì¹˜ëª… ë°˜ì§€",   rarity:"rare",   descGen:(d)=>`ì¹˜í™• +${Math.round((d.critChanceAdd ?? 0)*100)}% / ì¹˜í”¼ +${Math.round((d.critMultiAdd ?? 0)*100)}%` },
  { id:"ring_regen", slot:"ring",   name:"ìƒëª… ë°˜ì§€",   rarity:"common", descGen:(d)=>`ì¬ìƒ +${(d.hpRegen ?? 0).toFixed(2)}/s / ìµœëŒ€ì²´ë ¥ +${Math.floor(d.maxHpAdd ?? 0)}` },
  { id:"ring_speed", slot:"ring",   name:"ì§ˆì£¼ ë°˜ì§€",   rarity:"common", descGen:(d)=>`ì´ì† +${Math.round(((d.spdMul ?? 1)-1)*100)}%` }
];

function createItemInstance(baseId, rarityOverride=null){
  const tmpl = ITEM_POOL.find(x => x.id === baseId);
  if(!tmpl) return null;

  const rarity = rarityOverride || tmpl.rarity || "common";
  const ilvl = getItemLevel();

  const baseData = buildBaseDataFromItemId(baseId);
  const affixes = rollAffixesPOE(rarity, ilvl);

  const affixData = makeEmptyItemData();
  for(const a of affixes){
    if(a && a.affix && typeof a.affix.apply === "function"){
      a.affix.apply(affixData, a.value);
    }
  }
  const totalData = mergeItemData(baseData, affixData);

  const preNames = affixes.filter(x=>x.kind==="prefix").map(x=>x.affix.name);
  const sufNames = affixes.filter(x=>x.kind==="suffix").map(x=>x.affix.name);

  let nm = tmpl.name;
  if(preNames.length) nm = preNames.join(" ") + " " + nm;
  if(sufNames.length) nm = nm + " " + sufNames.join(" ");

  return {
    id: baseId,
    baseId,
    baseName: tmpl.name,
    name: nm,
    rarity,
    slot: tmpl.slot,
    ilvl,
    isUnique: false,
    data: totalData,
    totalData,
    baseData,
    affixData,
    affixes,
    shownDesc: tmpl.descGen ? tmpl.descGen(totalData) : ""
  };
}

function giveStarterItems(){
  const starters = ["dmg_up", "armor", "hp", "ring_speed"];
  for(const id of starters){
    const it = createItemInstance(id);
    if(it) inventory.push(it);
  }
}

/* ============================= */
/* âœ… ì „ì„¤(Unique) ì‹œìŠ¤í…œ         */
/* ============================= */
let ownedUniques = [];
let uniqueState = {};

function emitEvent(type, payload){
  for(const u of ownedUniques){
    if(u.onEvent) u.onEvent(type, payload);
  }
}
function cloneLegendary(template){
  return {
    id: template.id,
    name: template.name,
    rarity: template.rarity ?? "legendary",
    desc: template.desc ?? "",
    applyStat: template.applyStat,
    onEvent: template.onEvent,
  };
}

function acquireLegendary(template, ilvl){
  if(ownedUniques.some(u => u.id === template.id)){
    shake = Math.max(shake, 6);
    return;
  }
  const u = cloneLegendary(template);
  if(u.applyStat) u.applyStat();
  ownedUniques.push(u);

  inventory.push({
    id: u.id,
    slot: "unique",
    name: u.name,
    rarity: "legendary",
    ilvl,
    isUnique: true,
    uniqueRef: u,
    data: null,
    affixes: []
  });

  recalcFromGear();
}

const LEGENDARY_POOL = [
  {
    id:"unique_thunderstep",
    name:"ì²œë‘¥ê±¸ìŒ (Thunderstep)",
    rarity:"legendary",
    desc:"ì  ì²˜ì¹˜ ì‹œ ë²ˆê°œê°€ ì£¼ë³€ìœ¼ë¡œ ì—°ì‡„ (ì¿¨ 0.8ì´ˆ)",
    applyStat(){ applyGearDelta({ dmgMul: 1.10 }); },
    onEvent(type, p){
      if(type !== "kill") return;

      const now = frameCount;
      const key = this.id + "_cd";
      const cd = uniqueState[key] ?? 0;
      if(now < cd) return;
      uniqueState[key] = now + 48;

      const cx = p.x, cy = p.y;
      let hits = 0;

      for(const e of enemies){
        if(e.hp <= 0) continue;
        if(e.type === "boss" && e.dead) continue;

        const dx = e.x - cx, dy = e.y - cy;
        if(dx*dx + dy*dy > 200*200) continue;

        e.hp -= baseDamage * 0.65;
        spawnHitBlood(e.x, e.y, 8);

        if(particles.length < 260){
          for(let i=0;i<6;i++){
            particles.push({ x:e.x, y:e.y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:18 });
          }
        }
        hits++;
        if(hits >= 4) break;
      }
      pruneDeadEnemies();
    }
  },
  {
    id:"unique_oni_aegis",
    name:"ì˜¤ë‹ˆì˜ ìˆ˜í˜¸ (Oni Aegis)",
    rarity:"legendary",
    desc:"í”¼ê²© ì‹œ ë³´í˜¸ë§‰ 1íšŒ ìƒì„± (í”¼í•´ 35% ê°ì†Œ ëŠë‚Œ, 2ì´ˆ, ì¿¨ 6ì´ˆ)",
    applyStat(){
      player.baseArmor += 4;
      player.baseMaxHp += 20;
      player.hp += 20;
    },
    onEvent(type, p){
      if(type !== "takeDamage") return;
      const now = frameCount;
      const cdKey = this.id + "_cd";
      if((uniqueState[cdKey] ?? 0) > now) return;

      applyBuff(player, "armor", 30, 120, "oni_aegis", "add");
      uniqueState[cdKey] = now + 360;

      shake = Math.max(shake, 12);
      for(let i=0;i<22;i++){
        particles.push({ x:player.x, y:player.y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:22 });
      }
    }
  },
  {
    id:"unique_bloodkatana",
    name:"í˜ˆê·€ì˜ ë„ (Blood Katana)",
    rarity:"legendary",
    desc:"íƒ€ê²© ì‹œ 20% í™•ë¥ ë¡œ ì¶œí˜ˆ ì¥íŒ ìƒì„±(3ì´ˆ). ì¥íŒì€ ì´ˆë‹¹ í”¼í•´ + í¡í˜ˆ",
    applyStat(){
      baseDamageBase *= 1.08;
      recalcFromGear();
    },
    onEvent(type, p){
      if(type !== "hit") return;
      if(Math.random() > 0.20) return;

      const x = p.enemy.x;
      const y = p.enemy.y;

      fireZones.push({
        x, y,
        radius:60,
        life:180,
        tick:0,
        damage: Math.max(2, baseDamage * 0.18),
        isBleed:true
      });
    }
  }
];

function rollRarity(){
  const t = mapTier;
  const legendary = clamp(0.004 + (t-1)*0.0003, 0.004, 0.025);
  const epic = clamp(0.03 + (t-1)*0.002, 0.03, 0.08);
  const rare = clamp(0.18 + (t-1)*0.004, 0.18, 0.32);

  const r = Math.random();
  if(r < legendary) return "legendary";
  if(r < legendary + epic) return "epic";
  if(r < legendary + epic + rare) return "rare";
  return "common";
}

function pickItemsForChoice(count=3){
  const rarity = rollRarity();

  if(rarity === "legendary"){
    const picks = [];
    let guard = 0;
    while(picks.length < count && guard++ < 200){
      const it = LEGENDARY_POOL[(Math.random()*LEGENDARY_POOL.length)|0];
      if(!it) continue;
      if(picks.some(p=>p.id===it.id)) continue;
      picks.push(it);
    }
    return picks;
  }

  const candidates = ITEM_POOL.filter(it => it.rarity === rarity);
  const fallback = ITEM_POOL;

  let picks = [];
  let guard = 0;
  while(picks.length < count && guard++ < 200){
    const src = (Math.random() < 0.85 ? candidates : fallback);
    const it = src[(Math.random()*src.length)|0];
    if(!it) continue;
    if(picks.some(p=>p.id===it.id)) continue;
    picks.push(it);
  }
  while(picks.length < count){
    const it = fallback[(Math.random()*fallback.length)|0];
    if(!picks.some(p=>p.id===it.id)) picks.push(it);
  }
  return picks;
}

function spawnLoot(x, y, source="mob"){
  if(loots.length > 25) loots.splice(0, loots.length-25);
  const choices = pickItemsForChoice(3);
  loots.push({ x, y, r: 14, ttl: 60*45, choices, taken: false, source });
}

function getNearbyLoot(){
  for(const L of loots){
    if(L.taken) continue;
    const dx = L.x - player.x;
    const dy = L.y - player.y;
    const rr = (L.r + player.radius + 18);
    if(dx*dx + dy*dy <= rr*rr) return L;
  }
  return null;
}

function openLootChoice(L){
  if(!L || L.taken) return;
  pauseGame({ dim: 0.60, blur: 2 });
  lootOverlayOpen = true;
  pendingLoot = L;

  lootOverlay.style.display = "flex";
  lootCardsEl.innerHTML = "";

  L.choices.forEach((it)=>{
    const card = document.createElement("div");
    card.className = `lootCard ${it.rarity}`;

    const ilvl = getItemLevel();
    const pick = { it, ilvl };

    if(it.rarity === "legendary"){
      pick.kind = "legendary";
      pick.shownName = it.name;
      pick.shownDesc = it.desc;
    }else{
      pick.kind = "normal";
      pick.baseData = buildBaseDataFromItemId(it.id);
      pick.affixes = rollAffixesPOE(it.rarity, ilvl);

      const affixData = makeEmptyItemData();
      for(const a of pick.affixes){
        a.affix.apply(affixData, a.value);
      }
      pick.affixData = affixData;
      pick.totalData = mergeItemData(pick.baseData, pick.affixData);

      const preNames = pick.affixes.filter(x=>x.kind==="prefix").map(x=>x.affix.name);
      const sufNames = pick.affixes.filter(x=>x.kind==="suffix").map(x=>x.affix.name);

      pick.baseName = it.name;
      pick.baseId = it.id;

      let nm = pick.baseName;
      if(preNames.length) nm = preNames.join(" ") + " " + nm;
      if(sufNames.length) nm = nm + " " + sufNames.join(" ");
      pick.name = nm;

      pick.shownName = pick.name;
      pick.shownDesc = it.descGen ? it.descGen(pick.totalData) : (it.desc || "");
    }

    card.innerHTML = `
      <div class="name">[${it.rarity.toUpperCase()}] ${pick.shownName}</div>
      <div class="desc">${pick.shownDesc}</div>
      <button type="button">ì´ê±¸ ì„ íƒ</button>
    `;

    card.querySelector("button").addEventListener("click", ()=>{
      if(pick.kind === "legendary"){
        acquireLegendary(pick.it, pick.ilvl);
      } else {
        const chosen = {
          id: pick.baseId,
          baseId: pick.baseId,
          baseName: pick.baseName,
          name: pick.name,
          rarity: pick.it.rarity,
          slot: pick.it.slot,
          ilvl: pick.ilvl,
          isUnique: false,
          data: pick.totalData,
          totalData: pick.totalData,
          baseData: pick.baseData,
          affixData: pick.affixData,
          affixes: pick.affixes,
          shownDesc: pick.shownDesc
        };
        inventory.push(chosen);
        if(panelOpen) renderAllPanels();
      }
      L.taken = true;
      closeLootChoice();
      shake = Math.max(shake, 10);
    });

    lootCardsEl.appendChild(card);
  });
}

function closeLootChoice(){
  lootOverlayOpen = false;
  pendingLoot = null;
  lootOverlay.style.display = "none";
  resumeGame();
}

function updateLoots(){
  for(let i=loots.length-1;i>=0;i--){
    const L = loots[i];
    if(L.taken){ loots.splice(i,1); continue; }
    L.ttl--;
    if(L.ttl <= 0) loots.splice(i,1);
  }
}
function drawLoots(){
  if(loots.length === 0) return;

  ctx.save();
  for(const L of loots){
    if(L.taken) continue;

    const pulse = 0.5 + 0.5*Math.sin(frameCount*0.15);
    ctx.globalAlpha = 0.75 + pulse*0.25;

    ctx.fillStyle = "rgba(80,140,255,0.25)";
    ctx.beginPath();
    ctx.arc(L.x, L.y, L.r + 10 + pulse*6, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(40,120,255,0.9)";
    ctx.beginPath();
    ctx.arc(L.x, L.y, L.r, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.fillStyle = "#fff";
    ctx.font = "bold 16px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("!", L.x, L.y+1);
  }
  ctx.restore();
}

/* ============================= */
/* âœ… POEì‹ ì¥ë¹„ ìŠ¬ë¡¯ / ì¸ë²¤í† ë¦¬  */
/* ============================= */
const EQUIP_SLOTS = ["weapon","helm","chest","ring"];
let equipment = { weapon:null, helm:null, chest:null, ring:null };

let inventory = [];
let selectedInvIndex = -1;

let chaosOrbs = 2;

let orbUIState = { cx:0, cy:0, centerR:24, ready:false };
let particles=[];
let bloodPools=[];
let shake=0;
let xp = 0;
let xpToNext = 120;
let level = 1;
let gameOver = false;
let orbFlash = 0;
let flashEffect = 0;

let baseDamageBase = 20;
let ultiDamageBase = 40;

let baseDamage = baseDamageBase;
let ultiDamage = ultiDamageBase;

player.gear = {
  dmgMul: 1,
  ultiMul: 1,
  spdMul: 1,
  atkSpdMul: 1,
  rangeMul: 1,
  armorAdd: 0,
  maxHpAdd: 0,
  hpRegen: 0,
  critChanceAdd: 0,
  critChanceMul: 1,
  critMultiAdd: 0,
};

function recalcFromGear(){
  baseDamage = baseDamageBase * (player.gear.dmgMul ?? 1);
  ultiDamage = ultiDamageBase * (player.gear.ultiMul ?? 1);
  updateBuffs(player);
  player.hp = Math.min(player.maxHp, player.hp);
}

function applyGearDelta(delta){
  for(const k in delta){
    const v = delta[k];
    if(typeof v !== "number") continue;
    if(k.endsWith("Mul")){
      player.gear[k] = (player.gear[k] ?? 1) * v;
    }else{
      player.gear[k] = (player.gear[k] ?? 0) + v;
    }
  }
  recalcFromGear();
}

let levelParticles = [];
let arrows = [];
let bloodParticles = [];
let fireZones = [];
let frameCount = 0;

let killCount = 0;
let killsAtLevelStart = 0;
let killsForNextLevel = 20;
let explosionActive = false;
let bossSpawned = false;
let bossTimer = 0;
let bossInterval = 45 * 60;

let mapTier = 1;
let mapSeed = 0;
let mapRun = {
  tier: 1,
  seed: 0,
  packsToClear: 10,
  clearedPacks: 0,
  bossSpawned: false,
  bossDefeated: false,
};

let portal = {
  active: false,
  x: 0,
  y: 0,
  r: 32,
  hold: 0,
  holdNeed: 25
};
let bossRoom = { x:0, y:0, w:0, h:0, cx:0, cy:0, doorX:0, doorY:0 };

/* ===== ì…ë ¥ ===== */
let joyDX=0, joyDY=0;
let attacking=false;
let attackFrame=0;
let keys = {};

window.addEventListener("keydown", e=>{ keys[e.key] = true; });
window.addEventListener("keyup", e=>{ keys[e.key] = false; });

const pad = document.getElementById("movePad");
const stick = document.getElementById("stick");
const attackBtn = document.getElementById("attackBtn");
let joyActive=false;

function bossDeathSound(){
  let now = audioCtx.currentTime;

  let o1 = audioCtx.createOscillator();
  let g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(220, now);
  o1.frequency.exponentialRampToValueAtTime(45, now + 0.6);
  g1.gain.setValueAtTime(0.25, now);
  g1.gain.exponentialRampToValueAtTime(0.001, now + 0.65);
  o1.connect(g1); g1.connect(audioCtx.destination);
  o1.start(now); o1.stop(now + 0.65);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "square";
  o2.frequency.setValueAtTime(900, now + 0.05);
  o2.frequency.exponentialRampToValueAtTime(180, now + 0.18);
  g2.gain.setValueAtTime(0.12, now + 0.05);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.22);
  o2.connect(g2); g2.connect(audioCtx.destination);
  o2.start(now + 0.05); o2.stop(now + 0.22);
}

function setStickByVector(vx, vy){
  const r = pad.getBoundingClientRect();
  const max = Math.min(r.width, r.height) * 0.33;
  let d = Math.hypot(vx, vy) || 1;
  if(d > max){ vx *= max/d; vy *= max/d; }

  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;

  stick.style.left = (r.width/2 - sw/2 + vx) + "px";
  stick.style.top  = (r.height/2 - sh/2 + vy) + "px";

  joyDX = vx / max;
  joyDY = vy / max;

  if(Math.abs(vx) > Math.abs(vy))
    player.dir = vx > 0 ? "right" : "left";
  else
    player.dir = vy > 0 ? "down" : "up";
}

function handlePadMove(clientX, clientY){
  const r = pad.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top + r.height/2;
  const vx = clientX - cx;
  const vy = clientY - cy;
  setStickByVector(vx, vy);
}

pad.addEventListener("touchstart", (e)=>{
  joyActive = true;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchmove", (e)=>{
  if(!joyActive) return;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchend", ()=>{
  joyActive=false; joyDX=joyDY=0;
  const r = pad.getBoundingClientRect();
  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;
  stick.style.left = (r.width/2 - sw/2) + "px";
  stick.style.top  = (r.height/2 - sh/2) + "px";
});

/* ===== attackBtn = í‰íƒ€ë§Œ ===== */
attackBtn.addEventListener("touchstart", ()=>{
  attacking = true;
  attackFrame = 0;
  swingSound();
  attackBtn.classList.add("active");
},{passive:true});

attackBtn.addEventListener("touchend", ()=>{
  attackBtn.classList.remove("active");
},{passive:true});

/* ===== ìœ í‹¸ ===== */
function rollWeaponDamage(){
  const w = player.weapon;
  return w.min + Math.random() * (w.max - w.min);
}

function getCritChance(){
  const w = player.weapon;
  const g = player.gear || {};
  let chance = (w.critChance ?? 0);
  chance += (g.critChanceAdd ?? 0);
  chance *= (g.critChanceMul ?? 1);
  return clamp(chance, 0, 0.95);
}
function getCritMulti(){
  const w = player.weapon;
  const g = player.gear || {};
  const multi = (w.critMulti ?? 1.5) + (g.critMultiAdd ?? 0);
  return Math.max(1.05, multi);
}
function applyCrit(dmg){
  const chance = getCritChance();
  const multi = getCritMulti();
  const isCrit = (Math.random() < chance);
  return { dmg: isCrit ? dmg * multi : dmg, isCrit, chance, multi };
}

function defaultBuffStats(){
  return {
    dmgMul: 1,
    spdMul: 1,
    atkSpdMul: 1,
    rangeMul: 1,
    meleeRangeMul: 1,
    aoeMul: 1,
    ultiAoeMul: 1,
    armorAdd: 0,
    armorMul: 1,
    maxHpMul: 1,
    maxHpAdd: 0,
    hpRegen: 0,
  };
}

function applyBuff(target, type, value, duration, source="", mode="mul"){
  if(!target.activeBuffs) target.activeBuffs = [];
  const key = type + "|" + source + "|" + mode;
  const b = target.activeBuffs.find(x => x.key === key);

  if(b){
    b.value = value;
    b.duration = Math.max(b.duration, duration);
  }else{
    target.activeBuffs.push({ key, type, value, duration, mode });
  }
}

function mapBuffTypeToStat(type){
  if(type === "damage")   return "dmgMul";
  if(type === "speed")    return "spdMul";
  if(type === "atkSpeed") return "atkSpdMul";
  if(type === "range")        return "rangeMul";
  if(type === "meleeRange")   return "meleeRangeMul";
  if(type === "aoe")          return "aoeMul";
  if(type === "ultiAoe")      return "ultiAoeMul";
  if(type === "armor")        return "armorAdd";
  if(type === "armorMul")     return "armorMul";
  if(type === "maxHpMul")     return "maxHpMul";
  if(type === "maxHp")        return "maxHpAdd";
  if(type === "hpRegen")      return "hpRegen";
  return null;
}

function updateBuffs(target){
  if(!target.activeBuffs) target.activeBuffs = [];
  target.buffs = defaultBuffStats();

  if(target === player){
    target.buffs.dmgMul   *= (player.gear.dmgMul ?? 1);
    target.buffs.rangeMul *= (player.gear.rangeMul ?? 1);
    target.buffs.spdMul    *= (player.gear.spdMul ?? 1);
    target.buffs.atkSpdMul *= (player.gear.atkSpdMul ?? 1);
    target.buffs.armorAdd += (player.gear.armorAdd ?? 0);
    target.buffs.maxHpAdd += (player.gear.maxHpAdd ?? 0);
    target.buffs.hpRegen  += (player.gear.hpRegen ?? 0);
  }

  for(let i = target.activeBuffs.length - 1; i >= 0; i--){
    const b = target.activeBuffs[i];
    b.duration--;
    if(b.duration <= 0){
      target.activeBuffs.splice(i,1);
      continue;
    }
    const stat = mapBuffTypeToStat(b.type);
    if(!stat) continue;

    if(b.mode === "mul"){
      if(target.buffs[stat] !== undefined) target.buffs[stat] *= b.value;
    }else if(b.mode === "add"){
      if(target.buffs[stat] !== undefined) target.buffs[stat] += b.value;
    }
  }

  if(target === player){
    const b = target.buffs;
    const newMax = Math.max(1, Math.floor(target.baseMaxHp * (b.maxHpMul ?? 1) + (b.maxHpAdd ?? 0)));
    target.maxHp = newMax;
    if(target.hp > target.maxHp) target.hp = target.maxHp;
    target.armor = Math.max(0, (target.baseArmor + (b.armorAdd ?? 0)) * (b.armorMul ?? 1));
  }
}

/* ===== ì—¬ê¸° ì•„ë˜ëŠ” ë„ˆê°€ ì˜¬ë ¤ì¤€ ì›ë³¸ ë¡œì§ ê·¸ëŒ€ë¡œ(ë§µ/ëª¹/ì „íˆ¬/ë Œë”) ===== */
/* NOTE: ë¸”ë™ìŠ¤í¬ë¦° ì›ì¸(êµ¬ ì¸ë²¤ ë§ˆí¬ì—… + CSS ê¹¨ì§ + prettyItemText ì¤„ë°”ê¿ˆ ë²„ê·¸)ì„ ì œê±°/ìˆ˜ì •í–ˆìŒ.
   ì•„ë˜ ë¡œì§ì€ ë„ˆë¬´ ê¸¸ì–´ì„œ ìƒëµí•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ì´ì–´ì ¸ì•¼ í•¨. */

/* ---------------------------------------------------------------------- */
/* ë„ˆê°€ ì˜¬ë¦° ì½”ë“œì—ì„œ ì—¬ê¸° ì´í›„(ë§µ ìƒì„±/ëª¬ìŠ¤í„°/ë Œë”/íŒ¨ë„ ë¡œì§/loop/resetGame)
   ëŠ” ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ë˜, ì•„ë˜ ë‘ ê°€ì§€ë§Œ ê¼­ ì ìš©ë¼ ìˆì–´ì•¼ í•´:

   âœ… 1) 'prettyItemText' ë§ˆì§€ë§‰ return:
      return lines.join("\\n");

   âœ… 2) êµ¬ë²„ì „ ì¸ë²¤ HTML ë¸”ë¡( invHeaderSub ~ invHint )ì€ ì•„ì˜ˆ ì—†ìŒ.

   ì´ íŒŒì¼ì€ ë¸”ë™ìŠ¤í¬ë¦° ì›ì¸ ì œê±°ìš© â€œì •ë¦¬ë³¸ í…œí”Œë¦¿â€ì´ì•¼.
   ë„ˆê°€ ì›ë³¸ ì½”ë“œì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì—¬ê¸° ì•„ë˜ì— ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰ë¨.
*/
/* ---------------------------------------------------------------------- */
</script>
</body>
</html>
