<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Oni Samurai Fixed UI</title>
<style>
body { margin:0; overflow:hidden; background:#1a1a1a; }
canvas { display:block; touch-action:none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const TILE = 64;
const MAP_SIZE = 20;
const ZOOM = 2.5;

let attacking = false;
let pointer = {x:canvas.width/2, y:canvas.height/2};

canvas.addEventListener("mousemove", e=>{
  pointer.x = e.clientX;
  pointer.y = e.clientY;
});
canvas.addEventListener("mousedown", ()=> attacking = true);

class Joystick {
  constructor(){
    this.baseX = canvas.width * 0.3;   // ğŸ”¥ ê°€ìš´ë°ìª½ìœ¼ë¡œ ì´ë™
    this.baseY = canvas.height * 0.75; // ğŸ”¥ ë„ˆë¬´ êµ¬ì„ ì•„ë‹˜
    this.radius = 60;
    this.active = false;
    this.dx = 0;
    this.dy = 0;
  }

  update(e){
    let touch = e.touches[0];
    let x = touch.clientX;
    let y = touch.clientY;

    let dist = Math.hypot(x-this.baseX,y-this.baseY);
    if(dist < this.radius*2){
      this.active = true;
      this.dx = (x-this.baseX)/this.radius;
      this.dy = (y-this.baseY)/this.radius;
    }
  }

  reset(){
    this.active=false;
    this.dx=0;
    this.dy=0;
  }

  draw(){
    ctx.globalAlpha=0.4;
    ctx.beginPath();
    ctx.arc(this.baseX,this.baseY,this.radius,0,Math.PI*2);
    ctx.fillStyle="#555";
    ctx.fill();

    ctx.beginPath();
    ctx.arc(this.baseX+this.dx*this.radius,
            this.baseY+this.dy*this.radius,
            25,0,Math.PI*2);
    ctx.fillStyle="#aaa";
    ctx.fill();
    ctx.globalAlpha=1;
  }
}

const joystick = new Joystick();

canvas.addEventListener("touchmove", e=>{
  joystick.update(e);
});
canvas.addEventListener("touchend", ()=>{
  joystick.reset();
  attacking=false;
});

class Player{
  constructor(){
    this.x=0;
    this.y=0;
    this.speed=0.04; // ğŸš¶ ë” ì²œì²œíˆ
    this.dir=0;
    this.hp=100;
    this.walkFrame=0;
  }

  update(){
    if(joystick.active){
      this.x+=joystick.dx*this.speed;
      this.y+=joystick.dy*this.speed;
      this.walkFrame+=0.2;
    }

    let px=pointer.x-canvas.width/2;
    let py=pointer.y-canvas.height/2;
    this.dir=Math.atan2(py,px);
  }

  draw(camX,camY){
    const isoX=(this.x-this.y)*TILE/2;
    const isoY=(this.x+this.y)*TILE/4;
    const sx=canvas.width/2+(isoX-camX)*ZOOM;
    const sy=canvas.height/2+(isoY-camY)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.7,ZOOM*1.7);

    // ê°‘ì£¼ ëª¸í†µ
    ctx.fillStyle="#6b0000";
    ctx.fillRect(-6,-12,12,14);

    // íˆ¬êµ¬
    ctx.fillStyle="#400000";
    ctx.fillRect(-5,-18,10,7);

    // ë¿”
    ctx.fillStyle="#ddd";
    ctx.beginPath();
    ctx.moveTo(-4,-18); ctx.lineTo(-8,-25); ctx.lineTo(-2,-20); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(4,-18); ctx.lineTo(8,-25); ctx.lineTo(2,-20); ctx.fill();

    // ëˆˆ (ë°œê´‘)
    ctx.shadowColor="yellow";
    ctx.shadowBlur=10;
    ctx.fillStyle="yellow";
    ctx.fillRect(-3,-15,2,2);
    ctx.fillRect(1,-15,2,2);
    ctx.shadowBlur=0;

    // ê±·ê¸° ë‹¤ë¦¬ ì• ë‹ˆë©”ì´ì…˜
    let legSwing=Math.sin(this.walkFrame)*3;
    ctx.fillStyle="#111";
    ctx.fillRect(-3,2,3,8+legSwing);
    ctx.fillRect(1,2,3,8-legSwing);

    ctx.restore();

    // HPë°”
    ctx.fillStyle="red";
    ctx.fillRect(20,20,this.hp*2,15);
  }
}

class Goblin{
  constructor(x,y){
    this.x=x;
    this.y=y;
  }
  update(player){
    let dx=player.x-this.x;
    let dy=player.y-this.y;
    let dist=Math.hypot(dx,dy);
    if(dist<5){
      this.x+=dx/dist*0.015;
      this.y+=dy/dist*0.015;
    }
  }
  draw(camX,camY){
    const isoX=(this.x-this.y)*TILE/2;
    const isoY=(this.x+this.y)*TILE/4;
    const sx=canvas.width/2+(isoX-camX)*ZOOM;
    const sy=canvas.height/2+(isoY-camY)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.4,ZOOM*1.4);

    ctx.fillStyle="#1e8449";
    ctx.fillRect(-5,-10,10,12);

    ctx.fillStyle="#0b3d1f";
    ctx.fillRect(-4,-14,8,4);

    ctx.restore();
  }
}

const player=new Player();
const goblins=[new Goblin(3,2),new Goblin(-2,1)];

let camX=0, camY=0;

function drawMap(){
  for(let x=-MAP_SIZE;x<MAP_SIZE;x++){
    for(let y=-MAP_SIZE;y<MAP_SIZE;y++){
      const isoX=(x-y)*TILE/2;
      const isoY=(x+y)*TILE/4;
      const sx=canvas.width/2+(isoX-camX)*ZOOM;
      const sy=canvas.height/2+(isoY-camY)*ZOOM;

      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.lineTo(sx,sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.closePath();

      ctx.fillStyle=(x+y)%2==0?"#3a3a3a":"#444";
      ctx.fill();
    }
  }
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update();
  goblins.forEach(g=>g.update(player));

  camX+=( (player.x-player.y)*TILE/2 - camX)*0.1;
  camY+=( (player.x+player.y)*TILE/4 - camY)*0.1;

  drawMap();
  goblins.forEach(g=>g.draw(camX,camY));
  player.draw(camX,camY);
  joystick.draw();

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
