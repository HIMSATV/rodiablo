<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Ronin - Combat Evolution</title>
<style>
body{margin:0;background:black;overflow:hidden;}
canvas{display:block;}

#uiBar{
 position:fixed;
 bottom:0;
 width:100%;
 height:140px;
 background:linear-gradient(#1a0000,#000);
 border-top:3px solid #550000;
}

#hpBar{
 position:fixed;
 top:15px;
 left:50%;
 transform:translateX(-50%);
 width:200px;
 height:20px;
 background:#330000;
 border:2px solid #aa0000;
}
#hpFill{
 height:100%;
 width:100%;
 background:red;
}

#joystickBase{
 position:absolute;
 left:40px;
 bottom:20px;
 width:120px;height:120px;
 border-radius:50%;
 background:rgba(255,255,255,0.08);
}
#joystick{
 position:absolute;
 width:60px;height:60px;
 border-radius:50%;
 background:rgba(255,255,255,0.25);
 left:30px;top:30px;
}

#attackBtn{
 position:absolute;
 right:40px;
 bottom:35px;
 width:90px;height:90px;
 border-radius:50%;
 background:radial-gradient(circle,#aa0000,#440000);
 border:3px solid #ff4444;
 display:flex;align-items:center;justify-content:center;
 color:white;font-size:22px;
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="hpBar"><div id="hpFill"></div></div>

<div id="uiBar">
 <div id="joystickBase"><div id="joystick"></div></div>
 <div id="attackBtn">⚔</div>
</div>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight-140;

/* ===== 플레이어 ===== */
let player={
 x:canvas.width/2,
 y:canvas.height/2,
 dir:0,
 speed:2,
 radius:14,
 hp:100,
 maxHp:100,
 invincible:0
};

let enemies=[];
let particles=[];
let attacking=false;
let attackCooldown=0;
let screenShake=0;

/* ===== 적 생성 ===== */
function spawnEnemy(){
 enemies.push({
  x:Math.random()*canvas.width,
  y:Math.random()*canvas.height,
  hp:40,
  radius:14,
  attackCooldown:0
 });
}
for(let i=0;i<6;i++) spawnEnemy();

/* ===== 자동 타겟 ===== */
function findClosest(){
 let min=9999,target=null;
 enemies.forEach(e=>{
  let d=Math.hypot(e.x-player.x,e.y-player.y);
  if(d<min){min=d;target=e;}
 });
 return target;
}

/* ===== 공격 ===== */
document.getElementById("attackBtn").addEventListener("touchstart",attack);
document.getElementById("attackBtn").addEventListener("mousedown",attack);

function attack(){
 if(attackCooldown>0) return;
 let target=findClosest();
 if(!target) return;

 let dx=target.x-player.x;
 let dy=target.y-player.y;
 let dist=Math.hypot(dx,dy);
 if(dist>100) return;

 player.dir=Math.atan2(dy,dx);
 attacking=true;
 attackCooldown=25;

 enemies.forEach(e=>{
  let dx=e.x-player.x;
  let dy=e.y-player.y;
  let dist=Math.hypot(dx,dy);
  let angle=Math.atan2(dy,dx);
  let diff=Math.abs(angle-player.dir);

  if(dist<80 && diff<0.8){
   e.hp-=20;
   spawnBlood(e.x,e.y);
   if(e.hp<=0){
     explode(e.x,e.y);
     screenShake=10;
   }
  }
 });

 setTimeout(()=>attacking=false,200);
}

/* ===== 폭발 ===== */
function explode(x,y){
 for(let i=0;i<20;i++){
  particles.push({
   x,y,
   vx:(Math.random()-0.5)*6,
   vy:(Math.random()-0.5)*6,
   life:40,
   color:"orange"
  });
 }
}

/* ===== 피 ===== */
function spawnBlood(x,y){
 for(let i=0;i<8;i++){
  particles.push({
   x,y,
   vx:(Math.random()-0.5)*4,
   vy:(Math.random()-0.5)*4,
   life:25,
   color:"red"
  });
 }
}

/* ===== 조이스틱 ===== */
let joyActive=false,joyDX=0,joyDY=0;
const base=document.getElementById("joystickBase");
const stick=document.getElementById("joystick");

base.addEventListener("touchstart",()=>joyActive=true);
base.addEventListener("touchmove",e=>{
 if(!joyActive)return;
 let r=base.getBoundingClientRect();
 let x=e.touches[0].clientX-r.left;
 let y=e.touches[0].clientY-r.top;
 joyDX=x-60; joyDY=y-60;
 let d=Math.hypot(joyDX,joyDY);
 if(d>50){joyDX=joyDX/d*50;joyDY=joyDY/d*50;}
 stick.style.left=(joyDX+30)+"px";
 stick.style.top=(joyDY+30)+"px";
});
base.addEventListener("touchend",()=>{
 joyActive=false;joyDX=joyDY=0;
 stick.style.left="30px";stick.style.top="30px";
});

/* ===== 충돌 ===== */
function resolveCollision(a,b){
 let dx=a.x-b.x;
 let dy=a.y-b.y;
 let dist=Math.hypot(dx,dy);
 let min=a.radius+b.radius;
 if(dist<min && dist>0){
  let push=(min-dist)/2;
  a.x+=dx/dist*push;
  a.y+=dy/dist*push;
  b.x-=dx/dist*push;
  b.y-=dy/dist*push;
 }
}

/* ===== 업데이트 ===== */
function update(){

 if(joyActive){
  player.x+=joyDX/50*player.speed;
  player.y+=joyDY/50*player.speed;
  if(Math.hypot(joyDX,joyDY)>5)
   player.dir=Math.atan2(joyDY,joyDX);
 }

 enemies.forEach(e=>{
  let dx=player.x-e.x;
  let dy=player.y-e.y;
  let dist=Math.hypot(dx,dy);

  if(dist>0){
   e.x+=dx/dist*0.5;
   e.y+=dy/dist*0.5;
  }

  resolveCollision(player,e);

  if(dist<25 && e.attackCooldown<=0){
   if(player.invincible<=0){
    player.hp-=10;
    player.invincible=30;
    screenShake=8;
   }
   e.attackCooldown=60;
  }

  if(e.attackCooldown>0) e.attackCooldown--;
 });

 enemies=enemies.filter(e=>e.hp>0);
 if(enemies.length<6) spawnEnemy();

 particles.forEach(p=>{
  p.x+=p.vx;p.y+=p.vy;p.life--;
 });
 particles=particles.filter(p=>p.life>0);

 if(attackCooldown>0) attackCooldown--;
 if(player.invincible>0) player.invincible--;

 if(screenShake>0) screenShake--;
 document.getElementById("hpFill").style.width=
   (player.hp/player.maxHp*100)+"%";
}

/* ===== 그리기 ===== */
function draw(){
 ctx.save();

 if(screenShake>0){
  ctx.translate(
    (Math.random()-0.5)*screenShake,
    (Math.random()-0.5)*screenShake
  );
 }

 ctx.fillStyle="#111";
 ctx.fillRect(0,0,canvas.width,canvas.height);

 enemies.forEach(e=>{
  ctx.fillStyle="#006600";
  ctx.fillRect(e.x-10,e.y-10,20,20);
 });

 ctx.fillStyle="#770000";
 ctx.fillRect(player.x-10,player.y-10,20,20);

 if(attacking){
  ctx.strokeStyle="white";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.arc(player.x,player.y,60,player.dir-0.7,player.dir+0.7);
  ctx.stroke();
 }

 particles.forEach(p=>{
  ctx.fillStyle=p.color;
  ctx.fillRect(p.x,p.y,3,3);
 });

 ctx.restore();
}

function loop(){
 update();
 draw();
 requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
