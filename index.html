<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport"
 content="width=device-width,
 initial-scale=1.0,
 maximum-scale=1.0,
 user-scalable=no,
 viewport-fit=cover">

<title>Pixel Axe - Center Camera</title>

<style>
html,body{
 margin:0;
 padding:0;
 overflow:hidden;
 touch-action:none;
 background:#000;
}
*{
 -webkit-user-select:none;
 user-select:none;
 -webkit-touch-callout:none;
}
canvas{
 display:block;
 image-rendering: pixelated;
}

/* HP 바 */
#hpBar{
 position:fixed;
 top:10px;
 left:50%;
 transform:translateX(-50%);
 width:200px;height:16px;
 background:#400;
 border:2px solid #a00;
}
#hpFill{
 height:100%;
 width:100%;
 background:#f00;
}

/* 하단 UI */
#uiBar{
 position:fixed;
 bottom:0;
 width:100%;
 height:140px;
 background:#200;
 border-top:3px solid #500;
}

#joystickBase{
 position:absolute;
 left:40px;
 bottom:20px;
 width:120px;height:120px;
 border-radius:50%;
 background:rgba(255,255,255,0.08);
}
#joystick{
 position:absolute;
 width:60px;height:60px;
 border-radius:50%;
 background:rgba(255,255,255,0.25);
 left:30px;top:30px;
}

#attackBtn{
 position:absolute;
 right:40px;
 bottom:35px;
 width:90px;height:90px;
 border-radius:50%;
 background:#900;
 border:3px solid #f44;
 display:flex;
 align-items:center;
 justify-content:center;
 color:white;
 font-size:22px;
}
</style>
</head>
<body>

<canvas id="game"></canvas>
<div id="hpBar"><div id="hpFill"></div></div>

<div id="uiBar">
 <div id="joystickBase"><div id="joystick"></div></div>
 <div id="attackBtn">⚔</div>
</div>

<script>

/* ===== iOS 확대 완전 차단 ===== */
document.addEventListener('gesturestart', e=>e.preventDefault());
document.addEventListener('gesturechange', e=>e.preventDefault());
document.addEventListener('gestureend', e=>e.preventDefault());
let lastTouchEnd = 0;
document.addEventListener('touchend', function (event) {
 let now = Date.now();
 if (now - lastTouchEnd <= 300) event.preventDefault();
 lastTouchEnd = now;
}, {passive:false});

/* ===== 기본 해상도 ===== */
const scale=4;
const baseW=240;
const baseH=320;

const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

canvas.width=baseW;
canvas.height=baseH;
canvas.style.width=baseW*scale+"px";
canvas.style.height=baseH*scale+"px";
ctx.imageSmoothingEnabled=false;

/* ===== 월드 좌표 ===== */
let worldOffsetX=0;
let worldOffsetY=0;

/* ===== 플레이어 (항상 중앙) ===== */
const centerX=baseW/2;
const centerY=baseH/2;

let player={
 x:0,y:0,
 dir:0,
 speed:1.5,
 hp:100,maxHp:100
};

let enemies=[];
let attacking=false;
let attackCooldown=0;

/* 적 생성 (월드 기준) */
function spawnEnemy(){
 enemies.push({
  x:(Math.random()*600)-300,
  y:(Math.random()*600)-300,
  hp:40
 });
}
for(let i=0;i<6;i++) spawnEnemy();

/* 자동 타겟 */
function findClosest(){
 let min=9999,target=null;
 enemies.forEach(e=>{
  let d=Math.hypot(e.x-player.x,e.y-player.y);
  if(d<min){min=d;target=e;}
 });
 return target;
}

/* 공격 */
const attackBtn=document.getElementById("attackBtn");
attackBtn.addEventListener("touchstart",function(e){
 e.preventDefault();
 attack();
},{passive:false});
attackBtn.addEventListener("mousedown",attack);

function attack(){
 if(attackCooldown>0)return;
 let target=findClosest();
 if(!target)return;

 player.dir=Math.atan2(target.y-player.y,target.x-player.x);
 attacking=true;
 attackCooldown=20;

 enemies.forEach(e=>{
  let d=Math.hypot(e.x-player.x,e.y-player.y);
  if(d<45) e.hp-=20;
 });

 setTimeout(()=>attacking=false,150);
}

/* ===== 조이스틱 ===== */
let joyActive=false,joyDX=0,joyDY=0;
const base=document.getElementById("joystickBase");

base.addEventListener("touchstart",e=>{
 e.preventDefault();
 joyActive=true;
},{passive:false});

base.addEventListener("touchmove",e=>{
 e.preventDefault();
 if(!joyActive)return;
 let r=base.getBoundingClientRect();
 let x=e.touches[0].clientX-r.left;
 let y=e.touches[0].clientY-r.top;
 joyDX=(x-60)/50;
 joyDY=(y-60)/50;
},{passive:false});

base.addEventListener("touchend",()=>{
 joyActive=false;
 joyDX=joyDY=0;
});

/* ===== 업데이트 ===== */
function update(){

 if(joyActive){
  player.x+=joyDX*player.speed;
  player.y+=joyDY*player.speed;
 }

 /* 몬스터 추적 */
 enemies.forEach(e=>{
  let dx=player.x-e.x;
  let dy=player.y-e.y;
  let d=Math.hypot(dx,dy);
  if(d>0){
   e.x+=dx/d*0.6;
   e.y+=dy/d*0.6;
  }
 });

 enemies=enemies.filter(e=>e.hp>0);
 if(enemies.length<6) spawnEnemy();

 if(attackCooldown>0)attackCooldown--;

 document.getElementById("hpFill").style.width=
  (player.hp/player.maxHp*100)+"%";
}

/* ===== 체크무늬 바닥 ===== */
function drawFloor(){

 const tile=16;

 for(let x=-baseW; x<baseW*2; x+=tile){
  for(let y=-baseH; y<baseH*2; y+=tile){

   let wx = x + (player.x % tile);
   let wy = y + (player.y % tile);

   let check = ((Math.floor((x+player.x)/tile)
               +Math.floor((y+player.y)/tile)) %2);

   ctx.fillStyle = check? "#1a1a1a":"#111";
   ctx.fillRect(wx,wy,tile,tile);
  }
 }
}

/* ===== 플레이어 도트 ===== */
function drawPlayer(){
 ctx.fillStyle="#8b0000";
 ctx.fillRect(centerX-4,centerY-6,8,8);

 ctx.fillStyle="#500";
 ctx.fillRect(centerX-4,centerY+2,3,4);
 ctx.fillRect(centerX+1,centerY+2,3,4);

 ctx.fillStyle="#a00";
 ctx.fillRect(centerX-3,centerY-10,6,4);

 ctx.fillStyle="#fff";
 ctx.fillRect(centerX-3,centerY-12,2,2);
 ctx.fillRect(centerX+1,centerY-12,2,2);

 ctx.fillStyle="yellow";
 ctx.fillRect(centerX-2,centerY-9,1,1);
 ctx.fillRect(centerX+1,centerY-9,1,1);

 ctx.save();
 ctx.translate(centerX,centerY);
 ctx.rotate(player.dir);
 if(attacking) ctx.rotate(Math.sin(Date.now()/30)*0.5);

 ctx.fillStyle="#5a3a1a";
 ctx.fillRect(0,-1,16,2);

 ctx.fillStyle="#ccc";
 ctx.fillRect(14,-4,6,8);
 ctx.restore();
}

/* ===== 몬스터 도트 ===== */
function drawEnemy(e){
 let screenX = centerX + (e.x-player.x);
 let screenY = centerY + (e.y-player.y);

 ctx.fillStyle="#0a0";
 ctx.fillRect(screenX-5,screenY-5,10,10);

 ctx.fillStyle="#0f0";
 ctx.fillRect(screenX-3,screenY-3,6,6);

 ctx.fillStyle="red";
 ctx.fillRect(screenX-2,screenY-1,2,2);
 ctx.fillRect(screenX+1,screenY-1,2,2);
}

/* ===== 루프 ===== */
function draw(){
 drawFloor();
 enemies.forEach(drawEnemy);
 drawPlayer();
}

function loop(){
 update();
 draw();
 requestAnimationFrame(loop);
}
loop();

</script>
</body>
</html>
