<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Oni Samurai</title>
<style>
:root{
  --uiScale: 1.2; /* ‚úÖ UI 20% ÌôïÎåÄ */
  /* ‚úÖ Í∏∞Í∏∞Î≥Ñ UI ÏûêÎèô Ïä§ÏºÄÏùº (ÏïÑÏù¥Ìè∞12ÎØ∏Îãà Ìè¨Ìï®) */
--uiH: clamp(calc(84px * var(--uiScale)),  calc(16vh * var(--uiScale)),  calc(120px * var(--uiScale)));
--pad: clamp(calc(66px * var(--uiScale)),  calc(12.5vw * var(--uiScale)), calc(90px  * var(--uiScale)));
--stick:clamp(calc(28px * var(--uiScale)),  calc(5.6vw * var(--uiScale)),  calc(40px  * var(--uiScale)));
--btn: clamp(calc(70px * var(--uiScale)),  calc(13vw * var(--uiScale)),   calc(90px  * var(--uiScale)));
}

body{
  margin:0;
  background:black;
  overflow:hidden;
  touch-action:none;
}
canvas{position:fixed;top:0;left:0;image-rendering:pixelated;}

#ui{
 position:fixed;bottom:0;width:100%;height:var(--uiH);
 background:#111;border-top:3px solid #550000;
 display:flex;align-items:center;justify-content:space-between;
 padding:0 clamp(10px, 4vw, 25px);box-sizing:border-box;
}

#movePad{
  position:relative;
  width:var(--pad);height:var(--pad);
  border-radius:50%;
  background:#222;
}
#stick{
  position:absolute;
  width:var(--stick);height:var(--stick);
  border-radius:50%;
  background:#666;
  left:calc(50% - var(--stick)/2);
  top:calc(50% - var(--stick)/2);
}

#attackBtn{
 position:relative;
 width:var(--btn);height:var(--btn);
 border-radius:50%;
 background:#990000;border:3px solid #ff4444;
 display:flex;align-items:center;justify-content:center;
 font-size:26px;color:white;
}
#attackBtn.active{background:red;transform:scale(.85);}

#attackIcon{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  pointer-events:none;
}
</style>
</head>
<body>
<canvas id="game"></canvas>

<div id="ui">
  <div id="movePad"><div id="stick"></div></div>
  <div id="attackBtn">
    <canvas id="attackIcon" width="60" height="60"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const ui = document.getElementById("ui");

function resize(){
  const uiH = ui.getBoundingClientRect().height || 120;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - uiH;
}
resize();
window.addEventListener("resize", resize);
// iOSÏóêÏÑú Ï£ºÏÜåÏ∞Ω Î≥ÄÌôî/ÌöåÏ†Ñ Ïãú ÎÜíÏù¥ ÌäÄÎäî Í±∞ Î∞©ÏßÄÏö©(Ìïú Î≤à Îçî)
requestAnimationFrame(resize);

/* ===== ÏÇ¨Ïö¥Îìú ===== */
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let audioUnlocked = false;

function unlockAudio(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  audioCtx.resume().then(()=>{
    if(!bgmOsc) bgmOsc = startBGM();
  });
}
window.addEventListener("touchstart", unlockAudio, { once:true });
window.addEventListener("mousedown", unlockAudio, { once:true });
window.addEventListener("keydown", unlockAudio, { once:true });

function startBGM(){
  let isPlaying = true;

  function getTempo(){
    if(killCount >= 100) return 150;
    if(killCount >= 50) return 130;
    return 110;
  }

  function playBeat(){
    if(!isPlaying) return;

    let tempo = getTempo();
    let beatTime = 60 / tempo;
    let now = audioCtx.currentTime;

    // ÌÇ•
    let kick = audioCtx.createOscillator();
    let kickGain = audioCtx.createGain();
    kick.type = "triangle";
    kick.frequency.setValueAtTime(90, now);
    kick.frequency.exponentialRampToValueAtTime(50, now + 0.12);
    kickGain.gain.setValueAtTime(0.18, now);
    kickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    kick.connect(kickGain);
    kickGain.connect(audioCtx.destination);
    kick.start(now);
    kick.stop(now + 0.15);

    // ÌïòÏù¥ÌÜ§
    let tone = audioCtx.createOscillator();
    let toneGain = audioCtx.createGain();
    tone.type = "square";
    tone.frequency.value = 220;
    toneGain.gain.setValueAtTime(0.06, now + beatTime/2);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + beatTime/2 + 0.1);
    tone.connect(toneGain);
    toneGain.connect(audioCtx.destination);
    tone.start(now + beatTime/2);
    tone.stop(now + beatTime/2 + 0.1);

    setTimeout(playBeat, beatTime * 1000);
  }

  playBeat();
  return { stop: () => isPlaying = false };
}

let bgmOsc;

function swingSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="sawtooth";
  o.frequency.setValueAtTime(700,audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(200,audioCtx.currentTime+0.12);
  g.gain.value=0.15;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.12);
}
function bossUnsheatheSound(){
  let now = audioCtx.currentTime;

  let o1 = audioCtx.createOscillator();
  let g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(120, now);
  o1.frequency.exponentialRampToValueAtTime(600, now + 0.6);
  g1.gain.setValueAtTime(0.4, now);
  g1.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
  o1.connect(g1);
  g1.connect(audioCtx.destination);
  o1.start(now);
  o1.stop(now + 0.6);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(900, now);
  o2.frequency.exponentialRampToValueAtTime(200, now + 0.4);
  g2.gain.setValueAtTime(0.3, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.4);
}
function thudSound(){
  let now = audioCtx.currentTime;

  let o = audioCtx.createOscillator();
  let g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.setValueAtTime(120, now);
  o.frequency.exponentialRampToValueAtTime(55, now + 0.14);
  g.gain.setValueAtTime(0.32, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start(now);
  o.stop(now + 0.18);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(220, now);
  o2.frequency.exponentialRampToValueAtTime(90, now + 0.08);
  g2.gain.setValueAtTime(0.12, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.09);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.09);
}
function hitSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="square";
  o.frequency.value=100;
  g.gain.value=0.25;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.08);
}

/* ===== ÌîåÎ†àÏù¥Ïñ¥ ===== */
let player={
  x:0,y:0,
  dir:"left",
  speed:5,
  radius:14,
  hp:100,maxHp:100,
  invul:0,
  knockbackX:0,
  knockbackY:0,
  kiOrbs:0,
  maxOrbs:5,
  levelGlow:0,
  ultiActive:false,
  ultiCount:0,
  ultiTimer:0,
};

let map = [];
let mapSize = 30;
let tileSize = 48;

for(let y=0; y<mapSize; y++){
  let row = [];
  for(let x=0; x<mapSize; x++){
    if(x===0 || y===0 || x===mapSize-1 || y===mapSize-1) row.push(1);
    else row.push(0);
  }
  map.push(row);
}

player.x = mapSize * tileSize / 2;
player.y = mapSize * tileSize / 2;

let hpWaveOffset = 0;
let slowMotion = 0;
let spawnTimer = 0;
let spawnInterval = 90;
let enemies=[];
let packs = [];
let particles=[];
let bloodPools=[];
let shake=0;
let killCount = 0;
let killsForNextLevel = 20;
let killsAtLevelStart = 0;
let level = 1;
let gameOver = false;
let orbFlash = 0;
let flashEffect = 0;
let baseDamage = 20;
let ultiDamage = 40;
let levelParticles = [];
let arrows = [];
let bloodParticles = [];
let fireZones = [];
let frameCount = 0;
let explosionActive = false;
let bossSpawned = false;
let bossTimer = 0;
let bossInterval = 45 * 60;

/* ===== ÏûÖÎ†• ===== */
let joyDX=0, joyDY=0;
let attacking=false;
let attackFrame=0;
let keys = {};

window.addEventListener("keydown", e=>{ keys[e.key] = true; });
window.addEventListener("keyup", e=>{ keys[e.key] = false; });

const pad = document.getElementById("movePad");
const stick = document.getElementById("stick");
const attackBtn = document.getElementById("attackBtn");
let joyActive=false;

function setStickByVector(vx, vy){
  const r = pad.getBoundingClientRect();
  const max = Math.min(r.width, r.height) * 0.33; // ‚úÖ Ìå®Îìú ÌÅ¨Í∏∞ Í∏∞Î∞ò
  let d = Math.hypot(vx, vy) || 1;
  if(d > max){ vx *= max/d; vy *= max/d; }

  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;

  stick.style.left = (r.width/2 - sw/2 + vx) + "px";
  stick.style.top  = (r.height/2 - sh/2 + vy) + "px";

  joyDX = vx / max;
  joyDY = vy / max;

  if(Math.abs(vx) > Math.abs(vy))
    player.dir = vx > 0 ? "right" : "left";
  else
    player.dir = vy > 0 ? "down" : "up";
}

function handlePadMove(clientX, clientY){
  const r = pad.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top + r.height/2;
  const vx = clientX - cx;
  const vy = clientY - cy;
  setStickByVector(vx, vy);
}

pad.addEventListener("touchstart", (e)=>{
  joyActive = true;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchmove", (e)=>{
  if(!joyActive) return;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchend", ()=>{
  joyActive=false; joyDX=joyDY=0;
  const r = pad.getBoundingClientRect();
  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;
  stick.style.left = (r.width/2 - sw/2) + "px";
  stick.style.top  = (r.height/2 - sh/2) + "px";
});

attackBtn.addEventListener("touchstart", ()=>{
  // Í∂ÅÍ∑πÍ∏∞ Î∞úÎèô
  if(player.kiOrbs >= player.maxOrbs && enemies.length > 0 && !player.ultiActive){
    player.kiOrbs = 0;
    orbFlash = 0;
    explosionActive = true;
    player.ultiActive = true;
    player.ultiCount = 0;
    player.ultiTimer = 0;
    return;
  }
  // ÏùºÎ∞ò Í≥µÍ≤©
  attacking = true;
  attackFrame = 0;
  swingSound();
  attackBtn.classList.add("active");
},{passive:true});

attackBtn.addEventListener("touchend", ()=>{
  attackBtn.classList.remove("active");
},{passive:true});

/* ===== Ïú†Ìã∏ ===== */
function dist2(ax, ay, bx, by){
  const dx = ax - bx;
  const dy = ay - by;
  return dx*dx + dy*dy;
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function spawnHitBlood(x, y, amount=10){
  if(bloodParticles.length > 320) return;

  for(let i=0;i<amount;i++){
    bloodParticles.push({
      x: x + (Math.random()-0.5)*6,
      y: y + (Math.random()-0.5)*6,
      vx: (Math.random()-0.5) * 6,
      vy: (Math.random()-0.5) * 6,
      size: Math.random()*3 + 1.5,
      life: 22
    });
  }

  if(bloodPools.length < 140){
    bloodPools.push({
      x: x + (Math.random()-0.5)*8,
      y: y + (Math.random()-0.5)*8,
      size: 5 + Math.random()*4,
      life: 280
    });
  }
}

/* ===== Ï∂©Îèå/Ïù¥Îèô Í∞ÄÎä• ===== */
function canMoveTo(x,y){
  let left = Math.floor((x - player.radius) / tileSize);
  let right = Math.floor((x + player.radius) / tileSize);
  let top = Math.floor((y - player.radius) / tileSize);
  let bottom = Math.floor((y + player.radius) / tileSize);

  return (
    map[top] && map[top][left] === 0 &&
    map[top] && map[top][right] === 0 &&
    map[bottom] && map[bottom][left] === 0 &&
    map[bottom] && map[bottom][right] === 0
  );
}
function canEnemyMoveTo(enemy, x, y){
  let left = Math.floor((x - enemy.radius) / tileSize);
  let right = Math.floor((x + enemy.radius) / tileSize);
  let top = Math.floor((y - enemy.radius) / tileSize);
  let bottom = Math.floor((y + enemy.radius) / tileSize);

  return (
    map[top] && map[top][left] === 0 &&
    map[top] && map[top][right] === 0 &&
    map[bottom] && map[bottom][left] === 0 &&
    map[bottom] && map[bottom][right] === 0
  );
}
function isFloorTile(tx, ty){ return !!(map[ty] && map[ty][tx] === 0); }
function canSpawnEnemyAt(enemy, x, y){ return canEnemyMoveTo(enemy, x, y); }

/* ===== ÌîåÎ†àÏù¥Ïñ¥ ÌîºÍ≤© Ï≤òÎ¶¨ ===== */
function damagePlayer(dmg, knockX, knockY){
  if(player.invul > 0 || gameOver) return;

  player.hp -= dmg;
  player.invul = 25;
  shake = Math.max(shake, 10);

  let nx = player.x + knockX;
  let ny = player.y + knockY;

  if(canMoveTo(nx, player.y)) player.x = nx;
  if(canMoveTo(player.x, ny)) player.y = ny;

  if(player.hp <= 0) handleGameOver();
}

/* ===== Ï†Å Í∑ºÏ†ë Í≥µÍ≤© ===== */
function enemyTryMeleeAttack(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);
  const reach = e.type === "boss" ? 70 : 42;

  if(dist > reach){
    e.attackFrame = 0;
    return;
  }

  if(e.attackFrame === 0){
    e.swingDir = dx < 0 ? -1 : 1;
  }

  e.attackFrame++;

  if(e.attackFrame === 12){
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;
    const kb = e.type === "boss" ? 30 : 18;
    damagePlayer(e.damage, nx*kb, ny*kb);
    hitSound();
  }

  if(e.attackFrame >= 25){
    e.attackFrame = 0;
  }
}

/* ===== ÏïÑÏ≤ò ÌôîÏÇ¥ Î∞úÏÇ¨ ===== */
function spawnArrow(fromX, fromY, toX, toY, damage){
  const dx = toX - fromX;
  const dy = toY - fromY;
  const dist = Math.hypot(dx, dy) || 1;
  const speed = 7.5;

  arrows.push({
    x: fromX,
    y: fromY,
    dx: dx/dist * speed,
    dy: dy/dist * speed,
    damage,
    life: 240
  });
}

/* ===== Î©îÏù¥ÏßÄ Ïû•Ìåê ÏÉùÏÑ± ===== */
function spawnFireZone(x, y, damage){
  fireZones.push({ x, y, radius:55, life:180, tick:0, damage });
}

/* ===== Ïä§Ìè∞ ===== */
function spawnEnemy(){
  if(enemies.length >= 300) return;

  let tileX, tileY;
  while(true){
    tileX = Math.floor(Math.random() * mapSize);
    tileY = Math.floor(Math.random() * mapSize);
    if(
      map[tileY][tileX] === 0 &&
      map[tileY-1]?.[tileX] === 0 &&
      map[tileY+1]?.[tileX] === 0 &&
      map[tileY]?.[tileX-1] === 0 &&
      map[tileY]?.[tileX+1] === 0
    ) break;
  }

  let ex = tileX * tileSize + tileSize/2;
  let ey = tileY * tileSize + tileSize/2;

  let rand = Math.random();
  let type;
  if(rand < 0.2) type = "mage";
  else if(rand < 0.5) type = "archer";
  else type = "melee";

  let scale = Math.min(killCount, 200);

  let enemy = {
    x: ex, y: ey,
    radius: 14,
    stun: 0,
    invul: 0,
    attackFrame: 0,
    swingDir: 1,
    type,

    hp: type==="mage" ? 35 + killCount*0.15 :
        type==="archer" ? 20 + killCount*0.1 :
        40 + killCount*0.2,

    speed: type==="mage" ? 0.4 :
           type==="archer" ? 0.5 : 0.8,

    damage: type==="mage" ? 5 + killCount*0.04 :
            type==="archer" ? 12 + scale*0.04 :
            10 * (1 + killCount*0.0035),

    shootCooldown: 0,
    castCooldown: 120
  };

  let eliteChance = 0.06 + Math.min(0.14, killCount * 0.001);
  if(Math.random() < eliteChance){
    enemy.isElite = true;
    enemy.eliteColor = Math.random() < 0.5 ? "yellow" : "blue";
    enemy.speed *= 1.6;
    enemy.damage *= 2;
    enemy.radius *= 1.2;
    enemy.hp *= 2.5;
  }

  enemies.push(enemy);
}

function spawnEnemyAt(ex, ey, pack){
  let tileX = Math.floor(ex / tileSize);
  let tileY = Math.floor(ey / tileSize);

  if(!isFloorTile(tileX, tileY)) return;
  if(!isFloorTile(tileX-1, tileY) || !isFloorTile(tileX+1, tileY) || !isFloorTile(tileX, tileY-1) || !isFloorTile(tileX, tileY+1)) return;
  if(enemies.length >= 200) return;

  let rand = Math.random();
  let type = rand < 0.2 ? "mage" : rand < 0.5 ? "archer" : "melee";

  let enemy = {
    x: ex, y: ey,
    radius: 14,
    stun: 0,
    invul: 0,
    attackFrame: 0,
    swingDir: 1,
    type,
    hp: 40,
    speed: type==="melee"?0.8:0.5,
    damage: 10,
    shootCooldown: 0,
    castCooldown: 120,
    pack
  };

  if(!canSpawnEnemyAt(enemy, ex, ey)) return;

  enemies.push(enemy);
  pack.enemies.push(enemy);
}

function spawnRandomBoss(){
  if(enemies.some(e => e.type === "boss")) return;

  let bx = player.x + 300;
  let by = player.y;
  const scale = 1 + level * 0.15;
  const tempBoss = { radius: 30 };
  let found = false;

  for(let i=0;i<160;i++){
    let tileX = Math.floor(Math.random() * mapSize);
    let tileY = Math.floor(Math.random() * mapSize);
    if(!map[tileY] || map[tileY][tileX] !== 0) continue;

    let tx = tileX * tileSize + tileSize/2;
    let ty = tileY * tileSize + tileSize/2;

    const dx = tx - player.x;
    const dy = ty - player.y;
    if(dx*dx + dy*dy < 300*300) continue;
    if(!canEnemyMoveTo(tempBoss, tx, ty)) continue;

    bx = tx; by = ty; found = true; break;
  }

  if(!found){
    let angle = Math.random() * Math.PI * 2;
    let dist = 340 + Math.random() * 260;
    let cx = player.x + Math.cos(angle) * dist;
    let cy = player.y + Math.sin(angle) * dist;
    let baseTX = Math.floor(cx / tileSize);
    let baseTY = Math.floor(cy / tileSize);

    outer:
    for(let r=1; r<=6; r++){
      for(let oy=-r; oy<=r; oy++){
        for(let ox=-r; ox<=r; ox++){
          if(Math.abs(ox)!==r && Math.abs(oy)!==r) continue;
          let txi = baseTX + ox;
          let tyi = baseTY + oy;
          if(!map[tyi] || map[tyi][txi] !== 0) continue;

          let tx = txi * tileSize + tileSize/2;
          let ty = tyi * tileSize + tileSize/2;

          const dx = tx - player.x;
          const dy = ty - player.y;
          if(dx*dx + dy*dy < 280*280) continue;
          if(!canEnemyMoveTo(tempBoss, tx, ty)) continue;

          bx = tx; by = ty; found = true; break outer;
        }
      }
    }
  }

  if(!found){
    for(let k=0;k<40;k++){
      let tx = bx + (Math.random()-0.5) * tileSize * 3;
      let ty = by + (Math.random()-0.5) * tileSize * 3;
      if(canEnemyMoveTo(tempBoss, tx, ty)){ bx = tx; by = ty; found = true; break; }
    }
  }

  if(!canEnemyMoveTo(tempBoss, bx, by)) return;

  enemies.push({
    x: bx, y: by,
    radius: 30,
    type: "boss",
    maxHp: 800 * scale,
    hp: 800 * scale,
    speed: 0.6 + level * 0.02,
    damage: 25 * scale,
    stun: 0,
    attackFrame: 0,
    swordPulled: false,
    phase2Used: false,
    dashCooldown: 120,
    cleaveCooldown: 160,
    invul: 0,
    phaseLock: 0
  });
}

function createPack(cx, cy, count){
  let pack = { x: cx, y: cy, enemies: [], activated: false };
  for(let i=0;i<count;i++){
    let angle = Math.random()*Math.PI*2;
    let radius = Math.random()*140;
    let ex = cx + Math.cos(angle)*radius;
    let ey = cy + Math.sin(angle)*radius;
    spawnEnemyAt(ex, ey, pack);
  }
  packs.push(pack);
}

/* ===== Í∂ÅÍ∑πÍ∏∞ ===== */
function teleportTo(target){
  spawnHitBlood(player.x, player.y, 18);
  if(particles.length < 220){
    for(let i=0;i<10;i++){
      particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 22 });
    }
  }

  if(canMoveTo(target.x, target.y)){
    player.x = target.x;
    player.y = target.y;
  }

  spawnHitBlood(player.x, player.y, 22);
  if(particles.length < 220){
    for(let i=0;i<12;i++){
      particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 26 });
    }
  }

  shake = Math.max(shake, 10);
}

function dealUltimateDamage(){
  const radius = 160;
  const r2 = radius * radius;
  let killedAny = false;

  for(let i=0; i<enemies.length; i++){
    const e = enemies[i];
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    if(dx*dx + dy*dy > r2) continue;

    const wasAlive = (e.hp > 0);

    if(e.type === "boss"){
      if(e.invul <= 0){
        e.hp -= ultiDamage * 2.5;
        e.stun = 25;
        spawnHitBlood(e.x, e.y, 14);
        shake = Math.max(shake, 20);
      }
      continue;
    }

    e.hp = 0;
    e.stun = 30;
    spawnHitBlood(e.x, e.y, 18);

    if(particles.length < 240){
      for(let k=0;k<12;k++){
        particles.push({ x: e.x, y: e.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 40 });
      }
    }

    if(wasAlive){
      killCount++;
      checkLevelUp();
      player.hp = Math.min(player.maxHp, player.hp + 1);
      slowMotion = 6;
      if(player.kiOrbs < player.maxOrbs) player.kiOrbs++;
      killedAny = true;
    }
  }

  if(killedAny) hitSound();
  shake = Math.max(shake, 35);
}

/* ===== Î≥¥Ïä§ Ïä§ÌÇ¨ ===== */
function bossEnterPhase2(boss){
  boss.swordPulled = true;
  boss.phase2Used = true;
  boss.speed *= 1.25;
  boss.damage *= 1.2;

  boss.invul = 120;
  boss.phaseLock = 36;

  shake = 30;
  bossUnsheatheSound();

  for(let i=0;i<80;i++){
    particles.push({ x: boss.x, y: boss.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 50 });
  }
}

function bossDash(boss){
  const dx = player.x - boss.x;
  const dy = player.y - boss.y;
  const dist = Math.hypot(dx, dy) || 1;
  const nx = dx / dist;
  const ny = dy / dist;

  const dashDist = 220;
  const steps = 18;
  let hit = false;

  for(let i=0;i<steps;i++){
    let px = boss.x + nx * (dashDist/steps);
    let py = boss.y + ny * (dashDist/steps);

    if(canEnemyMoveTo(boss, px, py)){
      boss.x = px; boss.y = py;
    }else break;

    if(!hit){
      const d = Math.hypot(player.x - boss.x, player.y - boss.y);
      if(d < boss.radius + player.radius + 10){
        damagePlayer(boss.damage*1.2, nx*34, ny*34);
        hit = true;
      }
    }
  }
  shake = Math.max(shake, 16);
}

function bossCleave(boss){
  const radius = 140;

  for(let i=0;i<70;i++){
    const a = Math.random()*Math.PI*2;
    const r = Math.random()*radius;
    particles.push({
      x: boss.x + Math.cos(a)*r,
      y: boss.y + Math.sin(a)*r,
      vx: Math.cos(a)*2 + (Math.random()-0.5)*2,
      vy: Math.sin(a)*2 + (Math.random()-0.5)*2,
      life: 35
    });
  }

  const dist = Math.hypot(player.x - boss.x, player.y - boss.y);
  if(dist < radius){
    const dx = player.x - boss.x;
    const dy = player.y - boss.y;
    const len = Math.hypot(dx, dy) || 1;
    damagePlayer(boss.damage*1.6, (dx/len)*42, (dy/len)*42);
  }
  shake = Math.max(shake, 22);
}
function isEnemyOnScreen(e){
  const camX = player.x - canvas.width/2;
  const camY = player.y - canvas.height/2;

  const screenLeft   = camX - 50;
  const screenRight  = camX + canvas.width + 50;
  const screenTop    = camY - 50;
  const screenBottom = camY + canvas.height + 50;

  return (
    e.x > screenLeft &&
    e.x < screenRight &&
    e.y > screenTop &&
    e.y < screenBottom
  );
}
/* ===== ÏóÖÎç∞Ïù¥Ìä∏ ===== */
function update(){
  frameCount++;
  if(gameOver) return;

  if(slowMotion > 0){
    slowMotion--;
    return;
  }

  updatePlayerState();
  updateUltimateSystem();
  updateEnemySystem();
  updateCombatSystem();
  updateProjectileSystem();
  updateEffectSystem();
  updateEnvironmentSystem();
  updateSpawnSystem();
}

function updatePlayerState(){
  if(player.hp <= 0){ handleGameOver(); return; }
  updateMovement();
  updateInvulnerability();
  updateLevelGlow();
}
function handleGameOver(){
  gameOver = true;
  document.getElementById("ui").style.display = "none";
}
function updateLevelGlow(){
  if(player.levelGlow > 0) player.levelGlow--;
}

function updateUltimateSystem(){
  if(!player.ultiActive) return;

  player.ultiTimer++;
  if(player.ultiTimer % 10 === 0) performUltimateStrike();
  if(player.ultiCount >= 5) endUltimate();
}
function performUltimateStrike(){
  if(enemies.length === 0) return;
  let target = enemies[Math.floor(Math.random()*enemies.length)];
  teleportTo(target);
  dealUltimateDamage();
  player.ultiCount++;
}
function endUltimate(){
  enemies = enemies.filter(e=>e.hp>0);
  player.ultiActive = false;
  player.kiOrbs = 0;
  explosionActive = false;
}

function updateEnemySystem(){

  // üî• ÏãúÏïº Í∏∞Î∞ò Ìå© ÌôúÏÑ±Ìôî
  packs.forEach(pack=>{
    if(pack.activated) return;

    for(let i=0;i<pack.enemies.length;i++){
      if(isEnemyOnScreen(pack.enemies[i])){
        pack.activated = true;
        break;
      }
    }
  });

  enemies.forEach(e=>{
    if(e.pack && !e.pack.activated) return;
    updateSingleEnemy(e);
  });
}

function updateLevelParticles(){
  for(let i = levelParticles.length - 1; i >= 0; i--){
    const p = levelParticles[i];
    p.ox += p.vx;
    p.oy -= p.vy;
    p.vy *= 0.97;
    p.life--;
    if(p.life <= 0) levelParticles.splice(i,1);
  }
  if(levelParticles.length > 200){
    levelParticles.splice(0, levelParticles.length - 200);
  }
}

function updateParticles(){
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }
  if(particles.length > 260){
    particles.splice(0, particles.length - 260);
  }
}

function updateMelee(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  if(dist > 0){
    let moveX = dx / dist * e.speed;
    let moveY = dy / dist * e.speed;

    let newX = e.x + moveX;
    let newY = e.y + moveY;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }

  enemyTryMeleeAttack(e);
}

function updateArcher(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  const desired = 240;
  if(dist < desired - 40){
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;

    const newX = e.x - nx * e.speed * 1.2;
    const newY = e.y - ny * e.speed * 1.2;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }else if(dist > desired + 80){
    updateMelee(e);
  }

  e.shootCooldown--;
  if(e.shootCooldown <= 0 && dist < 520){
    spawnArrow(e.x, e.y, player.x, player.y, e.damage);
    e.shootCooldown = 80 + Math.floor(Math.random()*40);
  }
}

function updateMage(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  if(dist < 180){
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;

    const newX = e.x - nx * e.speed * 1.4;
    const newY = e.y - ny * e.speed * 1.4;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }else{
    updateMelee(e);
  }

  e.castCooldown--;
  if(e.castCooldown <= 0 && dist < 520){
    spawnFireZone(player.x, player.y, e.damage);
    e.castCooldown = 140 + Math.floor(Math.random()*50);
  }
}

function updateBoss(e){
  if(!e.phase2Used && e.hp <= e.maxHp * 0.5) bossEnterPhase2(e);
  updateMelee(e);

  if(e.swordPulled){
    e.dashCooldown--;
    e.cleaveCooldown--;

    const dist = Math.hypot(player.x - e.x, player.y - e.y);

    if(e.dashCooldown <= 0 && dist > 160 && dist < 520){
      bossDash(e);
      e.dashCooldown = 160 + Math.floor(Math.random()*70);
    }
    if(e.cleaveCooldown <= 0 && dist < 220){
      bossCleave(e);
      e.cleaveCooldown = 200 + Math.floor(Math.random()*80);
    }
  }
}

function updateSingleEnemy(e){
  if(e.invul > 0) e.invul--;

  if(e.phaseLock > 0){
    e.phaseLock--;
    return;
  }

  if(e.stun > 0){
    e.stun--;
    return;
  }

  switch(e.type){
    case "archer": updateArcher(e); break;
    case "mage": updateMage(e); break;
    case "boss": updateBoss(e); break;
    default: updateMelee(e);
  }
}

function updateProjectileSystem(){
  updateArrows();
  updateFireZones();
}

function updateFireZones(){
  for(let i = fireZones.length - 1; i >= 0; i--){
    const f = fireZones[i];
    f.life--;
    f.tick++;

    if(f.tick % 10 === 0){
      const dx = player.x - f.x;
      const dy = player.y - f.y;
      if(dx*dx + dy*dy < f.radius*f.radius){
        damagePlayer(Math.max(1, f.damage*0.6), 0, 0);
      }
    }

    if(f.life <= 0) fireZones.splice(i,1);
  }
}

function updateEffectSystem(){
  updateParticles();
  updateBlood();
  updateLevelParticles();

  for(let i=bloodPools.length-1;i>=0;i--){
    bloodPools[i].life--;
    if(bloodPools[i].life <= 0) bloodPools.splice(i,1);
  }
  if(bloodPools.length > 120) bloodPools.splice(0, bloodPools.length-120);
}

function updateCombatSystem(){
  if(attacking){
    attackFrame++;
    if(attackFrame === 3) checkHit();
    if(attackFrame > 8){
      attacking = false;
      attackFrame = 0;
    }
  }
}

function updateMovement(){
  let dx = 0;
  let dy = 0;

  if(keys["ArrowLeft"] || keys["a"]) dx -= player.speed;
  if(keys["ArrowRight"] || keys["d"]) dx += player.speed;
  if(keys["ArrowUp"] || keys["w"]) dy -= player.speed;
  if(keys["ArrowDown"] || keys["s"]) dy += player.speed;

  dx += joyDX * player.speed;
  dy += joyDY * player.speed;

  if(Math.abs(dx) > Math.abs(dy)){
    if(dx > 0) player.dir = "right";
    else if(dx < 0) player.dir = "left";
  }else{
    if(dy > 0) player.dir = "down";
    else if(dy < 0) player.dir = "up";
  }

  let newX = player.x + dx;
  let newY = player.y + dy;

  if(canMoveTo(newX, player.y)) player.x = newX;
  if(canMoveTo(player.x, newY)) player.y = newY;
}

function updateInvulnerability(){
  if(player.invul > 0) player.invul--;
}

function updateEnvironmentSystem(){ updateShake(); }
function updateShake(){ if(shake > 0) shake--; }

function updateSpawnSystem(){
  spawnTimer++;
  if(spawnTimer >= spawnInterval){
    spawnTimer = 0;

    let angle = Math.random() * Math.PI * 2;
    let distance = 700;

    let px = player.x + Math.cos(angle) * distance;
    let py = player.y + Math.sin(angle) * distance;

    let margin = 200;

    if(px > margin && py > margin && px < mapSize * tileSize - margin && py < mapSize * tileSize - margin){
      createPack(px, py, 18 + Math.floor(Math.random()*10));
    }

    if(spawnInterval > 40) spawnInterval -= 1;
  }

  bossTimer++;
  bossInterval = Math.max(25*60, 45*60 - level*3*60);

  if(bossTimer >= bossInterval){
    bossTimer = 0;
    if(!enemies.some(e => e.type === "boss")) spawnRandomBoss();
  }
}

function updateArrows(){
  for(let i = arrows.length - 1; i >= 0; i--){
    const a = arrows[i];
    a.x += a.dx;
    a.y += a.dy;
    a.life--;

    const tx = Math.floor(a.x / tileSize);
    const ty = Math.floor(a.y / tileSize);
    if(!map[ty] || map[ty][tx] === 1){
      arrows.splice(i,1);
      continue;
    }

    const px = player.x, py = player.y;
    const dxp = a.x - px;
    const dyp = a.y - py;
    const rr = (player.radius + 4);
    if(dxp*dxp + dyp*dyp < rr*rr){
      const dx = px - a.x;
      const dy = py - a.y;
      const len = Math.hypot(dx, dy) || 1;
      damagePlayer(a.damage, (dx/len)*14, (dy/len)*14);
      arrows.splice(i,1);
      continue;
    }

    if(a.life <= 0){
      arrows.splice(i,1);
      continue;
    }
  }
}

/* ===== Î†àÎ≤®ÏóÖ ===== */
function levelUpSound(){
  let o = audioCtx.createOscillator();
  let g = audioCtx.createGain();

  o.type = "triangle";
  o.frequency.setValueAtTime(400, audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.3);

  g.gain.setValueAtTime(0.3, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

  o.connect(g);
  g.connect(audioCtx.destination);

  o.start();
  o.stop(audioCtx.currentTime + 0.3);
}

function checkLevelUp(){
  if(killCount - killsAtLevelStart >= killsForNextLevel){
    level++;
    killsAtLevelStart = killCount;
    killsForNextLevel += 5;

    player.maxHp += 10;
    player.hp = player.maxHp;

    baseDamage *= 1 + level * 0.01;
    ultiDamage *= 1 + level * 0.015;
    player.levelGlow = 60;

    for(let i=0;i<60;i++){
      levelParticles.push({
        ox: (Math.random()-0.5)*40,
        oy: -40 + (Math.random()-0.5)*10,
        vx: (Math.random()-0.5)*2,
        vy: Math.random()*3 + 2,
        life: 60
      });
    }

    levelUpSound();
  }
}

/* ===== Í≥µÍ≤© ===== */
function checkHit(){
  const range = 45;
  const hitLimit = 12;
  let hitDone = 0;

  for(let i=0;i<enemies.length;i++){
    const e = enemies[i];

    const dx = e.x - player.x;
    const dy = e.y - player.y;

    const r = range + e.radius;
    if(dx*dx + dy*dy > r*r) continue;

    if(player.dir === "up" && dy >= 0) continue;
    if(player.dir === "down" && dy <= 0) continue;
    if(player.dir === "right" && dx <= 0) continue;
    if(player.dir === "left" && dx >= 0) continue;

    hitDone++;
    if(hitDone > hitLimit) break;

    const len = Math.hypot(dx, dy) || 1;
    const nx = dx / len;
    const ny = dy / len;

    let dealt = baseDamage;
    const bossInvul = (e.type === "boss" && e.invul > 0);

    if(e.invul <= 0){
      e.hp -= dealt;
    }

    const heal = dealt * 0.05;
    player.hp = Math.min(player.maxHp, player.hp + heal);

    if(Math.random() < 0.2 && player.kiOrbs < player.maxOrbs){
      player.kiOrbs++;
    }

    if(bossInvul){
      spawnHitBlood(e.x, e.y, 14);
    }else{
      e.stun = 15;
      let ex = e.x + nx*18;
      let ey = e.y + ny*18;
      if(canEnemyMoveTo(e, ex, e.y)) e.x = ex;
      if(canEnemyMoveTo(e, e.x, ey)) e.y = ey;
    }

    if(bossInvul) thudSound();
    else hitSound();

    shake = 12;

    if(particles.length < 220){
      particles.push({
        x: e.x, y: e.y,
        vx: nx*4 + (Math.random()-0.5)*4,
        vy: ny*4 + (Math.random()-0.5)*4,
        life: 30
      });
    }

    if(e.hp <= 0){
      killCount++;
      checkLevelUp();

      player.hp = Math.min(player.maxHp, player.hp + 1);

      if(bloodPools.length < 140){
        bloodPools.push({
          x: e.x, y: e.y,
          size: 10 + Math.random()*6,
          life: 600
        });
      }

      slowMotion = 6;

      if(player.kiOrbs < player.maxOrbs){
        player.kiOrbs++;
      }
    }
  }

  enemies = enemies.filter(e => e.hp > 0);
  packs.forEach(pack=>{
    pack.enemies = pack.enemies.filter(e=>e.hp>0);
  });
}

function updateBlood(){
  for(let i = bloodParticles.length - 1; i >= 0; i--){
    const p = bloodParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.25;
    p.life--;
    if(p.life <= 0) bloodParticles.splice(i,1);
  }
  if(bloodParticles.length > 260){
    bloodParticles.splice(0, bloodParticles.length - 260);
  }
}

function drawBlood(){
  if(bloodParticles.length === 0) return;

  ctx.save();
  ctx.fillStyle = "#8b0000";
  ctx.beginPath();

  for(let i=0;i<bloodParticles.length;i++){
    const p = bloodParticles[i];
    const a = p.life / 30;
    if(a > 0.66) ctx.globalAlpha = 0.9;
    else if(a > 0.33) ctx.globalAlpha = 0.6;
    else ctx.globalAlpha = 0.35;

    ctx.fillRect(p.x - p.size*0.5, p.y - p.size*0.5, p.size, p.size);
  }
  ctx.restore();
}

/* ===== Î†åÎçî ===== */
function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";
  ctx.filter = "none";

  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  let camX = player.x - canvas.width/2;
  let camY = player.y - canvas.height/2;
  let sx = shake ? (Math.random()-0.5)*12 : 0;
  let sy = shake ? (Math.random()-0.5)*12 : 0;

  ctx.save();
  ctx.translate(-camX+sx, -camY+sy);

  for(let y = 0; y < map.length; y++){
    for(let x = 0; x < map[y].length; x++){
      let tile = map[y][x];
      if(tile === 0) ctx.fillStyle = "#222";
      if(tile === 1) ctx.fillStyle = "#555";
      if(tile === 2) ctx.fillStyle = "blue";
      if(tile === 3) ctx.fillStyle = "red";
      ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
    }
  }

  ctx.fillStyle = "#550000";
  for(let i=0;i<bloodPools.length;i++){
    const b = bloodPools[i];
    const a = b.life / 600;
    if(a <= 0.05) continue;
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  fireZones.forEach(f=>{
    ctx.save();
    for(let i=0;i<6;i++){
      let flameHeight = 10 + Math.sin(frameCount*0.2 + i)*6;
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "orange";
      ctx.beginPath();
      ctx.moveTo(f.x - 6 + i*2, f.y);
      ctx.lineTo(f.x - 3 + i*2, f.y - flameHeight);
      ctx.lineTo(f.x + i*2, f.y);
      ctx.fill();
    }
    ctx.restore();
  });

  ctx.fillStyle = "red";
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    ctx.fillRect(p.x, p.y, 3, 3);
  }

  drawBlood();
  enemies.forEach(e=>drawEnemy(e));

  levelParticles.forEach(p=>{
    ctx.fillStyle = "gold";
    ctx.fillRect(player.x + p.ox, player.y + p.oy, 4, 4);
  });

  arrows.forEach(a=>{
    ctx.fillStyle = "white";
    ctx.fillRect(a.x-2, a.y-2, 4, 4);
  });

  ctx.restore();

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  drawPlayer(canvas.width/2, canvas.height/2);
  drawUI();

  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";
}

/* ===== ÌîåÎ†àÏù¥Ïñ¥ ===== */
function drawPlayer(x,y){
  if(player.levelGlow > 0){
    ctx.shadowColor = "gold";
    ctx.shadowBlur = player.levelGlow * 0.5;
  }

  ctx.fillStyle="#880000";
  ctx.fillRect(x-10,y-12,20,22);

  ctx.fillStyle="#aa0000";
  ctx.fillRect(x-7,y-20,14,8);

  ctx.fillStyle="#ffffcc";
  ctx.fillRect(x-8,y-26,4,8);
  ctx.fillRect(x+4,y-26,4,8);

  ctx.fillStyle = "#fff";
  ctx.fillRect(x-3,y-14,2,2);
  ctx.fillRect(x+1,y-14,2,2);

  ctx.shadowBlur = 0;

  if(player.ultiActive){
    ctx.save();
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 25;
    ctx.fillStyle = "#ffaa00";
    ctx.fillRect(x-3,y-14,2,2);
    ctx.fillRect(x+1,y-14,2,2);
    ctx.restore();
  }

  drawSword(x,y);
}

function drawSword(x, y){
  ctx.save();
  ctx.translate(x, y);

  var offsetX = 0;
  var offsetY = 0;
  var angle = 0;
  var t = attackFrame / 8;

  if (player.dir === "right") { offsetX = 18; if (attacking) angle = 1.5 * t; }
  else if (player.dir === "left") { offsetX = -18; if (attacking) angle = -1.5 * t; }
  else if (player.dir === "up") { offsetY = -18; if (attacking) offsetY -= 25 * t; }
  else if (player.dir === "down") { offsetY = 6; angle = Math.PI; if (attacking) offsetY += 25 * t; }

  ctx.translate(offsetX, offsetY);
  ctx.rotate(angle);
  drawSwordShape(ctx);
  ctx.restore();
}

function drawSwordShape(c){
  c.fillStyle = "#552200";
  c.fillRect(-2, 6, 4, 8);

  c.fillStyle = "#bbbbbb";
  c.fillRect(-8, 6, 16, 3);

  c.fillStyle = "#dddddd";
  c.fillRect(-2, -20, 4, 26);

  c.beginPath();
  c.moveTo(-2, -20);
  c.lineTo(0, -32);
  c.lineTo(2, -20);
  c.fill();
}

/* ===== Î™¨Ïä§ÌÑ∞ ===== */
function drawEnemy(e){
  if(e.type === "boss"){
    if(e.invul > 0){
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius + 10, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    ctx.fillStyle = "#777777";
    ctx.fillRect(e.x-20, e.y-25, 40, 50);

    ctx.fillStyle = "#999999";
    ctx.fillRect(e.x-15, e.y-35, 30, 15);

    ctx.fillStyle = "red";
    ctx.fillRect(e.x-6, e.y-15, 4,4);
    ctx.fillRect(e.x+2, e.y-15, 4,4);

    if(!e.swordPulled){
      ctx.save();
      ctx.translate(e.x+5, e.y-5);
      ctx.rotate(0.7);
      drawSwordShape(ctx);
      ctx.restore();
    }else{
      ctx.save();
      ctx.translate(e.x+28, e.y);
      ctx.rotate(0.2);
      drawSwordShape(ctx);
      ctx.restore();
    }
    return;
  }

  if(e.isElite){
    ctx.fillStyle = (e.eliteColor === "yellow") ? "#ffcc00" : "#00aaff";
  }else if(e.type === "archer"){
    ctx.fillStyle = "#cccccc";
  }else if(e.type === "mage"){
    ctx.fillStyle = "#550088";
  }else{
    ctx.fillStyle = "#006600";
  }

  ctx.fillRect(e.x-10,e.y-12,20,22);

  if(e.type === "archer") ctx.fillStyle = "#dddddd";
  else if(e.type === "mage") ctx.fillStyle = "#550088";
  else ctx.fillStyle = "#00aa00";
  ctx.fillRect(e.x-7,e.y-20,14,8);

  ctx.fillStyle="red";
  ctx.fillRect(e.x-4,e.y-14,3,3);
  ctx.fillRect(e.x+1,e.y-14,3,3);

  if(e.attackFrame > 0){
    let t = (25 - e.attackFrame) / 25;
    let swingRange = 1.4;
    let angle = (t - 0.5) * 2 * swingRange * e.swingDir;

    ctx.save();
    ctx.translate(e.x, e.y-5);
    ctx.rotate(angle);

    if(e.type === "archer") ctx.fillStyle = "#dddddd";
    else ctx.fillStyle = "#006600";

    ctx.fillRect(-20,-3,40,6);
    ctx.restore();
  }
}

/* ===== UI ===== */
function drawUI(){
  drawTextUI();
  drawOrbUI();
  drawHpOrb();
  drawBossHpBar();
  drawMiniMap();
}

function drawMiniMap(){
  const w = 150, h = 150;
  const x0 = canvas.width - w - 20;
  const y0 = canvas.height - h - 20;

  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = "#000";
  ctx.fillRect(x0, y0, w, h);

  const mapW = mapSize * tileSize;
  const mapH = mapSize * tileSize;
  const sx = w / mapW;
  const sy = h / mapH;

  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "#555";
  ctx.lineWidth = 2;
  ctx.strokeRect(x0+1, y0+1, w-2, h-2);

  ctx.fillStyle = "#ff4444";
  ctx.fillRect(x0 + player.x * sx - 2, y0 + player.y * sy - 2, 4, 4);

  let drawCount = 0;
  for(let i=0;i<enemies.length;i++){
    if(drawCount > 200) break;
    const e = enemies[i];
    if(e.type === "boss"){
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(x0 + e.x*sx - 3, y0 + e.y*sy - 3, 6, 6);
    }else if(e.isElite){
      ctx.fillStyle = "#00aaff";
      ctx.fillRect(x0 + e.x*sx - 2, y0 + e.y*sy - 2, 4, 4);
    }else{
      ctx.fillStyle = "#00ff55";
      ctx.fillRect(x0 + e.x*sx - 1, y0 + e.y*sy - 1, 2, 2);
    }
    drawCount++;
  }
  ctx.restore();
}

function drawTextUI(){
  ctx.save();
  ctx.textAlign = "left";
  ctx.font = "bold 18px Arial";
  ctx.fillStyle = "white";
  ctx.strokeStyle = "black";
  ctx.lineWidth = 4;

  ctx.strokeText("Level: " + level, 20, 55);
  ctx.fillText("Level: " + level, 20, 55);

  ctx.strokeText("KILLS: " + killCount, 20, 80);
  ctx.fillText("KILLS: " + killCount, 20, 80);

  ctx.restore();
}

function drawOrbUI(){

  const btnRect = document.getElementById("attackBtn").getBoundingClientRect();

  // Î≤ÑÌäº Ï§ëÏã¨(ÌôîÎ©¥Ï¢åÌëú)
  const centerScreenX = btnRect.left + btnRect.width * 0.5;
  const centerScreenY = btnRect.top  + btnRect.height * 0.5;

  // ÌôîÎ©¥Ï¢åÌëú -> Ï∫îÎ≤ÑÏä§Ï¢åÌëú (Ï∫îÎ≤ÑÏä§Îäî uiHeight ÏúÑÍπåÏßÄÎßå)
  let cx = centerScreenX;
  let cy = centerScreenY - uiHeight;

  // ÏïàÏ†Ñ Î≥¥Ï†ï(Ï∫îÎ≤ÑÏä§ Î∞ñ Î∞©ÏßÄ)
  cx = Math.max(40, Math.min(canvas.width - 40, cx));
  cy = Math.max(40, Math.min(canvas.height - 40, cy));

  const orbR = 10;          // Íµ¨Ïä¨ Î∞òÏßÄÎ¶Ñ(Í∏∞Ï°¥ 10)
  const ringR = 32;         // ‚≠ê Ïò§Í∞ÅÌòï ÌÅ¨Í∏∞(Ïù¥ Í∞í ÌÇ§Ïö∞Î©¥ Îçî ÌçºÏßê)
  const startAngle = -Math.PI/2; // Îß® ÏúÑ Íº≠ÏßÄÏ†êÎ∂ÄÌÑ∞

  ctx.save();

  for(let i=0;i<player.maxOrbs;i++){

    // Ïò§Í∞ÅÌòï Íº≠ÏßÄÏ†ê: 72ÎèÑ(2œÄ/5) Í∞ÑÍ≤©
    const a = startAngle + (i * (Math.PI * 2 / player.maxOrbs));

    const x = cx + Math.cos(a) * ringR;
    const y = cy + Math.sin(a) * ringR;

    ctx.beginPath();
    ctx.arc(x, y, orbR, 0, Math.PI*2);

    if(orbFlash > 0){
      ctx.fillStyle = "#00ff88";
      ctx.shadowColor = "#00ff88";
      ctx.shadowBlur = 35;
    }
    else if(i < player.kiOrbs){
      ctx.fillStyle = "#00ff55";
      ctx.shadowColor = "#00ff55";
      ctx.shadowBlur = 15;
    }
    else{
      ctx.fillStyle = "#002211";
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
    }

    ctx.fill();
  }

  ctx.restore();
}
function drawHpOrb(){

  // ‚úÖ Ï°∞Ïù¥Ïä§Ìã±(movePad) Í∏∞Ï§ÄÏúºÎ°ú ÏúÑÏπò Ïû°Í∏∞
  const padRect = document.getElementById("movePad").getBoundingClientRect();

  // Ï∫îÎ≤ÑÏä§Îäî UI(120px) ÏúÑÍπåÏßÄÎßå Í∑∏Î†§ÏßÄÎãàÍπå,
  // ÌôîÎ©¥Ï¢åÌëú -> Ï∫îÎ≤ÑÏä§Ï¢åÌëúÎ°ú Î≥ÄÌôò (bottom uiHeight ÎßåÌÅº ÎπºÏ§å)
  let x = padRect.left + padRect.width * 0.5;               // Ï°∞Ïù¥Ïä§Ìã± Ï§ëÏïô
  let y = (padRect.top - uiHeight) - 35;                    // Ï°∞Ïù¥Ïä§Ìã± "ÏúÑ"Î°ú 35px

  // ÌôîÎ©¥ Î∞ñÏúºÎ°ú ÎÇòÍ∞ÄÎ©¥ ÏïàÏ†Ñ Î≥¥Ï†ï
  x = Math.max(30, Math.min(canvas.width - 30, x));
  y = Math.max(40, Math.min(canvas.height - 40, y));

  ctx.save();

  let radius = 25;

  hpWaveOffset += 0.07;

  let hpPercent = player.hp / player.maxHp;
  let liquidHeight = radius * 2 * hpPercent;
  let topY = y + radius - liquidHeight;

  // ===== Í≥†Îîï Ïô∏Í≥Ω Î©îÌÉà ÎßÅ =====
  let metal = ctx.createRadialGradient(x, y, radius-10, x, y, radius+12);
  metal.addColorStop(0, "#2a0000");
  metal.addColorStop(0.5, "#550000");
  metal.addColorStop(1, "#110000");

  ctx.beginPath();
  ctx.arc(x, y, radius+10, 0, Math.PI*2);
  ctx.fillStyle = metal;
  ctx.fill();

  // Ïñ¥ÎëêÏö¥ Ïô∏Í≥Ω ÎùºÏù∏
  ctx.lineWidth = 4;
  ctx.strokeStyle = "#000";
  ctx.stroke();

  // Î∂âÏùÄ ÏñáÏùÄ ÎÇ¥Î∂Ä ÎßÅ
  ctx.beginPath();
  ctx.arc(x, y, radius+6, 0, Math.PI*2);
  ctx.strokeStyle = "#aa0000";
  ctx.lineWidth = 2;
  ctx.stroke();

  // ===== ÎÇ¥Î∂Ä ÌÅ¥Î¶¨Ìïë =====
  ctx.save();
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI*2);
  ctx.clip();

  // ÎÇ¥Î∂Ä Ïñ¥Îë† (ÍπäÏù¥Í∞ê)
  let innerShadow = ctx.createRadialGradient(x, y+15, 10, x, y, radius);
  innerShadow.addColorStop(0, "#330000");
  innerShadow.addColorStop(1, "#000000");

  ctx.fillStyle = innerShadow;
  ctx.fillRect(x-radius, y-radius, radius*2, radius*2);

  // ===== Ïï°Ï≤¥ =====
  ctx.beginPath();
  ctx.moveTo(x-radius, y+radius);

  for(let i=0;i<=radius*2;i++){
    let wave = Math.sin(i*0.12 + hpWaveOffset) * 4;
    ctx.lineTo(x-radius+i, topY + wave);
  }

  ctx.lineTo(x+radius, y+radius);
  ctx.closePath();

  let blood = ctx.createLinearGradient(0, topY, 0, y+radius);
  blood.addColorStop(0, "#ff2a2a");
  blood.addColorStop(1, "#8b0000");

  ctx.fillStyle = blood;
  ctx.fill();

  // ===== Ïú†Î¶¨ Î∞òÏÇ¨Í¥ë =====
  ctx.beginPath();
  ctx.arc(x-15, y-20, 18, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.25)";
  ctx.fill();

  // Ïú†Î¶¨ Ï†ÑÏ≤¥ Í¥ëÌÉù
  let glass = ctx.createRadialGradient(x-10, y-15, 5, x, y, radius);
  glass.addColorStop(0, "rgba(255,255,255,0.25)");
  glass.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = glass;
  ctx.fillRect(x-radius, y-radius, radius*2, radius*2);

  // ===== Ï†ÄÏ≤¥Î†• ÍπúÎπ°ÏûÑ =====
  if(hpPercent < 0.3){
    if(Math.floor(Date.now()/200)%2===0){
      ctx.beginPath();
      ctx.arc(x, y, radius+14, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,0,0,0.25)";
      ctx.fill();
    }
  }

  // ===== Ï≤¥Î†• Ïà´Ïûê =====
  ctx.fillStyle = "white";
  ctx.font = "bold 16px Arial";
  ctx.textAlign = "center";
  ctx.fillText(Math.floor(player.hp), x, y+6);

  ctx.restore(); // clip Î≥µÍµ¨
  ctx.restore(); // Ï†ÑÏ≤¥ Î≥µÍµ¨
}

function drawBossHpBar(){
  let boss = enemies.find(e => e.type === "boss");
  if(!boss) return;

  let barWidth = canvas.width * 0.6;
  let barHeight = 20;
  let x = canvas.width/2 - barWidth/2;
  let y = 20;

  let percent = boss.hp / boss.maxHp;
  if(percent < 0) percent = 0;

  ctx.save();
  ctx.fillStyle = "#220000";
  ctx.fillRect(x, y, barWidth, barHeight);

  let grad = ctx.createLinearGradient(x, y, x, y + barHeight);
  grad.addColorStop(0, "#ff3333");
  grad.addColorStop(1, "#880000");
  ctx.fillStyle = grad;
  ctx.fillRect(x, y, barWidth * percent, barHeight);

  ctx.lineWidth = 3;
  ctx.strokeStyle = "#550000";
  ctx.strokeRect(x, y, barWidth, barHeight);

  ctx.fillStyle = "white";
  ctx.font = "bold 16px Arial";
  ctx.textAlign = "center";
  ctx.fillText("HILLOCK", canvas.width/2, y - 5);
  ctx.restore();
}

function drawGameOver(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle="rgba(0,0,0,0.6)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="white";
  ctx.font="bold 40px Arial";
  ctx.textAlign="center";
  ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);

  ctx.font="bold 18px Arial";
  ctx.fillText("Tap to Restart", canvas.width/2, canvas.height/2 + 40);
}

canvas.addEventListener("touchstart", ()=>{ if(gameOver) resetGame(); });
canvas.addEventListener("mousedown", ()=>{ if(gameOver) resetGame(); });

function loop(){
  if(!gameOver){
    update();
    draw();
  }else{
    drawGameOver();
  }
  requestAnimationFrame(loop);
}

/* ===== Î¶¨ÏÖã ===== */
function resetGame(){
  if(audioUnlocked && !bgmOsc){
    bgmOsc = startBGM();
  }

  player.x = mapSize * tileSize / 2;
  player.y = mapSize * tileSize / 2;
  player.hp = 100;
  player.maxHp = 100;
  player.invul = 0;
  player.kiOrbs = 0;
  player.ultiActive = false;
  player.ultiCount = 0;
  player.ultiTimer = 0;
  player.levelGlow = 0;

  killCount = 0;
  level = 1;
  killsAtLevelStart = 0;
  killsForNextLevel = 20;
  baseDamage = 20;
  ultiDamage = 40;

  bossTimer = 0;
  bossInterval = 45 * 60;

  enemies = [];
  packs = [];
  particles = [];
  bloodPools = [];
  bloodParticles = [];
  arrows = [];
  levelParticles = [];
  fireZones = [];

  spawnTimer = 0;
  spawnInterval = 120;

  shake = 0;
  slowMotion = 0;

  gameOver = false;
  document.getElementById("ui").style.display = "flex";

  // ÏãúÏûë Ï£ºÎ≥Ä 2Í∞ú + ÎûúÎç§ 12Í∞ú
  for(let i=0;i<2;i++){
    let angle = Math.random()*Math.PI*2;
    let dist = 260 + Math.random()*180;
    let px = player.x + Math.cos(angle)*dist;
    let py = player.y + Math.sin(angle)*dist;

    let tx = clamp(Math.floor(px/tileSize), 1, mapSize-2);
    let ty = clamp(Math.floor(py/tileSize), 1, mapSize-2);

    if(map[ty][tx] !== 0){
      for(let k=0;k<50;k++){
        let rx = clamp(tx + (Math.floor(Math.random()*7)-3), 1, mapSize-2);
        let ry = clamp(ty + (Math.floor(Math.random()*7)-3), 1, mapSize-2);
        if(map[ry][rx] === 0){ tx=rx; ty=ry; break; }
      }
    }

    createPack(tx*tileSize + tileSize/2, ty*tileSize + tileSize/2, 18 + Math.floor(Math.random()*10));
  }

  for(let i=0;i<12;i++){
    let tileX, tileY;
    while(true){
      tileX = Math.floor(Math.random()*mapSize);
      tileY = Math.floor(Math.random()*mapSize);
      if(map[tileY][tileX] === 0) break;
    }
    let px = tileX * tileSize + tileSize/2;
    let py = tileY * tileSize + tileSize/2;
    createPack(px, py, 18 + Math.floor(Math.random()*12));
  }

  spawnRandomBoss();
  resize(); // ‚úÖ Î¶¨ÏÖã Ïãú Ï∫îÎ≤ÑÏä§ÎèÑ Ìïú Î≤à Îçî ÎßûÏ∂§
}

/* ===== Í≥µÍ≤© ÏïÑÏù¥ÏΩò ===== */
const iconCanvas = document.getElementById("attackIcon");
const iconCtx = iconCanvas.getContext("2d");
iconCtx.clearRect(0, 0, 60, 60);
iconCtx.save();
iconCtx.translate(30, 34);
iconCtx.scale(1.4, 1.4);
drawSwordShape(iconCtx);
iconCtx.restore();

resetGame();
loop();
</script>
</body>
</html>
