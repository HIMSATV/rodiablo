<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Isometric ARPG</title>
<style>
body{margin:0;overflow:hidden;background:#111;}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
canvas.width=innerWidth;
canvas.height=innerHeight;

const TILE=80;
const MAP=20;
const ZOOM=1.6;

let inputX=0,inputY=0;
let monsters=[];
let effects=[];

// ===== ISO 변환 =====
function iso(x,y){
  return {
    x:(x-y)*TILE/2,
    y:(x+y)*TILE/4
  }
}

function dist(a,b){
  return Math.hypot(a.x-b.x,a.y-b.y);
}

// ===== PLAYER =====
class Player{
  constructor(){
    this.x=0; this.y=0;
    this.speed=0.05;
    this.dir=0; // 0 up,1 right,2 down,3 left
    this.attackTimer=0;
  }

  update(){
    if(inputX||inputY){
      this.x+=inputX*this.speed;
      this.y+=inputY*this.speed;

      if(Math.abs(inputX)>Math.abs(inputY)){
        this.dir=inputX>0?1:3;
      }else{
        this.dir=inputY>0?2:0;
      }
    }

    if(this.attackTimer>0) this.attackTimer--;
  }

  attack(){
    if(this.attackTimer>0) return;
    this.attackTimer=15;

    effects.push(new Slash(this.x,this.y,this.dir));

    monsters.forEach(m=>{
      if(m.dead) return;
      let d=Math.hypot(m.x-this.x,m.y-this.y);
      if(d<1.5){ // 광역
        m.hp-=40;
        if(m.hp<=0){
          m.dead=true;
        }
      }
    });
  }

  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.8,ZOOM*1.8);

    // 망토
    ctx.fillStyle="#550000";
    ctx.fillRect(-6,-10,12,14);

    // 몸통
    ctx.fillStyle="#880000";
    ctx.fillRect(-5,-14,10,8);

    // 머리
    ctx.fillStyle="#222";
    ctx.fillRect(-4,-20,8,6);

    // 눈
    ctx.fillStyle="red";
    ctx.fillRect(-2,-18,1,1);
    ctx.fillRect(1,-18,1,1);

    ctx.restore();
  }
}

// ===== MONSTER =====
class Monster{
  constructor(x,y){
    this.x=x; this.y=y;
    this.hp=60;
    this.dead=false;
  }

  update(player){
    if(this.dead) return;
    let dx=player.x-this.x;
    let dy=player.y-this.y;
    let d=Math.hypot(dx,dy);

    if(d<6){
      this.x+=dx/d*0.02;
      this.y+=dy/d*0.02;
    }
  }

  draw(cam){
    if(this.dead) return;
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.5,ZOOM*1.5);

    // 몸
    ctx.fillStyle="#1e8449";
    ctx.fillRect(-6,-10,12,14);

    // 머리
    ctx.fillStyle="#145a32";
    ctx.fillRect(-5,-18,10,8);

    // 눈
    ctx.fillStyle="yellow";
    ctx.fillRect(-2,-15,1,1);
    ctx.fillRect(1,-15,1,1);

    ctx.restore();
  }
}

// ===== 검 궤적 =====
class Slash{
  constructor(x,y,dir){
    this.x=x;
    this.y=y;
    this.dir=dir;
    this.life=10;
  }

  update(){ this.life--; }

  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*2,ZOOM*2);

    ctx.strokeStyle="white";
    ctx.lineWidth=3;

    ctx.beginPath();

    if(this.dir===0) ctx.arc(0,-15,15,Math.PI*1.1,Math.PI*1.9);
    if(this.dir===1) ctx.arc(10,-5,15,-Math.PI*0.4,Math.PI*0.4);
    if(this.dir===2) ctx.arc(0,10,15,0.1,Math.PI-0.1);
    if(this.dir===3) ctx.arc(-10,-5,15,Math.PI*0.6,Math.PI*1.4);

    ctx.stroke();
    ctx.restore();
  }
}

// ===== 조이스틱 =====
const joystick={
  x:150,
  y:canvas.height-150,
  r:70
};

const attackBtn={
  x:canvas.width-150,
  y:canvas.height-150,
  r:60
};

canvas.addEventListener("touchstart",e=>{
  for(let t of e.touches){
    let dx=t.clientX-attackBtn.x;
    let dy=t.clientY-attackBtn.y;
    if(Math.hypot(dx,dy)<attackBtn.r){
      player.attack();
    }
  }
});

canvas.addEventListener("touchmove",e=>{
  let t=e.touches[0];
  let dx=t.clientX-joystick.x;
  let dy=t.clientY-joystick.y;
  let d=Math.hypot(dx,dy);

  if(d<joystick.r){
    inputX=dx/joystick.r;
    inputY=dy/joystick.r;
  }
});

canvas.addEventListener("touchend",()=>{
  inputX=0; inputY=0;
});

// ===== INIT =====
let player=new Player();
for(let i=0;i<6;i++)
  monsters.push(new Monster(Math.random()*4-2,Math.random()*4-2));

let cam={x:0,y:0};

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update();
  monsters.forEach(m=>m.update(player));
  effects.forEach(e=>e.update());
  effects=effects.filter(e=>e.life>0);
  monsters=monsters.filter(m=>!m.dead);

  cam.x+=(iso(player.x,player.y).x-cam.x)*0.1;
  cam.y+=(iso(player.x,player.y).y-cam.y)*0.1;

  // 체크무늬 바닥
  for(let x=-MAP;x<MAP;x++){
    for(let y=-MAP;y<MAP;y++){
      let p=iso(x,y);
      let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
      let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.lineTo(sx,sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.closePath();

      ctx.fillStyle=(x+y)%2==0?"#2a2a2a":"#353535";
      ctx.fill();
    }
  }

  monsters.forEach(m=>m.draw(cam));
  effects.forEach(e=>e.draw(cam));
  player.draw(cam);

  // 조이스틱 그리기
  ctx.globalAlpha=0.4;
  ctx.beginPath();
  ctx.arc(joystick.x,joystick.y,joystick.r,0,Math.PI*2);
  ctx.fillStyle="gray";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(attackBtn.x,attackBtn.y,attackBtn.r,0,Math.PI*2);
  ctx.fillStyle="darkred";
  ctx.fill();
  ctx.globalAlpha=1;

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
