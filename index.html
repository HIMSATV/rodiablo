<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Oni ARPG Ultimate</title>
<style>
body { margin:0; overflow:hidden; background:#111; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const TILE = 64;
const MAP = 30;
const ZOOM = 2.2;

let walls = {};
let monsters = [];
let particles = [];
let expOrbs = [];

function iso(x,y){
  return {
    x:(x-y)*TILE/2,
    y:(x+y)*TILE/4
  }
}

function key(x,y){ return x+"_"+y; }

// ===== 던전 자동 생성 =====
for(let x=-MAP;x<MAP;x++){
  for(let y=-MAP;y<MAP;y++){
    if(Math.random()<0.08){
      walls[key(x,y)] = true;
    }
  }
}

// ===== 사운드 엔진 =====
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
function beep(freq,time){
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.frequency.value = freq;
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.start();
  gain.gain.exponentialRampToValueAtTime(0.0001,audioCtx.currentTime+time);
  osc.stop(audioCtx.currentTime+time);
}

// ===== 플레이어 =====
class Player{
  constructor(){
    this.x=0; this.y=0;
    this.speed=0.04;
    this.dir=0;
    this.hp=100;
    this.maxHp=100;
    this.exp=0;
    this.level=1;
    this.attackTime=0;
  }

  move(dx,dy){
    if(!walls[key(Math.round(this.x+dx),Math.round(this.y+dy))]){
      this.x+=dx;
      this.y+=dy;
    }
  }

  update(inputX,inputY){
    if(inputX||inputY){
      this.dir=Math.atan2(inputY,inputX);
      this.move(inputX*this.speed,inputY*this.speed);
    }
    if(this.attackTime>0) this.attackTime--;
  }

  attack(){
    if(this.attackTime>0) return;
    this.attackTime=20;
    beep(200,0.1);

    monsters.forEach(m=>{
      let dx=m.x-this.x;
      let dy=m.y-this.y;
      let dist=Math.hypot(dx,dy);
      let ang=Math.atan2(dy,dx);
      let diff=Math.abs(ang-this.dir);

      if(dist<1.5 && diff<0.8){
        m.hp-=25;
        for(let i=0;i<15;i++) particles.push(new Blood(m.x,m.y));
        beep(100,0.1);
      }
    });
  }

  gainExp(v){
    this.exp+=v;
    if(this.exp>=this.level*50){
      this.exp=0;
      this.level++;
      this.maxHp+=20;
      this.hp=this.maxHp;
    }
  }

  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.8,ZOOM*1.8);

    ctx.fillStyle="#6b0000";
    ctx.fillRect(-6,-12,12,14);

    ctx.fillStyle="#400000";
    ctx.fillRect(-5,-18,10,7);

    ctx.fillStyle="#ddd";
    ctx.beginPath();
    ctx.moveTo(-4,-18); ctx.lineTo(-8,-25); ctx.lineTo(-2,-20); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(4,-18); ctx.lineTo(8,-25); ctx.lineTo(2,-20); ctx.fill();

    ctx.shadowColor="yellow";
    ctx.shadowBlur=8;
    ctx.fillStyle="yellow";
    ctx.fillRect(-3,-15,2,2);
    ctx.fillRect(1,-15,2,2);
    ctx.shadowBlur=0;

    if(this.attackTime>0){
      ctx.rotate(this.dir);
      ctx.fillStyle="#ccc";
      ctx.fillRect(0,-1,15,3);
    }

    ctx.restore();

    ctx.fillStyle="red";
    ctx.fillRect(20,20,(this.hp/this.maxHp)*200,15);

    ctx.fillStyle="white";
    ctx.fillText("Lv."+this.level,20,55);
  }
}

// ===== 몬스터 =====
class Monster{
  constructor(x,y,type){
    this.x=x; this.y=y;
    this.type=type;
    this.hp= type=="skeleton"?60:40;
    this.cool=0;
  }

  update(player){
    let dx=player.x-this.x;
    let dy=player.y-this.y;
    let dist=Math.hypot(dx,dy);

    if(this.type=="skeleton"){
      if(dist<5 && this.cool==0){
        this.cool=60;
      }
      if(this.cool>30){
        this.x+=dx/dist*0.07;
        this.y+=dy/dist*0.07;
        if(dist<1) player.hp-=0.5;
      }
    }

    if(this.type=="goblin"){
      if(dist<4){
        this.x+=dx/dist*0.02;
        this.y+=dy/dist*0.02;
      }
      if(dist<1.3 && this.cool==0){
        this.cool=50;
        player.hp-=5;
      }
    }

    if(this.cool>0) this.cool--;

    if(this.hp<=0){
      player.gainExp(20);
      expOrbs.push(new ExpOrb(this.x,this.y));
      this.dead=true;
    }
  }

  draw(cam){
    if(this.dead) return;
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.5,ZOOM*1.5);

    if(this.type=="skeleton"){
      ctx.fillStyle="#ddd";
      ctx.fillRect(-4,-10,8,12);
    }else{
      ctx.fillStyle="#1e8449";
      ctx.fillRect(-5,-10,10,12);
    }

    ctx.restore();
  }
}

// ===== 피 =====
class Blood{
  constructor(x,y){
    this.x=x; this.y=y;
    this.life=40;
  }
  update(){ this.life--; }
  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;
    ctx.fillStyle="darkred";
    ctx.fillRect(sx,sy,3,3);
  }
}

// ===== 경험치 구슬 =====
class ExpOrb{
  constructor(x,y){ this.x=x; this.y=y; }
  update(player){
    let dx=player.x-this.x;
    let dy=player.y-this.y;
    if(Math.hypot(dx,dy)<1){
      player.gainExp(10);
      this.collected=true;
    }
  }
  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;
    ctx.fillStyle="cyan";
    ctx.fillRect(sx,sy,4,4);
  }
}

// ===== 초기 생성 =====
let player=new Player();
for(let i=0;i<10;i++){
  monsters.push(new Monster(
    Math.random()*10-5,
    Math.random()*10-5,
    Math.random()<0.5?"skeleton":"goblin"
  ));
}

let cam={x:0,y:0};
let inputX=0,inputY=0;

window.addEventListener("keydown",e=>{
  if(e.key=="w") inputY=-1;
  if(e.key=="s") inputY=1;
  if(e.key=="a") inputX=-1;
  if(e.key=="d") inputX=1;
  if(e.key==" ") player.attack();
});
window.addEventListener("keyup",()=>{inputX=0;inputY=0;});

function lighting(){
  let grad=ctx.createRadialGradient(
    canvas.width/2,canvas.height/2,100,
    canvas.width/2,canvas.height/2,500);
  grad.addColorStop(0,"rgba(0,0,0,0)");
  grad.addColorStop(1,"rgba(0,0,0,0.65)");
  ctx.fillStyle=grad;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update(inputX,inputY);
  monsters.forEach(m=>m.update(player));
  particles.forEach(p=>p.update());
  expOrbs.forEach(o=>o.update(player));

  monsters=monsters.filter(m=>!m.dead);
  expOrbs=expOrbs.filter(o=>!o.collected);

  cam.x+=((iso(player.x,player.y).x)-cam.x)*0.1;
  cam.y+=((iso(player.x,player.y).y)-cam.y)*0.1;

  for(let x=-MAP;x<MAP;x++){
    for(let y=-MAP;y<MAP;y++){
      let p=iso(x,y);
      let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
      let sy=canvas.height/2+(p.y-cam.y)*ZOOM;
      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.lineTo(sx,sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.closePath();
      ctx.fillStyle=walls[key(x,y)]?"#222":"#3a3a3a";
      ctx.fill();
    }
  }

  monsters.forEach(m=>m.draw(cam));
  expOrbs.forEach(o=>o.draw(cam));
  particles.forEach(p=>p.draw(cam));
  player.draw(cam);

  lighting();

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
