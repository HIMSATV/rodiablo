<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IsoRPG Engine</title>
<style>
body{margin:0;background:#000;overflow:hidden;}
canvas{display:block;background:#0a0a0a;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");

function resize(){
  canvas.width=window.innerWidth;
  canvas.height=window.innerHeight;
}
resize();
window.addEventListener("resize",resize);

const TILE_W=64;
const TILE_H=32;

/* =========================
   WORLD MAP
========================= */

const MAP_W=30;
const MAP_H=30;

let map=[];
for(let y=0;y<MAP_H;y++){
  let row=[];
  for(let x=0;x<MAP_W;x++){
    if(x===0||y===0||x===MAP_W-1||y===MAP_H-1){
      row.push(1); // wall
    }else{
      row.push(0); // floor
    }
  }
  map.push(row);
}

/* =========================
   CAMERA
========================= */

let camera={x:0,y:0};

function isoToScreen(x,y){
  return {
    x:(x-y)*(TILE_W/2),
    y:(x+y)*(TILE_H/2)
  };
}

function worldToScreen(x,y){
  const iso=isoToScreen(x,y);
  return {
    x:iso.x-camera.x+canvas.width/2,
    y:iso.y-camera.y+canvas.height/2
  };
}

/* =========================
   ENTITIES
========================= */

let player={
  x:15,
  y:15,
  color:"#8b0000",
  hp:100
};

let monsters=[];
for(let i=0;i<20;i++){
  monsters.push({
    x:Math.random()*MAP_W,
    y:Math.random()*MAP_H,
    color:"#2f6b2f"
  });
}

/* =========================
   TORCHES (LIGHT SOURCES)
========================= */

let torches=[
  {x:10,y:10},
  {x:20,y:18}
];

/* =========================
   DRAW TILE
========================= */

function drawTile(x,y,type){
  const pos=worldToScreen(x,y);

  ctx.beginPath();
  ctx.moveTo(pos.x,pos.y);
  ctx.lineTo(pos.x+TILE_W/2,pos.y+TILE_H/2);
  ctx.lineTo(pos.x,pos.y+TILE_H);
  ctx.lineTo(pos.x-TILE_W/2,pos.y+TILE_H/2);
  ctx.closePath();

  if(type===0){
    ctx.fillStyle=(x+y)%2?"#1c1c1c":"#111";
  }else{
    ctx.fillStyle="#333";
  }

  ctx.fill();
}

/* =========================
   DRAW ENTITY
========================= */

function drawEntity(e){
  const pos=worldToScreen(e.x,e.y);

  ctx.fillStyle="rgba(0,0,0,0.6)";
  ctx.beginPath();
  ctx.ellipse(pos.x,pos.y+12,12,6,0,0,Math.PI*2);
  ctx.fill();

  ctx.fillStyle=e.color;
  ctx.fillRect(pos.x-10,pos.y-20,20,20);
}

/* =========================
   LIGHTING SYSTEM
========================= */

function drawLighting(){
  ctx.fillStyle="rgba(0,0,0,0.85)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.globalCompositeOperation="destination-out";

  // player light
  let ppos=worldToScreen(player.x,player.y);
  drawLight(ppos.x,ppos.y,140);

  // torches
  torches.forEach(t=>{
    let pos=worldToScreen(t.x,t.y);
    drawLight(pos.x,pos.y,120);
  });

  ctx.globalCompositeOperation="source-over";
}

function drawLight(x,y,r){
  const gradient=ctx.createRadialGradient(x,y,10,x,y,r);
  gradient.addColorStop(0,"rgba(0,0,0,1)");
  gradient.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle=gradient;
  ctx.beginPath();
  ctx.arc(x,y,r,0,Math.PI*2);
  ctx.fill();
}

/* =========================
   INPUT (MOBILE + PC)
========================= */

canvas.addEventListener("click",moveTo);
canvas.addEventListener("touchstart",(e)=>{
  moveTo(e.touches[0]);
});

function moveTo(e){
  const rect=canvas.getBoundingClientRect();
  const mx=e.clientX-rect.left;
  const my=e.clientY-rect.top;

  // 간단 이동
  player.x += (Math.random()-0.5)*2;
  player.y += (Math.random()-0.5)*2;
}

/* =========================
   MAIN LOOP
========================= */

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // camera follow
  const cam=isoToScreen(player.x,player.y);
  camera.x=cam.x;
  camera.y=cam.y;

  // draw map
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      drawTile(x,y,map[y][x]);
    }
  }

  // depth sort
  let entities=[...monsters,player];
  entities.sort((a,b)=>(a.x+a.y)-(b.x+b.y));
  entities.forEach(drawEntity);

  // lighting
  drawLighting();

  requestAnimationFrame(loop);
}
loop();

</script>
</body>
</html>
