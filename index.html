
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Blood of the Ronin - Ultimate Katana</title>
<style>
body { margin:0; background:black; overflow:hidden; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let player = {x:canvas.width/2,y:canvas.height/2,dir:0};
let enemies=[];
let particles=[];
let slashes=[];
let attacking=false;
let attackFrame=0;

function spawnEnemy(){
 enemies.push({x:Math.random()*canvas.width,
               y:Math.random()*canvas.height,
               hp:40});
}
for(let i=0;i<6;i++) spawnEnemy();

canvas.addEventListener("mousedown",input);
canvas.addEventListener("touchstart",input);

function input(e){
 let x=e.touches?e.touches[0].clientX:e.clientX;
 let y=e.touches?e.touches[0].clientY:e.clientY;

 let dx=x-player.x;
 let dy=y-player.y;
 player.dir=Math.atan2(dy,dx);

 player.x=x;
 player.y=y;

 attacking=true;
 attackFrame=0;
 playSlash();
 setTimeout(()=>attacking=false,350);
}

function spawnBlood(x,y){
 for(let i=0;i<10;i++){
  particles.push({
   x,y,
   vx:(Math.random()-0.5)*6,
   vy:(Math.random()-0.5)*6,
   life:40
  });
 }
}

function update(){
 if(attacking){
  attackFrame++;
  if(attackFrame%3===0){
   slashes.push({x:player.x,y:player.y,angle:player.dir,life:15});
  }
 }

 enemies.forEach(enemy=>{
  let dx=player.x-enemy.x;
  let dy=player.y-enemy.y;
  let dist=Math.sqrt(dx*dx+dy*dy);
  if(dist>0){
   enemy.x+=dx/dist*0.7;
   enemy.y+=dy/dist*0.7;
  }
  if(attacking && dist<65 && attackFrame===3){
   enemy.hp-=20;
   spawnBlood(enemy.x,enemy.y);
  }
 });

 enemies=enemies.filter(e=>e.hp>0);
 if(enemies.length<6) spawnEnemy();

 particles.forEach(p=>{
  p.x+=p.vx;
  p.y+=p.vy;
  p.life--;
 });
 particles=particles.filter(p=>p.life>0);

 slashes.forEach(s=>s.life--);
 slashes=slashes.filter(s=>s.life>0);
}

function drawPlayer(){
 // body
 ctx.fillStyle="#550000";
 ctx.fillRect(player.x-12,player.y-12,24,24);

 // head
 ctx.fillStyle="#aa0000";
 ctx.fillRect(player.x-8,player.y-22,16,12);

 // horns
 ctx.fillStyle="#ffffcc";
 ctx.fillRect(player.x-10,player.y-24,6,6);
 ctx.fillRect(player.x+4,player.y-24,6,6);

 // eyes
 ctx.fillStyle=attacking?"yellow":"white";
 ctx.fillRect(player.x-4,player.y-18,3,3);
 ctx.fillRect(player.x+1,player.y-18,3,3);

 if(attacking){
  drawKatana();
 }
}

function drawKatana(){
 ctx.save();
 ctx.translate(player.x,player.y);

 let frame=attackFrame%3;
 let offset=[-1,0,1][frame];

 ctx.rotate(player.dir+offset*0.8);

 ctx.fillStyle="#dddddd";
 ctx.fillRect(0,-3,55,6);

 ctx.fillStyle="#552200";
 ctx.fillRect(-10,-4,10,8);

 ctx.restore();
}

function draw(){
 ctx.fillStyle="#111";
 ctx.fillRect(0,0,canvas.width,canvas.height);

 enemies.forEach(e=>{
  ctx.fillStyle="#003300";
  ctx.fillRect(e.x-12,e.y-12,24,24);
 });

 drawPlayer();

 ctx.fillStyle="#aa0000";
 particles.forEach(p=>{
  ctx.fillRect(p.x,p.y,3,3);
 });

 slashes.forEach(s=>{
  ctx.save();
  ctx.translate(s.x,s.y);
  ctx.rotate(s.angle);
  ctx.strokeStyle="rgba(255,255,255,"+(s.life/15)+")";
  ctx.lineWidth=4;
  ctx.beginPath();
  ctx.arc(0,0,50,-0.5,0.5);
  ctx.stroke();
  ctx.restore();
 });

 let g=ctx.createRadialGradient(player.x,player.y,80,player.x,player.y,300);
 g.addColorStop(0,"rgba(0,0,0,0)");
 g.addColorStop(1,"rgba(0,0,0,0.95)");
 ctx.fillStyle=g;
 ctx.fillRect(0,0,canvas.width,canvas.height);
}

function loop(){
 update();
 draw();
 requestAnimationFrame(loop);
}
loop();

// ---- Sound ----
let audioCtx=new (window.AudioContext||window.webkitAudioContext)();

function playSlash(){
 let osc=audioCtx.createOscillator();
 let gain=audioCtx.createGain();
 osc.type="sawtooth";
 osc.frequency.setValueAtTime(400,audioCtx.currentTime);
 osc.frequency.exponentialRampToValueAtTime(80,audioCtx.currentTime+0.2);
 gain.gain.setValueAtTime(0.3,audioCtx.currentTime);
 gain.gain.exponentialRampToValueAtTime(0.01,audioCtx.currentTime+0.3);
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start();
 osc.stop(audioCtx.currentTime+0.3);
}

// ambient loop
function ambient(){
 let osc=audioCtx.createOscillator();
 let gain=audioCtx.createGain();
 osc.type="sine";
 osc.frequency.value=60;
 gain.gain.value=0.05;
 osc.connect(gain);
 gain.connect(audioCtx.destination);
 osc.start();
}
ambient();

</script>
</body>
</html>
