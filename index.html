<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Ronin Combat Upgrade</title>
<style>
body{margin:0;background:black;overflow:hidden;}
canvas{display:block;}

#uiBar{
  position:fixed;
  bottom:0;
  width:100%;
  height:140px;
  background:linear-gradient(#1a0000,#000);
  border-top:3px solid #550000;
}

#joystickBase{
  position:absolute;
  left:40px;
  bottom:20px;
  width:120px;height:120px;
  border-radius:50%;
  background:rgba(255,255,255,0.08);
}
#joystick{
  position:absolute;
  width:60px;height:60px;
  border-radius:50%;
  background:rgba(255,255,255,0.25);
  left:30px;top:30px;
}

#attackBtn{
  position:absolute;
  right:40px;
  bottom:35px;
  width:90px;height:90px;
  border-radius:50%;
  background:radial-gradient(circle,#aa0000,#440000);
  border:3px solid #ff4444;
  display:flex;align-items:center;justify-content:center;
  color:white;font-size:22px;
}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="uiBar">
  <div id="joystickBase"><div id="joystick"></div></div>
  <div id="attackBtn">⚔</div>
</div>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
canvas.width=window.innerWidth;
canvas.height=window.innerHeight-140;

/* ===== 플레이어 ===== */
let player={
  x:canvas.width/2,
  y:canvas.height/2,
  dir:0,
  speed:2,
  radius:14
};

let enemies=[];
let particles=[];
let attacking=false;
let attackCooldown=0;

/* ===== 적 생성 ===== */
function spawnEnemy(){
  enemies.push({
    x:Math.random()*canvas.width,
    y:Math.random()*canvas.height,
    hp:40,
    radius:14
  });
}
for(let i=0;i<6;i++) spawnEnemy();

/* ===== 자동 타겟 ===== */
function findClosest(){
  let min=9999, target=null;
  enemies.forEach(e=>{
    let dx=e.x-player.x;
    let dy=e.y-player.y;
    let d=Math.hypot(dx,dy);
    if(d<min){min=d;target=e;}
  });
  return target;
}

/* ===== 공격 ===== */
document.getElementById("attackBtn").addEventListener("touchstart",attack);
document.getElementById("attackBtn").addEventListener("mousedown",attack);

function attack(){
  if(attackCooldown>0) return;

  let target=findClosest();
  if(!target) return;

  let dx=target.x-player.x;
  let dy=target.y-player.y;
  let dist=Math.hypot(dx,dy);
  if(dist>100) return;

  player.dir=Math.atan2(dy,dx);
  attacking=true;
  attackCooldown=30;

  enemies.forEach(e=>{
    let dx=e.x-player.x;
    let dy=e.y-player.y;
    let dist=Math.hypot(dx,dy);
    let angle=Math.atan2(dy,dx);
    let diff=Math.abs(angle-player.dir);

    if(dist<80 && diff<0.8){ // 부채꼴 판정
      e.hp-=20;
      spawnBlood(e.x,e.y);
    }
  });

  setTimeout(()=>attacking=false,200);
}

/* ===== 피 효과 ===== */
function spawnBlood(x,y){
  for(let i=0;i<8;i++){
    particles.push({
      x,y,
      vx:(Math.random()-0.5)*4,
      vy:(Math.random()-0.5)*4,
      life:25
    });
  }
}

/* ===== 조이스틱 ===== */
let joyActive=false,joyDX=0,joyDY=0;
const base=document.getElementById("joystickBase");
const stick=document.getElementById("joystick");

base.addEventListener("touchstart",()=>joyActive=true);
base.addEventListener("touchmove",e=>{
  if(!joyActive)return;
  let r=base.getBoundingClientRect();
  let x=e.touches[0].clientX-r.left;
  let y=e.touches[0].clientY-r.top;
  joyDX=x-60; joyDY=y-60;

  let d=Math.hypot(joyDX,joyDY);
  if(d>50){
    joyDX=joyDX/d*50;
    joyDY=joyDY/d*50;
  }

  stick.style.left=(joyDX+30)+"px";
  stick.style.top=(joyDY+30)+"px";
});
base.addEventListener("touchend",()=>{
  joyActive=false;joyDX=joyDY=0;
  stick.style.left="30px";stick.style.top="30px";
});

/* ===== 충돌 밀어내기 ===== */
function resolveCollision(a,b){
  let dx=a.x-b.x;
  let dy=a.y-b.y;
  let dist=Math.hypot(dx,dy);
  let min=a.radius+b.radius;
  if(dist<min && dist>0){
    let push=(min-dist)/2;
    a.x+=dx/dist*push;
    a.y+=dy/dist*push;
    b.x-=dx/dist*push;
    b.y-=dy/dist*push;
  }
}

/* ===== 업데이트 ===== */
function update(){

  if(joyActive){
    player.x+=joyDX/50*player.speed;
    player.y+=joyDY/50*player.speed;
    if(Math.hypot(joyDX,joyDY)>5)
      player.dir=Math.atan2(joyDY,joyDX);
  }

  enemies.forEach(e=>{
    let dx=player.x-e.x;
    let dy=player.y-e.y;
    let d=Math.hypot(dx,dy);
    if(d>0){
      e.x+=dx/d*0.6;
      e.y+=dy/d*0.6;
    }
    resolveCollision(player,e);
  });

  enemies=enemies.filter(e=>e.hp>0);
  if(enemies.length<6) spawnEnemy();

  particles.forEach(p=>{
    p.x+=p.vx;p.y+=p.vy;p.life--;
  });
  particles=particles.filter(p=>p.life>0);

  if(attackCooldown>0) attackCooldown--;
}

/* ===== 4방향 검 애니메이션 ===== */
function drawKatana(x,y){
  ctx.save();
  ctx.translate(x,y);

  let dir=Math.round(player.dir/(Math.PI/2));
  ctx.fillStyle="#ccc";

  if(dir===0){ ctx.fillRect(10,-2,40,4); }      // →
  else if(dir===1){ ctx.fillRect(-2,10,4,40); } // ↓
  else if(dir===-1){ ctx.fillRect(-2,-40,4,40);} // ↑
  else { ctx.fillRect(-40,-2,40,4); }           // ←

  ctx.restore();
}

/* ===== 캐릭터 ===== */
function drawOni(x,y){
  ctx.fillStyle="#770000";
  ctx.fillRect(x-10,y-10,20,20);

  ctx.fillStyle="#cc0000";
  ctx.fillRect(x-6,y-18,12,10);

  ctx.fillStyle="#ffffcc";
  ctx.fillRect(x-8,y-20,4,6);
  ctx.fillRect(x+4,y-20,4,6);

  ctx.fillStyle=attacking?"#ffff00":"#ffffff";
  ctx.fillRect(x-3,y-15,2,2);
  ctx.fillRect(x+1,y-15,2,2);

  if(attacking) drawKatana(x,y);
}

function drawGoblin(x,y){
  ctx.fillStyle="#004400";
  ctx.fillRect(x-10,y-10,20,20);

  ctx.fillStyle="#00aa00";
  ctx.fillRect(x-6,y-16,12,8);

  ctx.fillStyle="#ffffff";
  ctx.fillRect(x-4,y-14,2,2);
  ctx.fillRect(x+2,y-14,2,2);
}

/* ===== 그리기 ===== */
function draw(){
  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  enemies.forEach(e=>drawGoblin(e.x,e.y));
  drawOni(player.x,player.y);

  ctx.fillStyle="#aa0000";
  particles.forEach(p=>{
    ctx.fillRect(p.x,p.y,3,3);
  });
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
