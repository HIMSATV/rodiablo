<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Oni Samurai Fixed</title>
<style>
body { margin:0; overflow:hidden; background:#1a1a1a; }
canvas { display:block; touch-action:none; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const TILE = 64;
const MAP_SIZE = 20;
const ZOOM = 2.5;

let keys = {};
let attacking = false;
let pointer = {x:canvas.width/2, y:canvas.height/2};
let touchMove = null;

document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

canvas.addEventListener("mousemove", e=>{
  pointer.x = e.clientX;
  pointer.y = e.clientY;
});

canvas.addEventListener("mousedown", ()=> attacking = true);
canvas.addEventListener("mouseup", ()=> attacking = false);

canvas.addEventListener("touchstart", e=>{
  attacking = true;
  touchMove = e.touches[0];
});

canvas.addEventListener("touchmove", e=>{
  touchMove = e.touches[0];
});

canvas.addEventListener("touchend", ()=>{
  attacking = false;
  touchMove = null;
});

class Player{
  constructor(){
    this.x = 0;
    this.y = 0;
    this.speed = 0.15;
    this.dir = 0;
    this.attackFrame = 0;
  }

  update(){
    let dx = 0;
    let dy = 0;

    // PC 이동
    if(keys["w"]) dy -= 1;
    if(keys["s"]) dy += 1;
    if(keys["a"]) dx -= 1;
    if(keys["d"]) dx += 1;

    // 모바일 이동 (화면 터치 위치 기준)
    if(touchMove){
      dx = (touchMove.clientX - canvas.width/2)/100;
      dy = (touchMove.clientY - canvas.height/2)/100;
    }

    if(dx !== 0 || dy !== 0){
      this.x += dx * this.speed;
      this.y += dy * this.speed;
    }

    // 항상 포인터 방향 바라봄
    let px = pointer.x - canvas.width/2;
    let py = pointer.y - canvas.height/2;
    this.dir = Math.atan2(py, px);

    if(attacking){
      this.attackFrame++;
      if(this.attackFrame > 15){
        this.attackFrame = 0;
        attacking = false;
      }
    }
  }

  draw(camX, camY){
    const isoX = (this.x - this.y) * TILE/2;
    const isoY = (this.x + this.y) * TILE/4;

    const sx = canvas.width/2 + (isoX - camX) * ZOOM;
    const sy = canvas.height/2 + (isoY - camY) * ZOOM;

    ctx.save();
    ctx.translate(sx, sy);
    ctx.scale(ZOOM*1.6, ZOOM*1.6);

    // 몸통
    ctx.fillStyle="#7a0000";
    ctx.fillRect(-5,-10,10,12);

    // 투구
    ctx.fillStyle="#550000";
    ctx.fillRect(-4,-16,8,6);

    // 뿔
    ctx.fillStyle="#ddd";
    ctx.beginPath();
    ctx.moveTo(-3,-16); ctx.lineTo(-6,-22); ctx.lineTo(-2,-18); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(3,-16); ctx.lineTo(6,-22); ctx.lineTo(2,-18); ctx.fill();

    // 눈
    ctx.fillStyle="yellow";
    ctx.fillRect(-2,-13,2,2);
    ctx.fillRect(1,-13,2,2);

    // 다리
    ctx.fillStyle="#222";
    ctx.fillRect(-3,2,3,8);
    ctx.fillRect(1,2,3,8);

    // ⚔ 360도 휘두르기
    ctx.strokeStyle="#ddd";
    ctx.lineWidth=2;

    let angle = this.dir;
    if(this.attackFrame > 0){
      let progress = this.attackFrame/15;
      angle += -1 + progress*2;
    }

    ctx.beginPath();
    ctx.moveTo(0,-6);
    ctx.lineTo(14*Math.cos(angle), -6 + 14*Math.sin(angle));
    ctx.stroke();

    ctx.restore();
  }
}

class Goblin{
  constructor(x,y){
    this.x=x;
    this.y=y;
    this.speed=0.05;
  }

  update(player){
    let dx=player.x-this.x;
    let dy=player.y-this.y;
    let dist=Math.hypot(dx,dy);
    if(dist>0 && dist<6){
      this.x+=dx/dist*this.speed;
      this.y+=dy/dist*this.speed;
    }
  }

  draw(camX,camY){
    const isoX=(this.x-this.y)*TILE/2;
    const isoY=(this.x+this.y)*TILE/4;
    const sx=canvas.width/2+(isoX-camX)*ZOOM;
    const sy=canvas.height/2+(isoY-camY)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.4,ZOOM*1.4);

    ctx.fillStyle="#2ecc71";
    ctx.fillRect(-4,-8,8,10);
    ctx.fillStyle="#145a32";
    ctx.fillRect(-3,-12,6,4);
    ctx.fillStyle="black";
    ctx.fillRect(-2,-11,1,1);
    ctx.fillRect(1,-11,1,1);

    ctx.restore();
  }
}

const player = new Player();
const goblins = [new Goblin(3,3), new Goblin(-4,2)];

let camX=0;
let camY=0;

function drawMap(){
  for(let x=-MAP_SIZE;x<MAP_SIZE;x++){
    for(let y=-MAP_SIZE;y<MAP_SIZE;y++){
      const isoX=(x-y)*TILE/2;
      const isoY=(x+y)*TILE/4;
      const sx=canvas.width/2+(isoX-camX)*ZOOM;
      const sy=canvas.height/2+(isoY-camY)*ZOOM;

      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.lineTo(sx,sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.closePath();

      ctx.fillStyle=(x+y)%2==0?"#3a3a3a":"#444";
      ctx.fill();
      ctx.strokeStyle="#2a2a2a";
      ctx.stroke();
    }
  }
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update();
  goblins.forEach(g=>g.update(player));

  camX += ((player.x - player.y)*TILE/2 - camX)*0.1;
  camY += ((player.x + player.y)*TILE/4 - camY)*0.1;

  drawMap();
  goblins.forEach(g=>g.draw(camX,camY));
  player.draw(camX,camY);

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
