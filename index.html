<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Oni ARPG Close Cam</title>
<style>
body{margin:0;overflow:hidden;background:#111;}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
canvas.width=innerWidth;
canvas.height=innerHeight;

const TILE=90;
const MAP=20;
const ZOOM=2.3;   // üî• ÏãúÏ†ê Í∞ÄÍπåÏù¥

let inputX=0,inputY=0;
let monsters=[];
let effects=[];

function iso(x,y){
  return { x:(x-y)*TILE/2, y:(x+y)*TILE/4 }
}

function distance(a,b){
  return Math.hypot(a.x-b.x,a.y-b.y);
}

// ===== PLAYER =====
class Player{
  constructor(){
    this.x=0;
    this.y=0;
    this.speed=0.045;
    this.radius=0.5;
    this.dir=0;
    this.attackTimer=0;
  }

  update(){
    let nx=this.x+inputX*this.speed;
    let ny=this.y+inputY*this.speed;

    // Î™¨Ïä§ÌÑ∞ÏôÄ Ï∂©Îèå Î∞©ÏßÄ
    monsters.forEach(m=>{
      if(m.dead) return;
      let dx=nx-m.x;
      let dy=ny-m.y;
      let d=Math.hypot(dx,dy);
      let min=this.radius+m.radius;

      if(d<min){
        let push=(min-d)/2;
        nx+=dx/d*push;
        ny+=dy/d*push;
      }
    });

    this.x=nx;
    this.y=ny;

    if(inputX||inputY){
      if(Math.abs(inputX)>Math.abs(inputY)){
        this.dir=inputX>0?1:3;
      }else{
        this.dir=inputY>0?2:0;
      }
    }

    if(this.attackTimer>0) this.attackTimer--;
  }

  attack(){
    if(this.attackTimer>0) return;
    this.attackTimer=15;
    effects.push(new Slash(this.x,this.y,this.dir));

    monsters.forEach(m=>{
      if(m.dead) return;
      if(distance(this,m)<1.6){
        m.hp-=50;
        if(m.hp<=0) m.dead=true;
      }
    });
  }

  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.9,ZOOM*1.9);

    // ÎßùÌÜ†
    ctx.fillStyle="#550000";
    ctx.fillRect(-6,-10,12,14);

    // Î™∏ÌÜµ
    ctx.fillStyle="#990000";
    ctx.fillRect(-5,-15,10,9);

    // Î®∏Î¶¨
    ctx.fillStyle="#222";
    ctx.fillRect(-4,-22,8,7);

    // üî• Îøî Î≥µÍµ¨
    ctx.strokeStyle="white";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(-4,-22);
    ctx.quadraticCurveTo(-8,-28,-6,-20);
    ctx.moveTo(4,-22);
    ctx.quadraticCurveTo(8,-28,6,-20);
    ctx.stroke();

    // Îàà
    ctx.fillStyle="yellow";
    ctx.fillRect(-2,-19,1,1);
    ctx.fillRect(1,-19,1,1);

    ctx.restore();
  }
}

// ===== MONSTER =====
class Monster{
  constructor(x,y){
    this.x=x;
    this.y=y;
    this.radius=0.5;
    this.hp=60;
    this.dead=false;
  }

  update(player){
    if(this.dead) return;

    let dx=player.x-this.x;
    let dy=player.y-this.y;
    let d=Math.hypot(dx,dy);

    if(d<6){
      this.x+=dx/d*0.02;
      this.y+=dy/d*0.02;
    }

    // Î™¨Ïä§ÌÑ∞ÎÅºÎ¶¨ Ï∂©Îèå
    monsters.forEach(m=>{
      if(m===this||m.dead) return;
      let dx=this.x-m.x;
      let dy=this.y-m.y;
      let d=Math.hypot(dx,dy);
      let min=this.radius+m.radius;
      if(d<min){
        let push=(min-d)/2;
        this.x+=dx/d*push;
        this.y+=dy/d*push;
      }
    });
  }

  draw(cam){
    if(this.dead) return;
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.6,ZOOM*1.6);

    // Î™∏
    ctx.fillStyle="#1e8449";
    ctx.fillRect(-6,-12,12,16);

    // Î®∏Î¶¨
    ctx.fillStyle="#145a32";
    ctx.fillRect(-5,-20,10,8);

    // Îàà
    ctx.fillStyle="lime";
    ctx.fillRect(-2,-17,1,1);
    ctx.fillRect(1,-17,1,1);

    ctx.restore();
  }
}

// ===== SLASH =====
class Slash{
  constructor(x,y,dir){
    this.x=x; this.y=y;
    this.dir=dir;
    this.life=8;
  }
  update(){ this.life--; }
  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*2,ZOOM*2);
    ctx.strokeStyle="white";
    ctx.lineWidth=3;
    ctx.beginPath();

    if(this.dir===0) ctx.arc(0,-15,18,Math.PI*1.1,Math.PI*1.9);
    if(this.dir===1) ctx.arc(15,-5,18,-0.5,0.5);
    if(this.dir===2) ctx.arc(0,15,18,0.1,Math.PI-0.1);
    if(this.dir===3) ctx.arc(-15,-5,18,Math.PI*0.6,Math.PI*1.4);

    ctx.stroke();
    ctx.restore();
  }
}

// ===== UI =====
const joystick={ x:160, y:canvas.height-160, r:75 };
const attackBtn={ x:canvas.width-160, y:canvas.height-160, r:65 };

canvas.addEventListener("touchmove",e=>{
  let t=e.touches[0];
  let dx=t.clientX-joystick.x;
  let dy=t.clientY-joystick.y;
  let d=Math.hypot(dx,dy);
  if(d<joystick.r){
    inputX=dx/joystick.r;
    inputY=dy/joystick.r;
  }
});

canvas.addEventListener("touchend",()=>{ inputX=0; inputY=0; });

canvas.addEventListener("touchstart",e=>{
  for(let t of e.touches){
    if(Math.hypot(t.clientX-attackBtn.x,t.clientY-attackBtn.y)<attackBtn.r)
      player.attack();
  }
});

// ===== INIT =====
let player=new Player();
for(let i=0;i<6;i++)
  monsters.push(new Monster(Math.random()*4-2,Math.random()*4-2));

let cam={x:0,y:0};

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update();
  monsters.forEach(m=>m.update(player));
  effects.forEach(e=>e.update());
  effects=effects.filter(e=>e.life>0);
  monsters=monsters.filter(m=>!m.dead);

  cam.x+=(iso(player.x,player.y).x-cam.x)*0.2;
  cam.y+=(iso(player.x,player.y).y-cam.y)*0.2;

  // Ï≤¥ÌÅ¨ Î∞îÎã•
  for(let x=-MAP;x<MAP;x++){
    for(let y=-MAP;y<MAP;y++){
      let p=iso(x,y);
      let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
      let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.lineTo(sx,sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.closePath();

      ctx.fillStyle=(x+y)%2==0?"#2b2b2b":"#383838";
      ctx.fill();
    }
  }

  monsters.forEach(m=>m.draw(cam));
  effects.forEach(e=>e.draw(cam));
  player.draw(cam);

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
