<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Oni Samurai Clean</title>
<style>
body { margin:0; overflow:hidden; background:#1a1a1a; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const TILE = 64;
const MAP_SIZE = 20;
const ZOOM = 2.5;

let keys = {};
let attacking = false;

document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

canvas.addEventListener("mousedown", ()=> attacking = true);
canvas.addEventListener("mouseup", ()=> attacking = false);
canvas.addEventListener("touchstart", ()=> attacking = true);
canvas.addEventListener("touchend", ()=> attacking = false);

class Player{
  constructor(){
    this.x = 0;
    this.y = 0;
    this.speed = 0.12;
    this.dir = 0;
    this.attackFrame = 0;
  }

  update(){
    let dx = 0;
    let dy = 0;

    if(keys["w"]) dy -= 1;
    if(keys["s"]) dy += 1;
    if(keys["a"]) dx -= 1;
    if(keys["d"]) dx += 1;

    if(dx !== 0 || dy !== 0){
      this.x += dx * this.speed;
      this.y += dy * this.speed;
      this.dir = Math.atan2(dy, dx);
    }

    if(attacking){
      this.attackFrame++;
      if(this.attackFrame > 12){
        this.attackFrame = 0;
        attacking = false;
      }
    }
  }

  draw(camX, camY){
    const isoX = (this.x - this.y) * TILE/2;
    const isoY = (this.x + this.y) * TILE/4;

    const sx = canvas.width/2 + (isoX - camX) * ZOOM;
    const sy = canvas.height/2 + (isoY - camY) * ZOOM;

    ctx.save();
    ctx.translate(sx, sy);
    ctx.scale(ZOOM*1.6, ZOOM*1.6);

    // 그림자
    ctx.fillStyle="rgba(0,0,0,0.4)";
    ctx.beginPath();
    ctx.ellipse(0,8,6,3,0,0,Math.PI*2);
    ctx.fill();

    // 갑주
    ctx.fillStyle="#7a0000";
    ctx.fillRect(-5,-10,10,12);

    // 투구
    ctx.fillStyle="#550000";
    ctx.fillRect(-4,-16,8,6);

    // 뿔
    ctx.fillStyle="#ddd";
    ctx.beginPath();
    ctx.moveTo(-3,-16); ctx.lineTo(-6,-22); ctx.lineTo(-2,-18); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(3,-16); ctx.lineTo(6,-22); ctx.lineTo(2,-18); ctx.fill();

    // 눈
    ctx.fillStyle="yellow";
    ctx.fillRect(-2,-13,2,2);
    ctx.fillRect(1,-13,2,2);

    // 다리
    ctx.fillStyle="#222";
    ctx.fillRect(-3,2,3,8);
    ctx.fillRect(1,2,3,8);

    // 칼 휘두르기
    ctx.strokeStyle="#ddd";
    ctx.lineWidth=2;

    let angle = this.dir;
    if(this.attackFrame > 0){
      let progress = this.attackFrame/12;
      angle += -1 + progress*2;
    }

    ctx.beginPath();
    ctx.moveTo(0,-6);
    ctx.lineTo(14*Math.cos(angle), -6 + 14*Math.sin(angle));
    ctx.stroke();

    ctx.restore();
  }
}

class Goblin{
  constructor(x,y){
    this.x = x;
    this.y = y;
    this.speed = 0.05;
  }

  update(player){
    let dx = player.x - this.x;
    let dy = player.y - this.y;
    let dist = Math.hypot(dx,dy);
    if(dist > 0 && dist < 6){
      this.x += dx/dist * this.speed;
      this.y += dy/dist * this.speed;
    }
  }

  draw(camX, camY){
    const isoX = (this.x - this.y) * TILE/2;
    const isoY = (this.x + this.y) * TILE/4;

    const sx = canvas.width/2 + (isoX - camX) * ZOOM;
    const sy = canvas.height/2 + (isoY - camY) * ZOOM;

    ctx.save();
    ctx.translate(sx, sy);
    ctx.scale(ZOOM*1.4, ZOOM*1.4);

    // 몸통
    ctx.fillStyle="#2ecc71";
    ctx.fillRect(-4,-8,8,10);

    // 얼굴
    ctx.fillStyle="#1e8449";
    ctx.fillRect(-3,-12,6,4);

    // 눈
    ctx.fillStyle="black";
    ctx.fillRect(-2,-11,1,1);
    ctx.fillRect(1,-11,1,1);

    // 이빨
    ctx.fillStyle="white";
    ctx.fillRect(-1,-8,2,2);

    ctx.restore();
  }
}

const player = new Player();
const goblins = [
  new Goblin(3,3),
  new Goblin(-4,2),
  new Goblin(2,-5)
];

let camX = 0;
let camY = 0;

function drawMap(){
  for(let x=-MAP_SIZE; x<MAP_SIZE; x++){
    for(let y=-MAP_SIZE; y<MAP_SIZE; y++){

      const isoX = (x - y) * TILE/2;
      const isoY = (x + y) * TILE/4;

      const sx = canvas.width/2 + (isoX - camX) * ZOOM;
      const sy = canvas.height/2 + (isoY - camY) * ZOOM;

      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(sx+TILE/2*ZOOM, sy+TILE/4*ZOOM);
      ctx.lineTo(sx, sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM, sy+TILE/4*ZOOM);
      ctx.closePath();

      ctx.fillStyle = (x+y)%2==0 ? "#3a3a3a" : "#444";
      ctx.fill();

      ctx.strokeStyle="#2a2a2a";
      ctx.stroke();
    }
  }
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update();
  goblins.forEach(g=>g.update(player));

  camX += ((player.x - player.y)*TILE/2 - camX) * 0.1;
  camY += ((player.x + player.y)*TILE/4 - camY) * 0.1;

  drawMap();
  goblins.forEach(g=>g.draw(camX,camY));
  player.draw(camX,camY);

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
