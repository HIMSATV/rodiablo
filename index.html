
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Ronin - Expanded Monsters</title>
<style>
body { margin:0; background:black; overflow:hidden; }
canvas { display:block; image-rendering: pixelated; }
</style>
</head>
<body>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let player = {x:canvas.width/2,y:canvas.height/2,dir:0};
let enemies=[];
let corpses=[];
let particles=[];
let slashes=[];
let attacking=false;
let attackFrame=0;

// ---- Static Torches ----
let torches = [
 {x:100,y:100},
 {x:canvas.width-100,y:120},
 {x:150,y:canvas.height-150},
 {x:canvas.width-150,y:canvas.height-120},
 {x:canvas.width/2,y:80}
];

function spawnEnemy(){
 let type = Math.random() > 0.5 ? "goblin" : "skeleton";
 enemies.push({
  x:Math.random()*canvas.width,
  y:Math.random()*canvas.height,
  hp: type==="goblin"?50:35,
  type:type
 });
}
for(let i=0;i<8;i++) spawnEnemy();

canvas.addEventListener("mousedown",input);
canvas.addEventListener("touchstart",input);

function input(e){
 let x=e.touches?e.touches[0].clientX:e.clientX;
 let y=e.touches?e.touches[0].clientY:e.clientY;

 let dx=x-player.x;
 let dy=y-player.y;
 player.dir=Math.atan2(dy,dx);

 player.x=x;
 player.y=y;

 attacking=true;
 attackFrame=0;
 setTimeout(()=>attacking=false,300);
}

function spawnBlood(x,y){
 for(let i=0;i<8;i++){
  particles.push({
   x,y,
   vx:(Math.random()-0.5)*6,
   vy:(Math.random()-0.5)*6,
   life:30
  });
 }
}

function dismember(enemy){
 corpses.push({
   x:enemy.x,
   y:enemy.y,
   topOffset:0,
   bottomOffset:0,
   life:150,
   type:enemy.type
 });
}

function update(){
 if(attacking){
   attackFrame++;
   slashes.push({x:player.x,y:player.y,angle:player.dir,life:10});
 }

 enemies.forEach(enemy=>{
  let dx=player.x-enemy.x;
  let dy=player.y-enemy.y;
  let dist=Math.sqrt(dx*dx+dy*dy);

  if(dist>0){
   enemy.x+=dx/dist*(enemy.type==="goblin"?0.5:0.8);
   enemy.y+=dy/dist*(enemy.type==="goblin"?0.5:0.8);
  }

  if(attacking && dist<60 && attackFrame===2){
   enemy.hp-=50;
   spawnBlood(enemy.x,enemy.y);
   if(enemy.hp<=0) dismember(enemy);
  }
 });

 enemies=enemies.filter(e=>e.hp>0);
 if(enemies.length<8) spawnEnemy();

 particles.forEach(p=>{
  p.x+=p.vx;
  p.y+=p.vy;
  p.life--;
 });
 particles=particles.filter(p=>p.life>0);

 corpses.forEach(c=>{
  c.topOffset -= 0.3;
  c.bottomOffset += 0.3;
  c.life--;
 });
 corpses=corpses.filter(c=>c.life>0);

 slashes.forEach(s=>s.life--);
 slashes=slashes.filter(s=>s.life>0);
}

function drawPlayer(){
 ctx.fillStyle="#330000";
 ctx.fillRect(player.x-6,player.y,12,12);

 ctx.fillStyle="#660000";
 ctx.fillRect(player.x-10,player.y-12,20,14);

 ctx.fillStyle="#aa0000";
 ctx.fillRect(player.x-6,player.y-22,12,10);

 ctx.fillStyle="#ffffcc";
 ctx.fillRect(player.x-8,player.y-24,4,6);
 ctx.fillRect(player.x+4,player.y-24,4,6);

 ctx.fillStyle=attacking?"yellow":"white";
 ctx.fillRect(player.x-3,player.y-18,2,2);
 ctx.fillRect(player.x+1,player.y-18,2,2);

 if(attacking) drawKatana();
}

function drawKatana(){
 ctx.save();
 ctx.translate(player.x,player.y);
 let swing=[-1,0,1][attackFrame%3];
 ctx.rotate(player.dir+swing*0.8);
 ctx.fillStyle="#dddddd";
 ctx.fillRect(0,-2,55,4);
 ctx.fillStyle="#552200";
 ctx.fillRect(-10,-3,10,6);
 ctx.restore();
}

function drawEnemy(e){
 if(e.type==="goblin"){
   ctx.fillStyle="#004400";
   ctx.fillRect(e.x-10,e.y-10,20,20);
   ctx.fillStyle="red";
   ctx.fillRect(e.x-4,e.y-5,3,3);
   ctx.fillRect(e.x+1,e.y-5,3,3);
 } else {
   ctx.fillStyle="#cccccc";
   ctx.fillRect(e.x-8,e.y-10,16,20);
   ctx.fillStyle="#000";
   ctx.fillRect(e.x-4,e.y-4,3,3);
   ctx.fillRect(e.x+1,e.y-4,3,3);
 }
}

function draw(){
 ctx.fillStyle="#111";
 ctx.fillRect(0,0,canvas.width,canvas.height);

 enemies.forEach(drawEnemy);

 corpses.forEach(c=>{
  ctx.fillStyle= c.type==="goblin"?"#003300":"#888888";
  ctx.fillRect(c.x-10,c.y-10+c.topOffset,20,10);
  ctx.fillRect(c.x-10,c.y+c.bottomOffset,20,10);
 });

 drawPlayer();

 ctx.fillStyle="#aa0000";
 particles.forEach(p=>{
  ctx.fillRect(p.x,p.y,3,3);
 });

 slashes.forEach(s=>{
  ctx.save();
  ctx.translate(s.x,s.y);
  ctx.rotate(s.angle);
  ctx.strokeStyle="rgba(255,255,255,"+(s.life/10)+")";
  ctx.lineWidth=5;
  ctx.beginPath();
  ctx.arc(0,0,60,-0.6,0.6);
  ctx.stroke();
  ctx.restore();
 });

 // ---- Torch Lighting System ----
 let darkOverlay = ctx.createRadialGradient(player.x,player.y,50,player.x,player.y,200);
 darkOverlay.addColorStop(0,"rgba(0,0,0,0)");
 darkOverlay.addColorStop(1,"rgba(0,0,0,0.9)");
 ctx.fillStyle=darkOverlay;
 ctx.fillRect(0,0,canvas.width,canvas.height);

 torches.forEach(t=>{
   let flicker = 120 + Math.sin(Date.now()*0.01 + t.x)*15;
   let g=ctx.createRadialGradient(t.x,t.y,20,t.x,t.y,flicker);
   g.addColorStop(0,"rgba(255,140,0,0.4)");
   g.addColorStop(1,"rgba(0,0,0,0)");
   ctx.fillStyle=g;
   ctx.fillRect(0,0,canvas.width,canvas.height);

   ctx.fillStyle="orange";
   ctx.fillRect(t.x-3,t.y-10,6,10);
 });

}

function loop(){
 update();
 draw();
 requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
