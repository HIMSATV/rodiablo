<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Oni ARPG Mobile</title>
<style>
body { margin:0; overflow:hidden; background:#111; touch-action:none;}
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const TILE=64;
const MAP=25;
const ZOOM=2.2;

let inputX=0,inputY=0;
let particles=[];
let monsters=[];

// ====== ISO ======
function iso(x,y){
  return {
    x:(x-y)*TILE/2,
    y:(x+y)*TILE/4
  }
}

// ====== PLAYER ======
class Player{
  constructor(){
    this.x=0; this.y=0;
    this.dir=0;
    this.speed=0.035;
    this.attackTime=0;
    this.hp=100;
  }

  update(){
    if(inputX||inputY){
      this.dir=Math.atan2(inputY,inputX);
      this.x+=inputX*this.speed;
      this.y+=inputY*this.speed;
    }
    if(this.attackTime>0) this.attackTime--;
  }

  attack(){
    if(this.attackTime>0) return;
    this.attackTime=20;

    monsters.forEach(m=>{
      let dx=m.x-this.x;
      let dy=m.y-this.y;
      let dist=Math.hypot(dx,dy);
      let ang=Math.atan2(dy,dx);
      let diff=Math.abs(ang-this.dir);

      if(dist<1.5 && diff<0.8){
        m.hp-=20;
        for(let i=0;i<12;i++)
          particles.push(new Blood(m.x,m.y));
      }
    });
  }

  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.7,ZOOM*1.7);

    // 몸
    ctx.fillStyle="#6b0000";
    ctx.fillRect(-6,-12,12,14);

    // 투구
    ctx.fillStyle="#400000";
    ctx.fillRect(-5,-18,10,7);

    // 뿔
    ctx.fillStyle="#ddd";
    ctx.beginPath();
    ctx.moveTo(-4,-18); ctx.lineTo(-8,-25); ctx.lineTo(-2,-20); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(4,-18); ctx.lineTo(8,-25); ctx.lineTo(2,-20); ctx.fill();

    // 눈 발광
    ctx.shadowColor="yellow";
    ctx.shadowBlur=8;
    ctx.fillStyle="yellow";
    ctx.fillRect(-3,-15,2,2);
    ctx.fillRect(1,-15,2,2);
    ctx.shadowBlur=0;

    // 공격 모션
    if(this.attackTime>0){
      ctx.rotate(this.dir);
      ctx.fillStyle="#ccc";
      ctx.fillRect(0,-1,14,3);
    }

    ctx.restore();

    // HP
    ctx.fillStyle="red";
    ctx.fillRect(20,20,this.hp*2,15);
  }
}

// ====== MONSTER ======
class Monster{
  constructor(x,y){
    this.x=x; this.y=y;
    this.hp=50;
  }
  update(player){
    let dx=player.x-this.x;
    let dy=player.y-this.y;
    let dist=Math.hypot(dx,dy);
    if(dist<5){
      this.x+=dx/dist*0.02;
      this.y+=dy/dist*0.02;
    }
  }
  draw(cam){
    if(this.hp<=0) return;
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.4,ZOOM*1.4);

    ctx.fillStyle="#1e8449";
    ctx.fillRect(-5,-10,10,12);

    ctx.restore();
  }
}

// ====== BLOOD ======
class Blood{
  constructor(x,y){
    this.x=x; this.y=y;
    this.life=30;
  }
  update(){ this.life--; }
  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;
    ctx.fillStyle="darkred";
    ctx.fillRect(sx,sy,3,3);
  }
}

// ====== JOYSTICK ======
const joystick={
  baseX:canvas.width*0.2,
  baseY:canvas.height*0.8,
  radius:60,
  active:false
};

// ====== ATTACK BUTTON ======
const attackBtn={
  x:canvas.width*0.85,
  y:canvas.height*0.8,
  r:50,
  pressed:false
};

canvas.addEventListener("touchstart",e=>{
  for(let t of e.touches){
    let dx=t.clientX-joystick.baseX;
    let dy=t.clientY-joystick.baseY;
    if(Math.hypot(dx,dy)<joystick.radius){
      joystick.active=true;
    }

    let adx=t.clientX-attackBtn.x;
    let ady=t.clientY-attackBtn.y;
    if(Math.hypot(adx,ady)<attackBtn.r){
      attackBtn.pressed=true;
      player.attack();
    }
  }
});

canvas.addEventListener("touchmove",e=>{
  if(!joystick.active) return;
  let t=e.touches[0];
  let dx=t.clientX-joystick.baseX;
  let dy=t.clientY-joystick.baseY;
  let dist=Math.hypot(dx,dy);
  if(dist>joystick.radius){
    dx=dx/dist*joystick.radius;
    dy=dy/dist*joystick.radius;
  }
  inputX=dx/joystick.radius;
  inputY=dy/joystick.radius;
});

canvas.addEventListener("touchend",()=>{
  joystick.active=false;
  inputX=0; inputY=0;
  attackBtn.pressed=false;
});

// ====== INIT ======
let player=new Player();
for(let i=0;i<6;i++)
  monsters.push(new Monster(Math.random()*6-3,Math.random()*6-3));

let cam={x:0,y:0};

// ====== LOOP ======
function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update();
  monsters.forEach(m=>m.update(player));
  particles.forEach(p=>p.update());
  particles=particles.filter(p=>p.life>0);

  cam.x+=((iso(player.x,player.y).x)-cam.x)*0.1;
  cam.y+=((iso(player.x,player.y).y)-cam.y)*0.1;

  // 맵
  for(let x=-MAP;x<MAP;x++){
    for(let y=-MAP;y<MAP;y++){
      let p=iso(x,y);
      let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
      let sy=canvas.height/2+(p.y-cam.y)*ZOOM;
      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.lineTo(sx,sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.closePath();
      ctx.fillStyle=(x+y)%2==0?"#3a3a3a":"#444";
      ctx.fill();
    }
  }

  monsters.forEach(m=>m.draw(cam));
  particles.forEach(p=>p.draw(cam));
  player.draw(cam);

  // 조이스틱 그리기
  ctx.globalAlpha=0.4;
  ctx.beginPath();
  ctx.arc(joystick.baseX,joystick.baseY,joystick.radius,0,Math.PI*2);
  ctx.fillStyle="#555";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(
    joystick.baseX+inputX*joystick.radius,
    joystick.baseY+inputY*joystick.radius,
    25,0,Math.PI*2);
  ctx.fillStyle="#aaa";
  ctx.fill();

  // 공격 버튼
  ctx.globalAlpha=0.5;
  ctx.beginPath();
  ctx.arc(attackBtn.x,attackBtn.y,attackBtn.r,0,Math.PI*2);
  ctx.fillStyle=attackBtn.pressed?"#aa0000":"#880000";
  ctx.fill();

  ctx.globalAlpha=1;

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
