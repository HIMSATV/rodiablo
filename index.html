<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Oni ARPG 4Dir Slash</title>
<style>
body { margin:0; overflow:hidden; background:#111; touch-action:none;}
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
canvas.width=innerWidth;
canvas.height=innerHeight;

const TILE=64;
const MAP=25;
const ZOOM=2.2;

let inputX=0,inputY=0;
let monsters=[];
let particles=[];
let slashEffects=[];

function iso(x,y){
  return {x:(x-y)*TILE/2,y:(x+y)*TILE/4}
}

// ===== PLAYER =====
class Player{
  constructor(){
    this.x=0; this.y=0;
    this.speed=0.04;
    this.dir=0; // 0:right,1:down,2:left,3:up
    this.attackTime=0;
  }

  update(){
    if(inputX||inputY){
      this.x+=inputX*this.speed;
      this.y+=inputY*this.speed;
    }
    if(this.attackTime>0) this.attackTime--;
  }

  attack(){
    if(this.attackTime>0) return;

    // 가장 가까운 적 찾기
    let closest=null;
    let min=999;
    monsters.forEach(m=>{
      if(m.dead) return;
      let d=Math.hypot(m.x-this.x,m.y-this.y);
      if(d<min){min=d; closest=m;}
    });

    if(!closest) return;

    // 4방향 결정
    let dx=closest.x-this.x;
    let dy=closest.y-this.y;
    if(Math.abs(dx)>Math.abs(dy)){
      this.dir = dx>0?0:2;
    }else{
      this.dir = dy>0?1:3;
    }

    this.attackTime=15;

    // 광역 공격
    monsters.forEach(m=>{
      if(m.dead) return;
      let d=Math.hypot(m.x-this.x,m.y-this.y);
      if(d<2.2){
        m.hp-=50;
        for(let i=0;i<30;i++)
          particles.push(new Blood(m.x,m.y));
        if(m.hp<=0){
          m.dead=true;
          for(let i=0;i<50;i++)
            particles.push(new Blood(m.x,m.y));
        }
      }
    });

    slashEffects.push(new Slash(this.x,this.y,this.dir));
  }

  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.8,ZOOM*1.8);

    ctx.fillStyle="#6b0000";
    ctx.fillRect(-6,-12,12,14);

    ctx.fillStyle="#400000";
    ctx.fillRect(-5,-18,10,7);

    ctx.fillStyle="yellow";
    ctx.fillRect(-3,-15,2,2);
    ctx.fillRect(1,-15,2,2);

    // 칼
    if(this.attackTime>0){
      ctx.fillStyle="#ccc";
      if(this.dir===0) ctx.fillRect(8,-2,12,3);
      if(this.dir===2) ctx.fillRect(-20,-2,12,3);
      if(this.dir===1) ctx.fillRect(-2,8,3,12);
      if(this.dir===3) ctx.fillRect(-2,-20,3,12);
    }

    ctx.restore();
  }
}

// ===== MONSTER =====
class Monster{
  constructor(x,y){
    this.x=x; this.y=y;
    this.hp=60;
    this.dead=false;
  }

  update(player){
    if(this.dead) return;

    let dx=player.x-this.x;
    let dy=player.y-this.y;
    let d=Math.hypot(dx,dy);

    if(d<5){
      this.x+=dx/d*0.02;
      this.y+=dy/d*0.02;
    }

    // 겹침 방지
    monsters.forEach(m=>{
      if(m===this||m.dead) return;
      let dd=Math.hypot(this.x-m.x,this.y-m.y);
      if(dd<0.8){
        this.x+=(this.x-m.x)/dd*0.02;
        this.y+=(this.y-m.y)/dd*0.02;
      }
    });
  }

  draw(cam){
    if(this.dead) return;

    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.5,ZOOM*1.5);

    // 몸
    ctx.fillStyle="#1e8449";
    ctx.fillRect(-5,-10,10,12);

    // 눈
    ctx.fillStyle="yellow";
    ctx.fillRect(-2,-13,1,1);
    ctx.fillRect(1,-13,1,1);

    ctx.restore();
  }
}

// ===== BLOOD =====
class Blood{
  constructor(x,y){
    this.x=x; this.y=y;
    this.life=30;
    this.vx=(Math.random()-0.5)*0.3;
    this.vy=(Math.random()-0.5)*0.3;
  }
  update(){
    this.x+=this.vx;
    this.y+=this.vy;
    this.life--;
  }
  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;
    ctx.fillStyle="darkred";
    ctx.fillRect(sx,sy,3,3);
  }
}

// ===== SLASH EFFECT =====
class Slash{
  constructor(x,y,dir){
    this.x=x; this.y=y;
    this.dir=dir;
    this.life=10;
  }
  update(){ this.life--; }
  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*2,ZOOM*2);

    ctx.strokeStyle="white";
    ctx.lineWidth=3;
    ctx.beginPath();

    if(this.dir===0) ctx.arc(0,0,20,-0.5,0.5);
    if(this.dir===2) ctx.arc(0,0,20,Math.PI-0.5,Math.PI+0.5);
    if(this.dir===1) ctx.arc(0,0,20,0.5,Math.PI-0.5);
    if(this.dir===3) ctx.arc(0,0,20,-Math.PI+0.5,-0.5);

    ctx.stroke();
    ctx.restore();
  }
}

// ===== UI =====
const joystick={
  x:canvas.width*0.25,
  y:canvas.height*0.8,
  r:60
};

const attackBtn={
  x:canvas.width*0.85,
  y:canvas.height*0.8,
  r:55
};

canvas.addEventListener("touchmove",e=>{
  let t=e.touches[0];
  let dx=t.clientX-joystick.x;
  let dy=t.clientY-joystick.y;
  let d=Math.hypot(dx,dy);
  if(d<joystick.r){
    inputX=dx/joystick.r;
    inputY=dy/joystick.r;
  }
});

canvas.addEventListener("touchend",()=>{
  inputX=0; inputY=0;
});

canvas.addEventListener("touchstart",e=>{
  for(let t of e.touches){
    if(Math.hypot(t.clientX-attackBtn.x,t.clientY-attackBtn.y)<attackBtn.r){
      player.attack();
    }
  }
});

// ===== INIT =====
let player=new Player();
for(let i=0;i<10;i++)
  monsters.push(new Monster(Math.random()*6-3,Math.random()*6-3));

let cam={x:0,y:0};

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update();
  monsters.forEach(m=>m.update(player));
  particles.forEach(p=>p.update());
  slashEffects.forEach(s=>s.update());

  particles=particles.filter(p=>p.life>0);
  slashEffects=slashEffects.filter(s=>s.life>0);
  monsters=monsters.filter(m=>!m.dead);

  cam.x+=((iso(player.x,player.y).x)-cam.x)*0.1;
  cam.y+=((iso(player.x,player.y).y)-cam.y)*0.1;

  for(let x=-MAP;x<MAP;x++){
    for(let y=-MAP;y<MAP;y++){
      let p=iso(x,y);
      let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
      let sy=canvas.height/2+(p.y-cam.y)*ZOOM;
      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.lineTo(sx,sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.closePath();
      ctx.fillStyle="#333";
      ctx.fill();
    }
  }

  monsters.forEach(m=>m.draw(cam));
  particles.forEach(p=>p.draw(cam));
  slashEffects.forEach(s=>s.draw(cam));
  player.draw(cam);

  // 조이스틱 표시
  ctx.globalAlpha=0.4;
  ctx.beginPath();
  ctx.arc(joystick.x,joystick.y,joystick.r,0,Math.PI*2);
  ctx.fillStyle="#666";
  ctx.fill();

  ctx.beginPath();
  ctx.arc(joystick.x+inputX*joystick.r,
          joystick.y+inputY*joystick.r,
          25,0,Math.PI*2);
  ctx.fillStyle="#aaa";
  ctx.fill();

  // 공격 버튼
  ctx.beginPath();
  ctx.arc(attackBtn.x,attackBtn.y,attackBtn.r,0,Math.PI*2);
  ctx.fillStyle="#aa0000";
  ctx.fill();
  ctx.globalAlpha=1;

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
