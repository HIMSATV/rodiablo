<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<title>Oni Samurai</title>
<style>
:root{
  --uiScale: 1.2; /* âœ… UI 20% í™•ëŒ€ */
  /* âœ… ê¸°ê¸°ë³„ UI ìë™ ìŠ¤ì¼€ì¼ (ì•„ì´í°12ë¯¸ë‹ˆ í¬í•¨) */
--uiH: clamp(calc(84px * var(--uiScale)),  calc(16vh * var(--uiScale)),  calc(120px * var(--uiScale)));
--pad: clamp(calc(66px * var(--uiScale)),  calc(12.5vw * var(--uiScale)), calc(90px  * var(--uiScale)));
--stick:clamp(calc(28px * var(--uiScale)),  calc(5.6vw * var(--uiScale)),  calc(40px  * var(--uiScale)));
--btn: clamp(calc(70px * var(--uiScale)),  calc(13vw * var(--uiScale)),   calc(90px  * var(--uiScale)));
}

body{
  margin:0;
  background:black;
  overflow:hidden;
  touch-action:none;
}
canvas{position:fixed;top:0;left:0;image-rendering:pixelated;}

#ui{
 position:fixed;bottom:0;width:100%;height:var(--uiH);
 background:#111;border-top:3px solid #550000;
 display:flex;align-items:center;justify-content:space-between;
 padding:0 clamp(10px, 4vw, 25px);box-sizing:border-box;
}

#movePad{
  position:relative;
  width:var(--pad);height:var(--pad);
  border-radius:50%;
  background:#222;
}
#stick{
  position:absolute;
  width:var(--stick);
  height:var(--stick);
  border-radius:50%;
  background:#666;
  left: calc(50% - (var(--stick) / 2));
  top:  calc(50% - (var(--stick) / 2));
}

#attackBtn{
 position:absolute;
 right:0;
 bottom:0;
 width:var(--btn);height:var(--btn);
 border-radius:50%;
 background:#990000;border:3px solid #ff4444;
 display:flex;align-items:center;justify-content:center;
 font-size:26px;color:white;
}
#attackBtn.active{background:red;transform:scale(.85);}

#attackIcon{
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-50%);
  pointer-events:none;
}

/* ============================= */
/* âœ… (ì¶”ê°€) ê¶ê·¹ê¸° ì¤‘ì•™ ë²„íŠ¼ UI   */
/* ============================= */
/* âœ… ì˜¤ë¥¸ìª½ ë²„íŠ¼ ë¬¶ìŒ ë°•ìŠ¤ */
#btnBox{
  position:relative;
  display:flex;
  flex-direction:column;
  align-items:center;
  gap:10px;           /* ulti / attack ì‚¬ì´ ê°„ê²© */
}

/* ğŸ‘‡ ì—¬ê¸°ë¶€í„° ë¶™ì—¬ë„£ê¸° */
#rightBtns{
  position:relative;
  width:var(--btn);
  height:var(--btn);
  /* ë ˆì´ì•„ì›ƒì„ ë°€ì§€ ì•Šê²Œ */
  display:block;
  overflow:visible;
  }
/* ... (ê¸°ì¡´) ... */

/* ============================= */
/* âœ… ì•„ì´í…œ ì„ íƒ ì˜¤ë²„ë ˆì´ UI     */
/* ============================= */
#lootOverlay{
  position:fixed;
  inset:0;
  display:none;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.75);
  z-index:9999;
  font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
}
#lootPanel{
  width:min(92vw, 520px);
  background:#111;
  border:2px solid #444;
  border-radius:14px;
  padding:14px;
  box-shadow:0 0 30px rgba(0,0,0,0.6);
}
#lootTitle{
  color:#fff;
  font-weight:800;
  font-size:18px;
  margin:4px 2px 10px;
  text-align:center;
}
.lootCards{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.lootCard{
  background:#1a1a1a;
  border:2px solid #333;
  border-radius:12px;
  padding:12px;
  color:#eee;
  line-height:1.25;
}
.lootCard .name{
  font-weight:900;
  margin-bottom:6px;
}
.lootCard .desc{
  color:#cfcfcf;
  font-size:14px;
}
.lootCard button{
  margin-top:10px;
  width:100%;
  padding:10px 12px;
  border:0;
  border-radius:10px;
  background:#2d6cff;
  color:#fff;
  font-weight:800;
  font-size:15px;
}
.lootCard.common{
  border-color:#3a3a3a;
  box-shadow:0 0 8px rgba(255,255,255,0.1);
}
.lootCard.rare{
  border-color:#2f7bff;
  box-shadow:0 0 14px rgba(0,140,255,0.6);
}
.lootCard.epic{
  border-color:#b44dff;
  box-shadow:0 0 18px rgba(180,80,255,0.9);
  animation:epicGlow 1.5s infinite alternate;
}
@keyframes epicGlow{
  from{ box-shadow:0 0 10px rgba(180,80,255,0.6); }
  to{ box-shadow:0 0 25px rgba(255,120,255,1); }
}
</style>
</head>
<body>
<canvas id="game"></canvas>
<!-- âœ… ì•„ì´í…œ ì„ íƒ UI -->
<div id="lootOverlay">
  <div id="lootPanel">
    <div id="lootTitle">ì•„ì´í…œ ì„ íƒ (1ê°œë§Œ)</div>
    <div class="lootCards" id="lootCards"></div>
    <div class="lootHint">ì„ íƒí•˜ë©´ ì¦‰ì‹œ ì ìš©ë©ë‹ˆë‹¤.</div>
  </div>
</div>

<div id="ui">
  <div id="movePad"><div id="stick"></div></div>

  <div id="rightBtns">
<div id="attackBtn">
      <canvas id="attackIcon" width="60" height="60"></canvas>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const ui = document.getElementById("ui");

// âœ… drawOrbUI / drawHpOrbì—ì„œ ì“°ëŠ” ì „ì—­ uiHeight
let uiHeight = 120;

function resize(){
  uiHeight = ui.getBoundingClientRect().height || 120;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - uiHeight;
}

resize();
window.addEventListener("resize", ()=>requestAnimationFrame(resize));
requestAnimationFrame(resize);


/* ===== ì‚¬ìš´ë“œ ===== */
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let audioUnlocked = false;

function unlockAudio(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  audioCtx.resume().then(()=>{
    if(!bgmOsc) bgmOsc = startBGM();
  });
}
window.addEventListener("touchstart", unlockAudio, { once:true });
window.addEventListener("mousedown", unlockAudio, { once:true });
window.addEventListener("keydown", unlockAudio, { once:true });

function startBGM(){
  let isPlaying = true;

  function getTempo(){
    if(killCount >= 100) return 150;
    if(killCount >= 50) return 130;
    return 110;
  }

  function playBeat(){
    if(!isPlaying) return;

    let tempo = getTempo();
    let beatTime = 60 / tempo;
    let now = audioCtx.currentTime;

    // í‚¥
    let kick = audioCtx.createOscillator();
    let kickGain = audioCtx.createGain();
    kick.type = "triangle";
    kick.frequency.setValueAtTime(90, now);
    kick.frequency.exponentialRampToValueAtTime(50, now + 0.12);
    kickGain.gain.setValueAtTime(0.18, now);
    kickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    kick.connect(kickGain);
    kickGain.connect(audioCtx.destination);
    kick.start(now);
    kick.stop(now + 0.15);

    // í•˜ì´í†¤
    let tone = audioCtx.createOscillator();
    let toneGain = audioCtx.createGain();
    tone.type = "square";
    tone.frequency.value = 220;
    toneGain.gain.setValueAtTime(0.06, now + beatTime/2);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + beatTime/2 + 0.1);
    tone.connect(toneGain);
    toneGain.connect(audioCtx.destination);
    tone.start(now + beatTime/2);
    tone.stop(now + beatTime/2 + 0.1);

    setTimeout(playBeat, beatTime * 1000);
  }

  playBeat();
  return { stop: () => isPlaying = false };
}

let bgmOsc;

function swingSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="sawtooth";
  o.frequency.setValueAtTime(700,audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(200,audioCtx.currentTime+0.12);
  g.gain.value=0.15;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.12);
}
function bossUnsheatheSound(){
  let now = audioCtx.currentTime;

  let o1 = audioCtx.createOscillator();
  let g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(120, now);
  o1.frequency.exponentialRampToValueAtTime(600, now + 0.6);
  g1.gain.setValueAtTime(0.4, now);
  g1.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
  o1.connect(g1);
  g1.connect(audioCtx.destination);
  o1.start(now);
  o1.stop(now + 0.6);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(900, now);
  o2.frequency.exponentialRampToValueAtTime(200, now + 0.4);
  g2.gain.setValueAtTime(0.3, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.4);
}
function thudSound(){
  let now = audioCtx.currentTime;

  let o = audioCtx.createOscillator();
  let g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.setValueAtTime(120, now);
  o.frequency.exponentialRampToValueAtTime(55, now + 0.14);
  g.gain.setValueAtTime(0.32, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start(now);
  o.stop(now + 0.18);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(220, now);
  o2.frequency.exponentialRampToValueAtTime(90, now + 0.08);
  g2.gain.setValueAtTime(0.12, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.09);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.09);
}
 
function hitSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="square";
  o.frequency.value=100;
  g.gain.value=0.25;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.08);
}

/* ===== í”Œë ˆì´ì–´ ===== */
let player={
  x:0,y:0,
  dir:"left",
  speed:5,
  radius:14,

  hp:100,
  maxHp:100,
  baseMaxHp:100,   // âœ… ì¶”ê°€: ë ˆë²¨ì—…/ì˜êµ¬ ì¦ê°€ìš© ë² ì´ìŠ¤ ì²´ë ¥

  baseArmor:0,     // âœ… ì¶”ê°€: ê¸°ë³¸ ë°©ì–´ë ¥(ì˜êµ¬/ë ˆë²¨ì—…/ì¥ë¹„ ê¸°ë³¸ê°’)
  invul:0,
  knockbackX:0,
  knockbackY:0,

  kiOrbs:0,
  maxOrbs:5,
  levelGlow:0,
  ultiActive:false,
  ultiCount:0,
  ultiTimer:0,

  // âœ… buffs ê¸°ë³¸ê°’ì€ updateBuffsì—ì„œ ë§¤ í”„ë ˆì„ ì„¸íŒ…
  buffs: { dmgMul:1, spdMul:1, atkSpdMul:1 },
  activeBuffs: []
};

let map = [];
let mapSize = 30;
let tileSize = 48;

for(let y=0; y<mapSize; y++){
  let row = [];
  for(let x=0; x<mapSize; x++){
    if(x===0 || y===0 || x===mapSize-1 || y===mapSize-1) row.push(1);
    else row.push(0);
  }
  map.push(row);
}

player.x = mapSize * tileSize / 2;
player.y = mapSize * tileSize / 2;

let reachableMask = null; // í”Œë ˆì´ì–´ ì‹œì‘ì ì—ì„œ ë„ë‹¬ ê°€ëŠ¥í•œ ë°”ë‹¥ íƒ€ì¼ í‘œì‹œ
let hpWaveOffset = 0;
let slowMotion = 0;
let spawnTimer = 0;
let spawnInterval = 90;
let enemies=[];
let packs = [];
/* ============================= */
/* âœ… ì•„ì´í…œ ë“œë/ì„ íƒ ì‹œìŠ¤í…œ     */
/* ============================= */
let loots = [];            // ë°”ë‹¥ì— ë–¨ì–´ì§„ ë£¨íŠ¸
let lootOverlayOpen = false;
let pendingLoot = null;    // í˜„ì¬ ì„ íƒ UIì— ë„ìš´ ë£¨íŠ¸

const lootOverlay = document.getElementById("lootOverlay");
const lootCardsEl = document.getElementById("lootCards");

// âœ… ë“œë í…Œì´ë¸”(ì›í•˜ë©´ ì—¬ê¸° ê³„ì† ì¶”ê°€í•˜ë©´ ë¨)
const ITEM_POOL = [

  {
    id:"dmg_up",
    name:"ê°•í™”ëœ ì¼ê²©",
    rarity:"common",
    type:"damage",
    descGen:(v)=>`í‰íƒ€ ë°ë¯¸ì§€ +${v}%`,
    scale(){
      const value = Math.floor(8 + level * 1.2 + mapTier * 1.5);
      return { percent:value };
    },
    apply(data){
      // âœ… ì˜êµ¬: gearì— ëˆ„ì (ê³±)
      applyGearDelta({ dmgMul: 1 + (data.percent/100) });
    }
  },

  {
    id:"ulti_up",
    name:"í­ë°œ ê°•í™”",
    rarity:"common",
    type:"ulti",
    descGen:(v)=>`ê¶ê·¹ê¸° ë°ë¯¸ì§€ +${v}%`,
    scale(){
      const value = Math.floor(12 + level * 1.5 + mapTier * 2);
      return { percent:value };
    },
    apply(data){
      applyGearDelta({ ultiMul: 1 + (data.percent/100) });
    }
  },

  {
    id:"hp",
    name:"ìƒëª…ì˜ ì •ìˆ˜",
    rarity:"rare",
    type:"hp",
    descGen:(v)=>`ìµœëŒ€ ì²´ë ¥ +${v}`,
    scale(){
      const value = Math.floor(15 + level*3 + mapTier*4);
      return { flat:value };
    },
    apply(data){
      applyGearDelta({ maxHpAdd: data.flat });
      player.hp += data.flat;
    }
  },

  {
    id:"armor",
    name:"ì² ë²½ ê°‘ì˜·",
    rarity:"rare",
    type:"armor",
    descGen:(v)=>`ë°©ì–´ë ¥ +${v}`,
    scale(){
      const value = Math.floor(5 + mapTier*2);
      return { flat:value };
    },
    apply(data){
      applyGearDelta({ armorAdd: data.flat });
    }
  }
];
const PREFIXES = [
  { name:"ë§¹ë ¬í•œ", mod:(data)=>{ data.percent += 10; } },
  { name:"ê´‘í­í•œ", mod:(data)=>{ data.percent += 15; } },
  { name:"ê²¬ê³ í•œ", mod:(data)=>{ data.flat += 8; } }
];

const SUFFIXES = [
  { name:"ì˜ ë¶„ë…¸", mod:(data)=>{ data.percent += 5; } },
  { name:"ì˜ ê±°ì¸", mod:(data)=>{ data.flat += 10; } }
];
// =============================
// âœ… ì „ì„¤ ì•„ì´í…œ(ê³ ìœ íš¨ê³¼)
// =============================
const LEGENDARY_POOL = [
  {
    id:"unique_thunderstep",
    name:"ì²œë‘¥ê±¸ìŒ (Thunderstep)",
    rarity:"legendary",
    desc:"ì  ì²˜ì¹˜ ì‹œ ë²ˆê°œê°€ ì£¼ë³€ìœ¼ë¡œ ì—°ì‡„ (ì¿¨ 0.8ì´ˆ)",
    apply(){
      // ìŠ¤íƒ¯ë„ ì¡°ê¸ˆ
      baseDamage *= 1.10;
    },
    onEvent(type, p){
      if(type !== "kill") return;

      const now = frameCount;
      const key = this.id + "_cd";
      const cd = uniqueState[key] ?? 0;
      if(now < cd) return;
      uniqueState[key] = now + 48; // 0.8ì´ˆ(60fps ê¸°ì¤€)

      // ì£¼ë³€ ì²´ì¸ ë²ˆê°œ: ì£½ì¸ ìœ„ì¹˜ ì¤‘ì‹¬ìœ¼ë¡œ ë°˜ê²½ ë‚´ 4ë§ˆë¦¬
      const cx = p.x, cy = p.y;
      let hits = 0;
      for(const e of enemies){
        if(e.hp <= 0) continue;
        if(e.type === "boss" && e.dead) continue;

        const dx = e.x - cx, dy = e.y - cy;
        if(dx*dx + dy*dy > 200*200) continue;

        e.hp -= baseDamage * 0.65;
        spawnHitBlood(e.x, e.y, 8);

        // ë²ˆê°œ ì´í™íŠ¸ ëŠë‚Œ íŒŒí‹°í´
        if(particles.length < 260){
          for(let i=0;i<6;i++){
            particles.push({ x:e.x, y:e.y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:18 });
          }
        }

        hits++;
        if(hits >= 4) break;
      }

      pruneDeadEnemies();
    }
  },

  {
    id:"unique_oni_aegis",
    name:"ì˜¤ë‹ˆì˜ ìˆ˜í˜¸ (Oni Aegis)",
    rarity:"legendary",
    desc:"í”¼ê²© ì‹œ ë³´í˜¸ë§‰ 1íšŒ ìƒì„± (í”¼í•´ 35% ê°ì†Œ, 2ì´ˆ ì§€ì†, ì¿¨ 6ì´ˆ)",
    apply(){
      player.baseArmor += 4;
      player.baseMaxHp += 20;
      player.hp += 20;
    },
    onEvent(type, p){
      if(type !== "takeDamage") return;

      const now = frameCount;
      const cdKey = this.id + "_cd";
      if((uniqueState[cdKey] ?? 0) > now) return;

      // ë³´í˜¸ë§‰ ë²„í”„ ë¶€ì—¬ (2ì´ˆ)
      // í”¼í•´ê°ì†ŒëŠ” damagePlayer ë‚´ë¶€ì—ì„œ "buffs.damageTakenMul" ê°™ì€ ê²Œ ì—†ìœ¼ë‹ˆ
      // ì—¬ê¸°ì„œëŠ” armorë¥¼ í¬ê²Œ ì˜¬ë¦¬ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬í˜„(ê°„ë‹¨/ì•ˆì „)
      applyBuff(player, "armor", 30, 120, "oni_aegis", "add");
      uniqueState[cdKey] = now + 360; // 6ì´ˆ ì¿¨

      // ì‹œê° ì—°ì¶œ
      shake = Math.max(shake, 12);
      for(let i=0;i<22;i++){
        particles.push({ x:player.x, y:player.y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:22 });
      }
    }
  },

  {
    id:"unique_bloodkatana",
    name:"í˜ˆê·€ì˜ ë„ (Blood Katana)",
    rarity:"legendary",
    desc:"íƒ€ê²© ì‹œ 20% í™•ë¥ ë¡œ ì¶œí˜ˆ ì¥íŒ ìƒì„±(3ì´ˆ). ì¥íŒì€ ì´ˆë‹¹ í”¼í•´ + í¡í˜ˆ",
    apply(){
      baseDamage *= 1.08;
    },
    onEvent(type, p){
      if(type !== "hit") return;
      if(Math.random() > 0.20) return;

      const x = p.enemy.x;
      const y = p.enemy.y;

      // fireZonesë¥¼ ì¬í™œìš©í•˜ë˜, ë¹¨ê°„ ì¥íŒì„ ë³„ë„ ë°°ì—´ë¡œ ë‘ëŠ” ê²Œ ë” ê¹”ë”
      // ì—¬ê¸°ì„  ìµœì†Œì¹¨ìŠµ: fireZonesì— damageë¥¼ ë‚®ê²Œ ë„£ê³ , tickì—ì„œ í¡í˜ˆ ì²˜ë¦¬ë§Œ ì¶”ê°€í•˜ì
      fireZones.push({ x, y, radius:60, life:180, tick:0, damage: Math.max(2, baseDamage*0.18), isBleed:true });
    }
  }
];
function pickUnique(list, n){
  const out = [];
  const copy = list.slice();
  while(out.length < n && copy.length){
    const idx = (Math.random() * copy.length) | 0;
    out.push(copy.splice(idx,1)[0]);
  }
  return out;
}

// âœ… ì»¤ë¨¼: ì ‘ë‘/ì ‘ë¯¸ 1ì¤„(ë‘˜ ì¤‘ í•˜ë‚˜ë§Œ)
// âœ… ë ˆì–´: ì ‘ë‘ 1ì¤„ + ì ‘ë¯¸ 1ì¤„
// âœ… ì—í”½: ì ‘ë‘ 1ì¤„ + ì ‘ë¯¸ 1ì¤„ + (ì ‘ë‘ ë˜ëŠ” ì ‘ë¯¸) 1ì¤„  => ì´ 3ì¤„
function rollAffixesByRarity(baseItem, rarity){
  let data = baseItem.scale();
  let prefixes = [];
  let suffixes = [];

  if(rarity === "common"){
    if(Math.random() < 0.5){
      prefixes = pickUnique(PREFIXES, 1);
    }else{
      suffixes = pickUnique(SUFFIXES, 1);
    }
  }else if(rarity === "rare"){
    prefixes = pickUnique(PREFIXES, 1);
    suffixes = pickUnique(SUFFIXES, 1);
  }else if(rarity === "epic"){
    // ê¸°ë³¸ 2ì¤„
    prefixes = pickUnique(PREFIXES, 1);
    suffixes = pickUnique(SUFFIXES, 1);

    // ì¶”ê°€ 1ì¤„(ì ‘ë‘ or ì ‘ë¯¸)
    if(Math.random() < 0.5){
      // ì ‘ë‘ 1ê°œ ë”(ì¤‘ë³µ ë°©ì§€)
      const cand = PREFIXES.filter(p => !prefixes.includes(p));
      if(cand.length) prefixes.push(pickUnique(cand, 1)[0]);
    }else{
      // ì ‘ë¯¸ 1ê°œ ë”(ì¤‘ë³µ ë°©ì§€)
      const cand = SUFFIXES.filter(s => !suffixes.includes(s));
      if(cand.length) suffixes.push(pickUnique(cand, 1)[0]);
    }
  }else{
    // legendaryëŠ” ì—¬ê¸°ì„œ ì•ˆ êµ´ë¦¼
  }

  // mod ì ìš©(ëˆ„ì )
  for(const p of prefixes) p.mod(data);
  for(const s of suffixes) s.mod(data);

  // ì´ë¦„ êµ¬ì„±(ì ‘ë‘ ì—¬ëŸ¬ ê°œë©´ ê³µë°±ìœ¼ë¡œ ì´ì–´ë¶™ì„, ì ‘ë¯¸ëŠ” ê¸°ì¡´ì²˜ëŸ¼ ë’¤ì— ë¶™ì„)
  const preName = prefixes.map(p=>p.name).join(" ");
  const sufName = suffixes.map(s=>s.name).join("");

  let name = baseItem.name;
  if(preName) name = preName + " " + name;
  if(sufName) name = name + sufName;

  return { name, data, prefixes, suffixes };
}

// âœ… í™•ë¥  (ì›í•˜ë©´ ì¡°ì ˆ)
function rollRarity(){
  const t = mapTier;

  // âœ… ì „ì„¤ í™•ë¥ : í‹°ì–´ ì˜¬ë¼ê°ˆìˆ˜ë¡ ì•„ì£¼ ì¡°ê¸ˆ ì¦ê°€ (ìµœëŒ€ 2.5%)
  const legendary = clamp(0.004 + (t-1)*0.0003, 0.004, 0.025);

  const epic = clamp(0.03 + (t-1)*0.002, 0.03, 0.08);
  const rare = clamp(0.18 + (t-1)*0.004, 0.18, 0.32);

  const r = Math.random();
  if(r < legendary) return "legendary";
  if(r < legendary + epic) return "epic";
  if(r < legendary + epic + rare) return "rare";
  return "common";
}

function pickItemsForChoice(count=3){
  const rarity = rollRarity();

  // âœ… ì „ì„¤ì´ë©´ ì „ì„¤ í’€ì—ì„œë§Œ 1~3ê°œ ë½‘ê¸°
  if(rarity === "legendary"){
    const picks = [];
    let guard = 0;
    while(picks.length < count && guard++ < 200){
      const it = LEGENDARY_POOL[(Math.random()*LEGENDARY_POOL.length)|0];
      if(!it) continue;
      if(picks.some(p=>p.id===it.id)) continue;
      picks.push(it);
    }
    return picks;
  }

  // ê¸°ì¡´ ë¡œì§ ìœ ì§€
  const candidates = ITEM_POOL.filter(it => it.rarity === rarity);
  const fallback = ITEM_POOL;

  let picks = [];
  let guard = 0;
  while(picks.length < count && guard++ < 200){
    const src = (Math.random() < 0.85 ? candidates : fallback);
    const it = src[(Math.random()*src.length)|0];
    if(!it) continue;
    if(picks.some(p=>p.id===it.id)) continue;
    picks.push(it);
  }
  while(picks.length < count){
    const it = fallback[(Math.random()*fallback.length)|0];
    if(!picks.some(p=>p.id===it.id)) picks.push(it);
  }
  return picks;
}

// âœ… ëª¹ ì£½ì„ ë•Œ ë“œë ìƒì„±
function spawnLoot(x, y, source="mob"){
  // ë„ˆë¬´ ë§ì´ ìŒ“ì´ë©´ ì •ë¦¬
  if(loots.length > 25) loots.splice(0, loots.length-25);

  const choices = pickItemsForChoice(3);
  loots.push({
    x, y,
    r: 14,
    ttl: 60*45,     // 45ì´ˆ í›„ ì‚¬ë¼ì§
    choices,
    taken: false,
    source
  });
}

// âœ… í”Œë ˆì´ì–´ ê·¼ì²˜ì—ì„œ "ì¤ê¸°" ê°€ëŠ¥ ë£¨íŠ¸ ì°¾ê¸°
function getNearbyLoot(){
  for(const L of loots){
    if(L.taken) continue;
    const dx = L.x - player.x;
    const dy = L.y - player.y;
    const rr = (L.r + player.radius + 18);
    if(dx*dx + dy*dy <= rr*rr) return L;
  }
  return null;
}

// âœ… ì„ íƒ UI ì—´ê¸°
function openLootChoice(L){
  if(!L || L.taken) return;
  lootOverlayOpen = true;
  pendingLoot = L;

  // ê²Œì„ ë©ˆì¶¤ ëŠë‚Œ(ì—…ë°ì´íŠ¸ì—ì„œ early return)
  lootOverlay.style.display = "flex";
  lootCardsEl.innerHTML = "";

    L.choices.forEach((it)=>{
    const card = document.createElement("div");
    card.className = `lootCard ${it.rarity}`;

    // âœ… í‘œì‹œìš© í”„ë¦¬ë·°(í‘œì‹œëœ ê°’ì´ ê·¸ëŒ€ë¡œ ì ìš©ë˜ê²Œ ê³ ì •)
    const preview = (it.rarity === "legendary") ? null : rollAffixesByRarity(it, it.rarity);

    const shownName = (it.rarity === "legendary") ? it.name : preview.name;
    const shownDesc = (it.rarity === "legendary")
      ? it.desc
      : it.descGen(preview.data.percent ?? preview.data.flat);

    card.innerHTML = `
      <div class="name">[${it.rarity.toUpperCase()}] ${shownName}</div>
      <div class="desc">${shownDesc}</div>
      <button type="button">ì´ê±¸ ì„ íƒ</button>
    `;

    card.querySelector("button").addEventListener("click", ()=>{
      if(it.rarity === "legendary"){
        it.apply();
        ownedItems.push(it.name);
        ownedUniques.push(it);
      }else{
        it.apply(preview.data);     // âœ… í‘œì‹œëœ ë°ì´í„° ê·¸ëŒ€ë¡œ ì ìš©
        ownedItems.push(preview.name);
      }

      // âœ… gear/ë²„í”„/íŒŒìƒ ìŠ¤íƒ¯ ë™ê¸°í™”
      recalcFromGear();

      L.taken = true;
      closeLootChoice();
      shake = Math.max(shake, 10);
    });

    lootCardsEl.appendChild(card);
  });
}

function closeLootChoice(){
  lootOverlayOpen = false;
  pendingLoot = null;
  lootOverlay.style.display = "none";
}

// âœ… ë£¨íŠ¸ ì—…ë°ì´íŠ¸/ê·¸ë¦¬ê¸°
function updateLoots(){
  for(let i=loots.length-1;i>=0;i--){
    const L = loots[i];
    if(L.taken){ loots.splice(i,1); continue; }
    L.ttl--;
    if(L.ttl <= 0) loots.splice(i,1);
  }
}

function drawLoots(){
  if(loots.length === 0) return;

  ctx.save();
  for(const L of loots){
    if(L.taken) continue;

    // ë¹›ë‚˜ëŠ” ë“œë
    const pulse = 0.5 + 0.5*Math.sin(frameCount*0.15);
    ctx.globalAlpha = 0.75 + pulse*0.25;

    // ë°”ê¹¥ ê¸€ë¡œìš°
    ctx.fillStyle = "rgba(80,140,255,0.25)";
    ctx.beginPath();
    ctx.arc(L.x, L.y, L.r + 10 + pulse*6, 0, Math.PI*2);
    ctx.fill();

    // ë³¸ì²´
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(40,120,255,0.9)";
    ctx.beginPath();
    ctx.arc(L.x, L.y, L.r, 0, Math.PI*2);
    ctx.fill();

    // "!" í‘œì‹œ
    ctx.globalAlpha = 1;
    ctx.fillStyle = "#fff";
    ctx.font = "bold 16px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("!", L.x, L.y+1);
  }
  ctx.restore();
}
let ownedItems = [];
// =============================
// âœ… ì „ì„¤(Unique) ì´ë²¤íŠ¸ ì‹œìŠ¤í…œ
// =============================
let ownedUniques = [];   // { id, name, rarity:"legendary", ... }
let uniqueState = {};    // ì „ì„¤ë³„ ë‚´ë¶€ ì¿¨ë‹¤ìš´/ìŠ¤íƒ ì €ì¥ìš©

function emitEvent(type, payload){
  for(const u of ownedUniques){
    if(u.onEvent) u.onEvent(type, payload);
  }
}
let orbUIState = { cx:0, cy:0, centerR:24, ready:false };
let particles=[];
let bloodPools=[];
let shake=0;
let xp = 0;
let xpToNext = 120;
let level = 1;
let gameOver = false;
let orbFlash = 0;
let flashEffect = 0;
/* ============================= */
/* âœ… POEì‹ ì˜êµ¬ ì•„ì´í…œ(gear) ì„¤ê³„ */
/* ============================= */

// âœ… â€œë ˆë²¨ì—…/ê¸°ë³¸ ì„±ì¥â€ì€ Baseì—ë§Œ ëˆ„ì 
let baseDamageBase = 20;
let ultiDamageBase = 40;

// âœ… ì‹¤ì œ ì „íˆ¬ì—ì„œ ì“°ëŠ” ê°’(í•­ìƒ ì¬ê³„ì‚°ë¨)
let baseDamage = baseDamageBase;
let ultiDamage = ultiDamageBase;

// âœ… í”Œë ˆì´ì–´ ì˜êµ¬ ì¥ë¹„ ìŠ¤íƒ¯(ì•„ì´í…œìœ¼ë¡œë§Œ ëˆ„ì )
// - ê³µê²© ë²”ìœ„ëŠ” rangeMulë§Œ ì‚¬ìš©
player.gear = {
  dmgMul: 1,        // í‰íƒ€ ë°ë¯¸ì§€ ë°°ìˆ˜
  ultiMul: 1,       // ê¶ê·¹ê¸° ë°ë¯¸ì§€ ë°°ìˆ˜
  spdMul: 1,        // ì´ë™ì†ë„ ë°°ìˆ˜(ì›í•˜ë©´)
  atkSpdMul: 1,     // ê³µì† ë°°ìˆ˜(ì›í•˜ë©´)
  rangeMul: 1,      // âœ… ê³µê²©ë²”ìœ„(í‰íƒ€/ê¶ê·¹ê¸° ëª¨ë‘) ë‹¨ì¼ í‚¤
  armorAdd: 0,      // ë°©ì–´ë ¥ ê°€ì‚°
  maxHpAdd: 0,      // ìµœëŒ€ì²´ë ¥ ê°€ì‚°
  hpRegen: 0        // ì´ˆë‹¹ ì¬ìƒ ê°€ì‚°
};

// âœ… gear ë³€ê²½/ë ˆë²¨ì—… í›„ í•­ìƒ ì´ê±¸ í˜¸ì¶œí•´ì„œ â€œíŒŒìƒ ìŠ¤íƒ¯â€ ì¬ê³„ì‚°
function recalcFromGear(){
  baseDamage = baseDamageBase * (player.gear.dmgMul ?? 1);
  ultiDamage = ultiDamageBase * (player.gear.ultiMul ?? 1);

  // maxHp/armorëŠ” updateBuffs(player)ì—ì„œ ìµœì¢… ë°˜ì˜ë˜ì§€ë§Œ,
  // gearëŠ” updateBuffsì— ì„ì´ë„ë¡ ì•„ë˜ updateBuffs ìˆ˜ì •ë„ ê°™ì´ í•´ì¤˜ì•¼ í•¨.
  updateBuffs(player);
  player.hp = Math.min(player.maxHp, player.hp);
}

// âœ… gearì— ê°’ì„ ì ìš©(í•œ ë²ˆ ë¨¹ì€ ì•„ì´í…œì€ ì—¬ê¸°ë¡œë§Œ ëˆ„ì )
function applyGearDelta(delta){
  // delta ì˜ˆ: { dmgMul:1.12 } ë˜ëŠ” { armorAdd:5 } ë˜ëŠ” { rangeMul:1.10 }
  for(const k in delta){
    const v = delta[k];
    if(typeof v !== "number") continue;

    // Mul ê³„ì—´ì€ ê³±, Add ê³„ì—´ì€ ë”í•˜ê¸°
    if(k.endsWith("Mul") || k === "rangeMul"){
      player.gear[k] = (player.gear[k] ?? 1) * v;
    }else{
      player.gear[k] = (player.gear[k] ?? 0) + v;
    }
  }

  recalcFromGear();
}
let levelParticles = [];
let arrows = [];
let bloodParticles = [];
let fireZones = [];
let frameCount = 0;
  // âœ… (ì¶”ê°€) ëˆ„ë½ë˜ë©´ ê²Œì„ì´ ë©ˆì¶œ ìˆ˜ ìˆëŠ” ì „ì—­ë“¤
let killCount = 0;
let killsAtLevelStart = 0;
let killsForNextLevel = 20;
let explosionActive = false;
let bossSpawned = false;
let bossTimer = 0;
let bossInterval = 45 * 60;
/* ===== ë§µí•‘(POE ìŠ¤íƒ€ì¼) ì „ì—­ ===== */
/* ===== ë§µ í‹°ì–´(POE ìŠ¤íƒ€ì¼) ===== */
let mapTier = 1;
let mapSeed = 0; // ë§µ ë°”ë€” ë•Œë§ˆë‹¤ ë°”ë€ŒëŠ” ëœë¤ ì‹œë“œ ëŠë‚Œìš©(ì„ íƒ)
let mapRun = {
  tier: 1,
  seed: 0,
  packsToClear: 10,     // ë³´ìŠ¤ ì—´ë¦¬ëŠ” ê¸°ì¤€ íŒ© ìˆ˜
  clearedPacks: 0,
  bossSpawned: false,
  bossDefeated: false,
};

let portal = {
  active: false,
  x: 0,
  y: 0,
  r: 32,
  hold: 0,           // í¬íƒˆ ì§„ì… ëŒ€ê¸°(ìë™ ì§„ì… ë°©ì§€ìš©)
  holdNeed: 25       // 25í”„ë ˆì„ ì •ë„ ì„œìˆìœ¼ë©´ ì§„ì…
};
let bossRoom = { x:0, y:0, w:0, h:0, cx:0, cy:0, doorX:0, doorY:0 };
/* ===== ì…ë ¥ ===== */
let joyDX=0, joyDY=0;
let attacking=false;
let attackFrame=0;
let keys = {};

window.addEventListener("keydown", e=>{ keys[e.key] = true; });
window.addEventListener("keyup", e=>{ keys[e.key] = false; });

const pad = document.getElementById("movePad");
const stick = document.getElementById("stick");
const attackBtn = document.getElementById("attackBtn");
// âœ… (ì¶”ê°€)
let joyActive=false;

function bossDeathSound(){
  let now = audioCtx.currentTime;

  let o1 = audioCtx.createOscillator();
  let g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(220, now);
  o1.frequency.exponentialRampToValueAtTime(45, now + 0.6);
  g1.gain.setValueAtTime(0.25, now);
  g1.gain.exponentialRampToValueAtTime(0.001, now + 0.65);
  o1.connect(g1); g1.connect(audioCtx.destination);
  o1.start(now); o1.stop(now + 0.65);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "square";
  o2.frequency.setValueAtTime(900, now + 0.05);
  o2.frequency.exponentialRampToValueAtTime(180, now + 0.18);
  g2.gain.setValueAtTime(0.12, now + 0.05);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.22);
  o2.connect(g2); g2.connect(audioCtx.destination);
  o2.start(now + 0.05); o2.stop(now + 0.22);
}

function setStickByVector(vx, vy){
  const r = pad.getBoundingClientRect();
  const max = Math.min(r.width, r.height) * 0.33; // âœ… íŒ¨ë“œ í¬ê¸° ê¸°ë°˜
  let d = Math.hypot(vx, vy) || 1;
  if(d > max){ vx *= max/d; vy *= max/d; }

  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;

  stick.style.left = (r.width/2 - sw/2 + vx) + "px";
  stick.style.top  = (r.height/2 - sh/2 + vy) + "px";

  joyDX = vx / max;
  joyDY = vy / max;

  if(Math.abs(vx) > Math.abs(vy))
    player.dir = vx > 0 ? "right" : "left";
  else
    player.dir = vy > 0 ? "down" : "up";
}

function handlePadMove(clientX, clientY){
  const r = pad.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top + r.height/2;
  const vx = clientX - cx;
  const vy = clientY - cy;
  setStickByVector(vx, vy);
}

pad.addEventListener("touchstart", (e)=>{
  joyActive = true;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchmove", (e)=>{
  if(!joyActive) return;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchend", ()=>{
  joyActive=false; joyDX=joyDY=0;
  const r = pad.getBoundingClientRect();
  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;
  stick.style.left = (r.width/2 - sw/2) + "px";
  stick.style.top  = (r.height/2 - sh/2) + "px";
});

/* ========================================= */
/* âœ… (ìˆ˜ì •) attackBtn = í‰íƒ€ë§Œ ë™ì‘í•˜ë„ë¡     */
/* ========================================= */
attackBtn.addEventListener("touchstart", ()=>{
  // âœ… í‰íƒ€ë§Œ
  attacking = true;
  attackFrame = 0;
  swingSound();
  attackBtn.classList.add("active");
},{passive:true});

attackBtn.addEventListener("touchend", ()=>{
  attackBtn.classList.remove("active");
},{passive:true});

/* ========================================= */


/* ===== ìœ í‹¸ ===== */

// âœ… í™•ì¥ ê°€ëŠ¥í•œ ê¸°ë³¸ ë²„í”„ ìŠ¤íƒ¯
function defaultBuffStats(){
  return {
    // ê³µê²©ê³„
    dmgMul: 1,
    spdMul: 1,
    atkSpdMul: 1,

    // ë²”ìœ„ê³„ (ê³µìš© + ìŠ¤í‚¬ë³„)
    rangeMul: 1,        // í‰íƒ€/ê¶ê·¹ê¸° ëª¨ë‘ì— ì ìš©ë˜ëŠ” "ê³µìš© ë²”ìœ„"
    meleeRangeMul: 1,   // í‰íƒ€ ì „ìš©
    aoeMul: 1,          // ê´‘ì—­(í­ë°œ/ì¥íŒ ë“±) ê³µìš©
    ultiAoeMul: 1,      // ê¶ê·¹ê¸° í­íŒŒ ì „ìš©

    // ë°©ì–´ê³„
    armorAdd: 0,        // âœ… ë°©ì–´ë ¥(ê°€ì‚°)
    armorMul: 1,        // âœ… ë°©ì–´ë ¥(ë°°ìˆ˜) - í•„ìš” ì—†ìœ¼ë©´ ì•ˆ ì¨ë„ ë¨
    maxHpMul: 1,        // âœ… ìµœëŒ€ì²´ë ¥ ë°°ìˆ˜
    maxHpAdd: 0,        // âœ… ìµœëŒ€ì²´ë ¥ ê°€ì‚°
    hpRegen: 0          // âœ… ì´ˆë‹¹ ì²´ë ¥ ì¬ìƒ(ê°€ì‚°)
  };
}

/**
 * applyBuff(target, type, value, duration, source="", mode="mul")
 * - mode: "mul" ë˜ëŠ” "add"
 * - ê¸°ì¡´ ì½”ë“œ(leader ì˜¤ë¼)ì˜ "damage / atkSpeed / speed" í˜¸ì¶œë„ ê·¸ëŒ€ë¡œ ë™ì‘í•˜ê²Œ ë§µí•‘ë¨
 */
function applyBuff(target, type, value, duration, source="", mode="mul"){
  if(!target.activeBuffs) target.activeBuffs = [];

  const key = type + "|" + source + "|" + mode;
  const b = target.activeBuffs.find(x => x.key === key);

  if(b){
    b.value = value;
    b.duration = Math.max(b.duration, duration);
  }else{
    target.activeBuffs.push({ key, type, value, duration, mode });
  }
}

// âœ… íƒ€ì…ëª…ì„ buffs í‚¤ë¡œ ë§¤í•‘(í˜¸í™˜ + í™•ì¥)
function mapBuffTypeToStat(type){
  // ê¸°ì¡´ í˜¸í™˜
  if(type === "damage")   return "dmgMul";
  if(type === "speed")    return "spdMul";
  if(type === "atkSpeed") return "atkSpdMul";

  // ì‹ ê·œ(ì•„ì´í…œ/ë²„í”„ìš©)
  if(type === "range")        return "rangeMul";        // ê³µìš© ë²”ìœ„
  if(type === "meleeRange")   return "meleeRangeMul";   // í‰íƒ€ ë²”ìœ„
  if(type === "aoe")          return "aoeMul";          // ê´‘ì—­ ë²”ìœ„ ê³µìš©
  if(type === "ultiAoe")      return "ultiAoeMul";      // ê¶ê·¹ê¸° í­íŒŒ

  if(type === "armor")        return "armorAdd";        // ë°©ì–´ë ¥(ê¸°ë³¸ì€ addë¡œ ì“°ëŠ” ê±¸ ì¶”ì²œ)
  if(type === "armorMul")     return "armorMul";
  if(type === "maxHpMul")     return "maxHpMul";
  if(type === "maxHp")        return "maxHpAdd";
  if(type === "hpRegen")      return "hpRegen";

  return null;
}

function updateBuffs(target){
  if(!target.activeBuffs) target.activeBuffs = [];

  // ê¸°ë³¸ê°’
  target.buffs = defaultBuffStats();

  // âœ… (ì¶”ê°€) ì˜êµ¬ gearë¥¼ â€œê¸°ë³¸ ë²„í”„â€ì— ë¨¼ì € í•©ì„±
  // - í”Œë ˆì´ì–´ë§Œ gearë¥¼ ì”€(ì ì€ ì•ˆ ì”€)
  if(target === player && target.gear){
    const g = target.gear;

    // mul
    target.buffs.dmgMul     *= (g.dmgMul     ?? 1);
    target.buffs.spdMul     *= (g.spdMul     ?? 1);
    target.buffs.atkSpdMul  *= (g.atkSpdMul  ?? 1);
    target.buffs.rangeMul   *= (g.rangeMul   ?? 1);

    // add
    target.buffs.armorAdd   += (g.armorAdd   ?? 0);
    target.buffs.maxHpAdd   += (g.maxHpAdd   ?? 0);
    target.buffs.hpRegen    += (g.hpRegen    ?? 0);
  }

  // âœ… ì„ì‹œ ë²„í”„ë“¤ ì²˜ë¦¬
  for(let i = target.activeBuffs.length - 1; i >= 0; i--){
    const b = target.activeBuffs[i];
    b.duration--;

    if(b.duration <= 0){
      target.activeBuffs.splice(i,1);
      continue;
    }

    const stat = mapBuffTypeToStat(b.type);
    if(!stat) continue;

    if(b.mode === "mul"){
      if(target.buffs[stat] !== undefined) target.buffs[stat] *= b.value;
    }else if(b.mode === "add"){
      if(target.buffs[stat] !== undefined) target.buffs[stat] += b.value;
    }
  }

  // âœ… ìµœì¢… maxHp/armor ë°˜ì˜
  if(target === player){
    const b = target.buffs;

    const newMax = Math.max(1, Math.floor(target.baseMaxHp * (b.maxHpMul ?? 1) + (b.maxHpAdd ?? 0)));
    target.maxHp = newMax;

    if(target.hp > target.maxHp) target.hp = target.maxHp;

    target.armor = Math.max(0, (target.baseArmor + (b.armorAdd ?? 0)) * (b.armorMul ?? 1));
  }
}
  function pruneDeadEnemies(){
  // ì¼ë°˜ ì : hp > 0ë§Œ ìœ ì§€
  // ë³´ìŠ¤: dead ì—°ì¶œ ì¤‘ì´ë©´ deathTimer ë‚¨ì•„ìˆì„ ë•Œë§Œ ìœ ì§€
  enemies = enemies.filter(e =>
    (e.hp > 0) ||
    (e.type === "boss" && e.dead && e.deathTimer > 0)
  );

  // íŒ© ë°°ì—´ë„ ê°™ì´ ì •ë¦¬
  for(const p of packs){
    p.enemies = p.enemies.filter(e => e.hp > 0 || (e.type==="boss" && e.dead && e.deathTimer > 0));
  }
}
function getRandomVisibleAliveEnemy(){
  // ì‚´ì•„ìˆê³ , (ë³´ìŠ¤ dead ì œì™¸), í™”ë©´ì— ë³´ì´ëŠ” ì ë§Œ
  const visible = enemies.filter(e =>
    e.hp > 0 &&
    !(e.type === "boss" && e.dead) &&
    isEnemyOnScreen(e)
  );
  if(visible.length === 0) return null;
  return visible[(Math.random() * visible.length) | 0];
}
function getRandomAliveEnemy(){
  // ì‚´ì•„ìˆëŠ” ì ë§Œ ëŒ€ìƒìœ¼ë¡œ (ë³´ìŠ¤ dead ì œì™¸)
  const alive = enemies.filter(e => e.hp > 0 && !(e.type === "boss" && e.dead));
  if(alive.length === 0) return null;
  return alive[(Math.random() * alive.length) | 0];
}
function getLevelPenalty(playerLv, monsterLv){
  const diff = monsterLv - playerLv;

  if(diff >= 0) return 1 + diff * 0.04;   // ë†’ì€ ëª¬ìŠ¤í„°ëŠ” +4%ì”©
  if(diff <= -6) return 0.1;              // 6 ì´ìƒ ë‚®ìœ¼ë©´ 90% ê°ì†Œ
  return 1 + diff * 0.12;                 // ë‚®ìœ¼ë©´ ê¸‰ê²©íˆ ê°ì†Œ
}
/* ===== POE ë§µí•‘: í‹°ì–´ ìŠ¤ì¼€ì¼/ë§µ ìƒì„± ===== */

// í‹°ì–´ ê¸°ë°˜ ìŠ¤ì¼€ì¼(ë„ˆê°€ ì›í•˜ëŠ” ë°¸ëŸ°ìŠ¤ë¡œ ìˆ˜ì¹˜ë§Œ ì¡°ì ˆí•˜ë©´ ë¨)
function tierScale(t){
  // ì´ˆë°˜ì€ ì™„ë§Œ, ë’¤ë¡œ ê°ˆìˆ˜ë¡ ì¢€ ë” ê°•í•´ì§€ëŠ” ê³¡ì„ 
  const hpMul  = 1 + (t-1) * 0.22;     // í‹°ì–´ë‹¹ HP +22%
  const dmgMul = 1 + (t-1) * 0.16;     // í‹°ì–´ë‹¹ ë°ë¯¸ì§€ +16%
  const spdMul = 1 + Math.min(0.25, (t-1) * 0.02); // ì†ë„ëŠ” ìµœëŒ€ +25%ê¹Œì§€ë§Œ
  const eliteChance = clamp(0.06 + (t-1) * 0.008, 0.06, 0.22); // í‹°ì–´ ê¸°ë°˜ ì—˜ë¦¬íŠ¸ í™•ë¥ 
  const eliteHpMul = 2.4;   // ì—˜ë¦¬íŠ¸ ì²´ë ¥ ë°°ìˆ˜
  const eliteDmgMul = 1.9;  // ì—˜ë¦¬íŠ¸ ë”œ ë°°ìˆ˜
  return { hpMul, dmgMul, spdMul, eliteChance, eliteHpMul, eliteDmgMul };
}
function giveXP(enemy){

  let base = 0;

  if(enemy.type === "mage") base = 14;
  else if(enemy.type === "archer") base = 12;
  else if(enemy.type === "melee") base = 10;
  else if(enemy.type === "boss") base = 200 * mapTier;

  if(enemy.isElite) base *= 3;
  if(enemy.isLeader) base *= 4;
  // ğŸ”¥ ë ˆë²¨ ì°¨ì´ íŒ¨ë„í‹°
  const levelMul = getLevelPenalty(level, mapTier);

  // ğŸ”¥ ë§µ í‹°ì–´ ë³´ë„ˆìŠ¤
  const mapMul = 1 + (mapTier - 1) * 0.08;

  const finalXP = Math.floor(base * levelMul * mapMul);

  xp += finalXP;

  checkLevelUp();
}
function makeEnemyStatsByTier(type, t){
  const s = tierScale(t);

  // â€œê¸°ë³¸ê°’â€ (í‹°ì–´ 1 ê¸°ì¤€). ì—¬ê¸°ë§Œ ì¡ì•„ë‘ë©´ ì „ì²´ ë°¸ëŸ°ìŠ¤ê°€ ì‰¬ì›€.
  let baseHp, baseDmg, baseSpd;

  if(type === "mage"){
    baseHp  = 42;
    baseDmg = 9;
    baseSpd = 0.48;
  }else if(type === "archer"){
    baseHp  = 30;
    baseDmg = 14;
    baseSpd = 0.55;
  }else{ // melee
    baseHp  = 55;
    baseDmg = 11;
    baseSpd = 0.85;
  }

  return {
    hp:  baseHp  * s.hpMul,
    dmg: baseDmg * s.dmgMul,
    spd: baseSpd * s.spdMul,
    eliteChance: s.eliteChance,
    eliteHpMul: s.eliteHpMul,
    eliteDmgMul: s.eliteDmgMul
  };
}

function makeBossStatsByTier(t){
  const s = tierScale(t);

  // í‹°ì–´1 ê¸°ì¤€ ë³´ìŠ¤ ìŠ¤íƒ¯
  const baseHp  = 900;
  const baseDmg = 26;
  const baseSpd = 0.62;

  // ë³´ìŠ¤ëŠ” í‹°ì–´ ê³¡ì„ ì„ ì¡°ê¸ˆ ë” ë¬µì§í•˜ê²Œ(ì›í•˜ë©´ ì¡°ì ˆ)
  const bossHp  = baseHp  * (1 + (t-1)*0.28);
  const bossDmg = baseDmg * (1 + (t-1)*0.18);
  const bossSpd = baseSpd * (1 + Math.min(0.18, (t-1)*0.015));

  return { bossHp, bossDmg, bossSpd };
}

// ëœë¤ ë§µ ìƒì„±: ë°”ê¹¥ í…Œë‘ë¦¬ëŠ” ë²½(1), ë‚´ë¶€ëŠ” ë°”ë‹¥(0) + ëœë¤ ì¥ì• ë¬¼(1)
// í†µë¡œê°€ ë§‰í ìˆ˜ ìˆì§€ë§Œ, ë„¤ ê²Œì„ì€ â€œë²½ ì¶©ëŒë§Œâ€ ì¤‘ìš”í•˜ë‹ˆê¹Œ ê°„ë‹¨ ëœë¤ìœ¼ë¡œ ì‹œì‘
function generateRandomMap(t){
  mapSeed = (Date.now() % 1000000) ^ (t * 1337);

  // ì¥ì• ë¬¼ ë°€ë„: í‹°ì–´ê°€ ì˜¬ë¼ê°ˆìˆ˜ë¡ ì•½ê°„ ì¦ê°€ (ì›í•˜ë©´ ê³ ì •ë„ ê°€ëŠ¥)
  const density = clamp(0.06 + (t-1)*0.005, 0.06, 0.16);

  map = [];
  for(let y=0; y<mapSize; y++){
    let row = [];
    for(let x=0; x<mapSize; x++){
      // í…Œë‘ë¦¬ëŠ” ë¬´ì¡°ê±´ ë²½
      if(x===0 || y===0 || x===mapSize-1 || y===mapSize-1){
        row.push(1);
        continue;
      }
      // ì¤‘ì•™ ìŠ¤í° êµ¬ì—­ì€ ë°”ë‹¥ í™•ë³´ (í”Œë ˆì´ì–´ê°€ ë²½ì— ê°‡íˆëŠ” ê±¸ ë°©ì§€)
      const cx = Math.floor(mapSize/2);
      const cy = Math.floor(mapSize/2);
      if(Math.abs(x-cx) <= 2 && Math.abs(y-cy) <= 2){
        row.push(0);
        continue;
      }
      // ëœë¤ ì¥ì• ë¬¼
      row.push(Math.random() < density ? 1 : 0);
    }
    map.push(row);
  }

  // í”Œë ˆì´ì–´ ì¤‘ì•™ ë°°ì¹˜
  player.x = mapSize * tileSize / 2;
  player.y = mapSize * tileSize / 2;
}

// â€œë‹¤ìŒ ë§µâ€ ì´ë™: í‹°ì–´ ì¦ê°€ + ë§µ ì¬ìƒì„± + ìŠ¤í° ë¦¬ì…‹ + ë³´ìŠ¤ ì†Œí™˜
function nextMap(){
  mapTier++;

  // (ì„ íƒ) ë§µ ë„˜ì–´ê°ˆ ë•Œ í”Œë ˆì´ì–´ ë³´ìƒ/íšŒë³µ
  player.hp = player.maxHp;

  // ë§µ ì¬ìƒì„±
  generateRandomMap(mapTier);

  // ì—”í‹°í‹°/ì´í™íŠ¸ ì •ë¦¬
  enemies = [];
  packs = [];
  arrows = [];
  fireZones = [];
  particles = [];
  bloodParticles = [];
  bloodPools = [];
  levelParticles = [];

  // ìŠ¤í° íƒ€ì´ë¨¸ ë¦¬ì…‹
  spawnTimer = 0;
  spawnInterval = 120;
  bossTimer = 0;

  // ìƒˆ ë§µ ì‹œì‘: ì£¼ë³€ íŒ© ëª‡ ê°œ + ëœë¤ íŒ©ë“¤ + ë³´ìŠ¤ 1ë§ˆë¦¬
  for(let i=0;i<2;i++){
    let angle = Math.random()*Math.PI*2;
    let dist = 260 + Math.random()*180;
    let px = player.x + Math.cos(angle)*dist;
    let py = player.y + Math.sin(angle)*dist;

    let tx = clamp(Math.floor(px/tileSize), 1, mapSize-2);
    let ty = clamp(Math.floor(py/tileSize), 1, mapSize-2);

    createPack(tx*tileSize + tileSize/2, ty*tileSize + tileSize/2, 18 + Math.floor(Math.random()*10));
  }

  for(let i=0;i<10;i++){
    let tileX, tileY;
 for(let tries=0; tries<200; tries++){
  tileX = Math.floor(Math.random() * mapSize);
  tileY = Math.floor(Math.random() * mapSize);

  if(map[tileY] && map[tileY][tileX] === 0){
    break;
  }
}
    createPack(tileX*tileSize + tileSize/2, tileY*tileSize + tileSize/2, 18 + Math.floor(Math.random()*12));
  }

  spawnRandomBoss();

  // ì—°ì¶œ
  shake = Math.max(shake, 18);
  slowMotion = 0;
}
function dist2(ax, ay, bx, by){
  const dx = ax - bx;
  const dy = ay - by;
  return dx*dx + dy*dy;
}
/* ===== ìœ í‹¸/ë§µí•‘(POE) ===== */

// ê°„ë‹¨ ì‹œë“œ ëœë¤ (ë§µ ì¬í˜„ ê°€ëŠ¥í•˜ê²Œ í•˜ê³  ì‹¶ìœ¼ë©´ seed ê³ ì •)
function srand(seed){
  let s = seed >>> 0;
  return function(){
    s = (s * 1664525 + 1013904223) >>> 0;
    return s / 4294967296;
  };
}

// í”Œë ˆì´ì–´ ì‹œì‘ì§€ì (ë§µ ì¤‘ì•™) ì£¼ë³€ì€ ë¹„ì›Œë‘ê¸°
function clearSpawnArea(cx, cy, radiusTiles=3){
  const tx = Math.floor(cx / tileSize);
  const ty = Math.floor(cy / tileSize);
  for(let y=ty-radiusTiles; y<=ty+radiusTiles; y++){
    for(let x=tx-radiusTiles; x<=tx+radiusTiles; x++){
      if(x<=0||y<=0||x>=mapSize-1||y>=mapSize-1) continue;
      map[y][x] = 0;
    }
  }
}
function carveBossRoomAndCorridor(){
  // 1) ë³´ìŠ¤ë£¸ í¬ê¸°/ìœ„ì¹˜
  const w = 7 + Math.floor(Math.random()*5); // 7~11
  const h = 7 + Math.floor(Math.random()*5);
  const margin = 2;

  // êµ¬ì„ìª½ ëœë¤ ë°°ì¹˜(4ì½”ë„ˆ ì¤‘ í•˜ë‚˜)
  const corner = (Math.random()*4)|0;
  let x0, y0;

  if(corner===0){ x0 = mapSize - margin - w; y0 = margin; }               // ìš°ìƒ
  if(corner===1){ x0 = margin; y0 = margin; }                             // ì¢Œìƒ
  if(corner===2){ x0 = margin; y0 = mapSize - margin - h; }               // ì¢Œí•˜
  if(corner===3){ x0 = mapSize - margin - w; y0 = mapSize - margin - h; } // ìš°í•˜

  // 2) ë°© íŒŒê¸°(0ìœ¼ë¡œ)
  for(let y=y0; y<y0+h; y++){
    for(let x=x0; x<x0+w; x++){
      map[y][x] = 0;
    }
  }

  // 3) ë¬¸(door) ìœ„ì¹˜(ë°© í•œ ë³€ ì¤‘ì•™ì¯¤)
  // ìŠ¤í°ì´ ì¤‘ì•™ì´ë‹ˆ, ì¤‘ì•™ìª½ì„ í–¥í•œ ë©´ì— ë¬¸ì„ ë‘ë©´ í†µë¡œê°€ ì§§ì•„ì§
  const cx = Math.floor(mapSize/2), cy = Math.floor(mapSize/2);
  const roomCx = x0 + (w>>1), roomCy = y0 + (h>>1);

  let doorX = roomCx;
  let doorY = roomCy;

  // ì¤‘ì•™ê³¼ì˜ ìƒëŒ€ ìœ„ì¹˜ë¡œ ë¬¸ì„ ì–´ëŠ ë©´ì— ë‘˜ì§€ ê²°ì •
  if(Math.abs(roomCx - cx) > Math.abs(roomCy - cy)){
    // ì¢Œ/ìš°ë¡œ ë” ë©€ë©´: ë°©ì˜ ì¤‘ì•™ìª½ ë©´(ì¢Œë©´ ë˜ëŠ” ìš°ë©´)
    if(roomCx > cx){ doorX = x0;       doorY = roomCy; }  // ë°© ì™¼ìª½ë²½ì— ë¬¸
    else           { doorX = x0+w-1;   doorY = roomCy; }  // ë°© ì˜¤ë¥¸ìª½ë²½ì— ë¬¸
  }else{
    // ìƒ/í•˜ë¡œ ë” ë©€ë©´: ë°©ì˜ ì¤‘ì•™ìª½ ë©´(ìœ—ë©´ ë˜ëŠ” ì•„ë«ë©´)
    if(roomCy > cy){ doorY = y0;       doorX = roomCx; }  // ë°© ìœ—ë²½
    else           { doorY = y0+h-1;   doorX = roomCx; }  // ë°© ì•„ë«ë²½
  }

  map[doorY][doorX] = 0;

  // 4) ìŠ¤í° ê·¼ì²˜ íƒ€ì¼ ì¢Œí‘œ
  const startX = Math.floor(player.x / tileSize);
  const startY = Math.floor(player.y / tileSize);

  // 5) Lì í†µë¡œë¥¼ ê°•ì œë¡œ ëš«ê¸° (start -> door)
  // ê°€ë¡œ ë¨¼ì €
  let x = startX, y = startY;
  const stepX = doorX > x ? 1 : -1;
  while(x !== doorX){
    map[y][x] = 0;
    map[y-1] && (map[y-1][x] = 0);
    map[y+1] && (map[y+1][x] = 0);
    x += stepX;
  }
  // ì„¸ë¡œ
  const stepY = doorY > y ? 1 : -1;
  while(y !== doorY){
    map[y][x] = 0;
    map[y][x-1] !== undefined && (map[y][x-1] = 0);
    map[y][x+1] !== undefined && (map[y][x+1] = 0);
    y += stepY;
  }
  map[doorY][doorX] = 0;

  bossRoom = { x:x0, y:y0, w, h, cx:roomCx, cy:roomCy, doorX, doorY };
}
function buildEmptyMap(){
  map = [];
  for(let y=0; y<mapSize; y++){
    let row = [];
    for(let x=0; x<mapSize; x++){
      if(x===0 || y===0 || x===mapSize-1 || y===mapSize-1) row.push(1);
      else row.push(0);
    }
    map.push(row);
  }
}

// ëœë¤ ì§ì‚¬ê°í˜• ì¥ì• ë¬¼(ë²½) ë°°ì¹˜
function placeRandomWalls(rng, wallCount){
  for(let i=0;i<wallCount;i++){
    const w = 2 + Math.floor(rng()*5);
    const h = 2 + Math.floor(rng()*5);
    const x0 = 1 + Math.floor(rng()*(mapSize-2-w));
    const y0 = 1 + Math.floor(rng()*(mapSize-2-h));

    // ë„ˆë¬´ ì¤‘ì•™(ìŠ¤í° ê·¼ì²˜)ì—ëŠ” ê¹”ì§€ ë§ê¸°
    const cx = Math.floor(mapSize/2);
    const cy = Math.floor(mapSize/2);
    if(Math.abs((x0 + (w>>1)) - cx) < 4 && Math.abs((y0 + (h>>1)) - cy) < 4){
      continue;
    }

    for(let y=y0; y<y0+h; y++){
      for(let x=x0; x<x0+w; x++){
        if(x<=0||y<=0||x>=mapSize-1||y>=mapSize-1) continue;
        map[y][x] = 1;
      }
    }
  }
}
function buildReachableMaskFromPlayer(){
  const startX = Math.floor(player.x / tileSize);
  const startY = Math.floor(player.y / tileSize);

  const vis = Array.from({length: mapSize}, ()=>Array(mapSize).fill(false));
  if(!map[startY] || map[startY][startX] !== 0) return vis;

  const q = [[startX, startY]];
  vis[startY][startX] = true;

  while(q.length){
    const [x,y] = q.pop();
    const nb = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
    for(const [nx,ny] of nb){
      if(nx<=0||ny<=0||nx>=mapSize-1||ny>=mapSize-1) continue;
      if(vis[ny][nx]) continue;
      if(map[ny][nx] !== 0) continue;
      vis[ny][nx] = true;
      q.push([nx,ny]);
    }
  }
  return vis;
}
// ì—°ê²°ì„± ì²´í¬(ìŠ¤í°ì—ì„œ ë„ë‹¬ ê°€ëŠ¥í•œ ë°”ë‹¥ ë¹„ìœ¨ì´ ë„ˆë¬´ ë‚®ìœ¼ë©´ ë‹¤ì‹œ)
function floodFillReachableFromPlayer(){
  const startX = Math.floor(player.x / tileSize);
  const startY = Math.floor(player.y / tileSize);
  if(!map[startY] || map[startY][startX] !== 0) return 0;

  const vis = Array.from({length: mapSize}, ()=>Array(mapSize).fill(false));
  const q = [[startX,startY]];
  vis[startY][startX] = true;
  let count = 0;

  while(q.length){
    const [x,y] = q.pop();
    count++;

    const nb = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
    for(const [nx,ny] of nb){
      if(nx<=0||ny<=0||nx>=mapSize-1||ny>=mapSize-1) continue;
      if(vis[ny][nx]) continue;
      if(map[ny][nx] !== 0) continue;
      vis[ny][nx] = true;
      q.push([nx,ny]);
    }
  }
  return count;
}

function generateRandomMapForTier(tier){
  // í‹°ì–´ê°€ ì˜¤ë¥¼ìˆ˜ë¡ ì¥ì• ë¬¼ ì¢€ ëŠ˜ë ¤ì„œ â€œì§€í˜• ëŠë‚Œâ€ ê°•í™”
  const seed = (Date.now() ^ (tier*987654321)) >>> 0;
  const rng = srand(seed);

  // ì—¬ëŸ¬ ë²ˆ ì¬ì‹œë„í•´ì„œ â€œë§‰íŒ ë§µâ€ í”¼í•˜ê¸°
  for(let attempt=0; attempt<8; attempt++){
    buildEmptyMap();

    // ì¥ì• ë¬¼ ìˆ˜: í‹°ì–´ ì˜í–¥ + ëœë¤
    const wallCount = 22 + Math.floor(tier*2.2) + Math.floor(rng()*10);
    placeRandomWalls(rng, wallCount);

    clearSpawnArea(player.x, player.y, 3);

    const reachable = floodFillReachableFromPlayer();
    const totalFloor = (mapSize-2)*(mapSize-2);
    // ë„ë‹¬ê°€ëŠ¥ ë°”ë‹¥ ë¹„ìœ¨ 55% ì´ìƒì´ë©´ OK
    if(reachable / totalFloor >= 0.55){
      return seed;
    }
  }
  // ìµœí›„: ê·¸ëƒ¥ ë¹ˆ ë§µ
  buildEmptyMap();
  clearSpawnArea(player.x, player.y, 4);
  return seed;
}

// ë§µ ì‹œì‘(= í•œ íŒ ì‹œì‘)
function startNewMap(nextTier){
  mapTier = nextTier;
  mapRun.tier = nextTier;
  mapRun.clearedPacks = 0;
  mapRun.bossSpawned = false;
  mapRun.bossDefeated = false;

  // ëª©í‘œ íŒ© ìˆ˜: í‹°ì–´ê°€ ì˜¤ë¥¼ìˆ˜ë¡ ë” ë§ì´
  mapRun.packsToClear = 8 + Math.floor(nextTier * 1.5);

  // í¬íƒˆ ë¦¬ì…‹
  portal.active = false;
  portal.hold = 0;

  // ê¸°ì¡´ ì—”í‹°í‹° ì „ë¶€ ë¦¬ì…‹
  enemies = [];
  packs = [];
  particles = [];
  bloodPools = [];
  bloodParticles = [];
  arrows = [];
  levelParticles = [];
  fireZones = [];

  // ìŠ¤í°/ë³´ìŠ¤ íƒ€ì´ë¨¸ ê¸°ë°˜ ì‹œìŠ¤í…œì€ ë§µí•‘ì—ì„  ì‚¬ì‹¤ìƒ ë”
  spawnTimer = 0;
  spawnInterval = 999999;
  bossTimer = 0;

  // í”Œë ˆì´ì–´ ìœ„ì¹˜/ìƒíƒœëŠ” â€œëŸ° ê³„ì†â€ ëŠë‚Œìœ¼ë¡œ ê°ˆ ê±°ë©´ ìœ ì§€í•´ë„ ë˜ëŠ”ë°
  // ì§€ê¸ˆì€ ì¼ë‹¨ ì•ˆì „í•˜ê²Œ ì¤‘ì•™ìœ¼ë¡œ ì´ë™
  player.x = mapSize * tileSize / 2;
  player.y = mapSize * tileSize / 2;

   // ëœë¤ ì§€í˜• ìƒì„±
  mapRun.seed = generateRandomMapForTier(nextTier);

  // âœ… ë³´ìŠ¤ë£¸ + ë¬¸ + í†µë¡œ ê°•ì œ ìƒì„± (ë³´ìŠ¤ê°€ í•­ìƒ ê°ˆ ìˆ˜ ìˆê²Œ)
  carveBossRoomAndCorridor();

  // âœ… í†µë¡œê¹Œì§€ ë°˜ì˜í•´ì„œ ë„ë‹¬ ê°€ëŠ¥ ë§ˆìŠ¤í¬ ë‹¤ì‹œ ìƒì„±
  reachableMask = buildReachableMaskFromPlayer();

  // íŒ© ìƒì„±(ë§µ ì „ì²´ì— ë°°ì¹˜)
  spawnMapPacks(nextTier);
  // âœ… ë³´ìŠ¤ëŠ” í•­ìƒ ë³´ìŠ¤ë£¸ì— ì¡´ì¬
  spawnRandomBoss();
  // UI ë§ì¶¤
  resize();
}

// íŒ©ë“¤ì„ ë§µì— ëœë¤í•˜ê²Œ ë¿Œë¦¼(= PoE ë§µ ëª¹ ë¶„í¬)
function spawnMapPacks(tier){
  const rng = srand(mapRun.seed ^ 0xA53C9E1B);

  const packCount = mapRun.packsToClear + 4 + Math.floor(tier*0.6);
  for(let i=0;i<packCount;i++){
    let placed = false;

    for(let tries=0; tries<120; tries++){
      const tx = 1 + Math.floor(rng()*(mapSize-2));
      const ty = 1 + Math.floor(rng()*(mapSize-2));
      if(map[ty][tx] !== 0) continue;
if(reachableMask && !reachableMask[ty][tx]) continue; // âœ… ë„ë‹¬ ê°€ëŠ¥í•œ ë°”ë‹¥ì—ì„œë§Œ

      const px = tx*tileSize + tileSize/2;
      const py = ty*tileSize + tileSize/2;

      // ìŠ¤í° ê·¼ì²˜ëŠ” í”¼í•˜ê¸°
      const dx = px - player.x, dy = py - player.y;
      if(dx*dx + dy*dy < 260*260) continue;

// ===== POEì‹ ìì—°ìŠ¤ëŸ¬ìš´ ë§ˆë¦¿ìˆ˜ ê³¡ì„  =====

// ì´ˆë°˜ ìµœì†Œ/ìµœëŒ€
let min = 25;
let max = 32;

// í‹°ì–´ 6 ì´ìƒë¶€í„° ì ì  ì¦ê°€
if(tier >= 6){
  min = 28 + Math.floor((tier-5) * 0.4);
  max = 36 + Math.floor((tier-5) * 0.6);
}

// í‹°ì–´ 12 ì´ìƒì€ ë” ë°€ì–´ì¤Œ
if(tier >= 12){
  min = 30 + Math.floor((tier-10) * 0.5);
  max = 40 + Math.floor((tier-10) * 0.7);
}

// ìƒí•œ ì œí•œ (í­ì£¼ ë°©ì§€)
max = Math.min(max, 45);

const count = min + Math.floor(rng() * (max - min + 1));

createPack(px, py, count);
      placed = true;
      break;
    }

    if(!placed){
      // ëª» ë†“ìœ¼ë©´ ê·¸ëƒ¥ ìŠ¤í‚µ
    }
  }

  // íŒ©ì— cleared í”Œë˜ê·¸ ì¶”ê°€
  for(const p of packs){
    p.cleared = false;
    }
   linkNearbyPacks();   
  
}
function linkNearbyPacks(){
  const linkDist = 360; // âœ… ì´ ê±°ë¦¬ ì•ˆì´ë©´ ê°™ì€ ê·¸ë£¹ (320~420 ì·¨í–¥)
  const link2 = linkDist * linkDist;

  const n = packs.length;
  const parent = Array.from({length:n}, (_,i)=>i);
  const find = (a)=>{ while(parent[a]!==a){ parent[a]=parent[parent[a]]; a=parent[a]; } return a; };
  const union = (a,b)=>{ a=find(a); b=find(b); if(a!==b) parent[b]=a; };

  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      const dx = packs[i].x - packs[j].x;
      const dy = packs[i].y - packs[j].y;
      if(dx*dx + dy*dy <= link2) union(i,j);
    }
  }

  const rootToG = new Map();
  let gid = 0;

  for(let i=0;i<n;i++){
    const r = find(i);
    if(!rootToG.has(r)) rootToG.set(r, gid++);
    packs[i].groupId = rootToG.get(r);
    packs[i].groupCleared = false;
  }
}

function activatePackGroup(groupId){
  for(const p of packs){
    if(p.groupId === groupId){
      p.activated = true;

      // ìŠ¤í° ì‹¤íŒ¨ë¡œ ë¹ˆíŒ©ì´ë©´ ì§„í–‰ ë§‰íˆì§€ ì•Šê²Œ
      if(p.enemies.length === 0 && !p.cleared){
        p.cleared = true;
      }
    }
  }
}
// íŒ© í´ë¦¬ì–´ ì²´í¬ + ì§„í–‰ë„ ì—…ë°ì´íŠ¸
function updateMapProgress(){
  for(const p of packs){
    if(!p.activated) continue;
    if(p.cleared) continue;

    // pack.enemies ë°°ì—´ì´ ì´ë¯¸ ìœ ì§€ë˜ê³  ìˆìœ¼ë‹ˆ 0ì´ë©´ í´ë¦¬ì–´
    if(p.enemies.length === 0){
      p.cleared = true;
      mapRun.clearedPacks++;

      // ì‚´ì§ ì—°ì¶œ
      shake = Math.max(shake, 10);
      slowMotion = Math.max(slowMotion, 2);
    }
  }

  // ëª©í‘œ ë‹¬ì„±í•˜ë©´ ë³´ìŠ¤ ìŠ¤í°(í•œ ë²ˆë§Œ)
  if(!mapRun.bossSpawned && mapRun.clearedPacks >= mapRun.packsToClear){
    mapRun.bossSpawned = true;
    spawnRandomBoss(); // ê¸°ì¡´ í•¨ìˆ˜ ì¬ì‚¬ìš©
  }
}

// ë³´ìŠ¤ ì²˜ì¹˜ í›„ í¬íƒˆ ìƒì„±
function spawnPortal(x, y){
  portal.active = true;
  portal.x = x;
  portal.y = y;
  portal.hold = 0;

  // í¬íƒˆ ë“±ì¥ ì—°ì¶œ(íŒŒí‹°í´)
  for(let i=0;i<90;i++){
    const a = Math.random()*Math.PI*2;
    const sp = 1 + Math.random()*5;
    particles.push({
      x: x + (Math.random()-0.5)*10,
      y: y + (Math.random()-0.5)*10,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp,
      life: 30 + Math.floor(Math.random()*25)
    });
  }
}

// í¬íƒˆ ì§„ì… ì²˜ë¦¬(ê°€ê¹Œì´ ì„œìˆìœ¼ë©´ ìë™ ì´ë™)
function updatePortal(){
  if(!portal.active) return;

  const dx = player.x - portal.x;
  const dy = player.y - portal.y;
  const rr = (portal.r + player.radius + 8);
  if(dx*dx + dy*dy < rr*rr){
    portal.hold++;
    if(portal.hold >= portal.holdNeed){
      // ë‹¤ìŒ ë§µ(í‹°ì–´+1)
      startNewMap(mapTier + 1);
      return;
    }
  }else{
    portal.hold = 0;
  }
}

// í¬íƒˆ ê·¸ë¦¬ê¸°(ì›”ë“œì¢Œí‘œ)
function drawPortal(){
  if(!portal.active) return;

  // ì‚´ì§ íšŒì „í•˜ëŠ” ë§ ëŠë‚Œ(ë‹¨ìˆœ)
  const pulse = 0.6 + 0.4*Math.sin(frameCount*0.15);
  const r = portal.r + pulse*6;

  ctx.save();
  ctx.globalAlpha = 0.9;

  // ë°”ê¹¥ ë§
  ctx.strokeStyle = "rgba(120,180,255,0.85)";
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(portal.x, portal.y, r, 0, Math.PI*2);
  ctx.stroke();

  // ì•ˆìª½ ê¸€ë¡œìš°
  ctx.fillStyle = "rgba(80,140,255,0.18)";
  ctx.beginPath();
  ctx.arc(portal.x, portal.y, r-6, 0, Math.PI*2);
  ctx.fill();

  // ì§„ì… ê²Œì´ì§€(ì„œìˆëŠ” ì‹œê°„)
  if(portal.hold > 0){
    const t = clamp(portal.hold / portal.holdNeed, 0, 1);
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(portal.x, portal.y, r+8, -Math.PI/2, -Math.PI/2 + Math.PI*2*t);
    ctx.stroke();
  }

  ctx.restore();
}
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function spawnHitBlood(x, y, amount=10){
  if(bloodParticles.length > 320) return;

  for(let i=0;i<amount;i++){
    bloodParticles.push({
      x: x + (Math.random()-0.5)*6,
      y: y + (Math.random()-0.5)*6,
      vx: (Math.random()-0.5) * 6,
      vy: (Math.random()-0.5) * 6,
      size: Math.random()*3 + 1.5,
      life: 22
    });
  }

  if(bloodPools.length < 140){
    bloodPools.push({
      x: x + (Math.random()-0.5)*8,
      y: y + (Math.random()-0.5)*8,
      size: 5 + Math.random()*4,
      life: 280
    });
  }
}
function startBossDeath(boss){
    if(boss.dead) return;
 if(!boss.xpGiven){
    boss.xpGiven = true;
    giveXP(boss);
    }
  boss.dead = true;
  boss.deathTimer = 60;      // âœ… 1ì´ˆ ì—°ì¶œ(60fps ê¸°ì¤€)
  boss.deathMax = 60;

  shake = Math.max(shake, 60);
  slowMotion = Math.max(slowMotion, 10);

  // í”¼ + íŒŒí¸
  spawnHitBlood(boss.x, boss.y, 40);

  // í° í­ë°œ íŒŒí‹°í´(ì£¼í™©/ë¹¨ê°• ëŠë‚Œì€ fillStyleì´ ì´ë¯¸ redë¼ "í”¼ íŒŒí¸"ì²˜ëŸ¼ ë³´ì„)
  for(let i=0;i<140;i++){
    const a = Math.random()*Math.PI*2;
    const sp = 2 + Math.random()*8;
    particles.push({
      x: boss.x + (Math.random()-0.5)*10,
      y: boss.y + (Math.random()-0.5)*10,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp - (Math.random()*2),
      life: 45 + Math.floor(Math.random()*25)
    });
  }

  // ë°”ë‹¥ì— í° í”¼ì›…ë©ì´(ë‚¨ëŠ” ëŠë‚Œ)
  if(bloodPools.length < 140){
    bloodPools.push({
      x: boss.x,
      y: boss.y,
      size: 26,
      life: 900
    });
  }

    // âœ… ë³´ìŠ¤ í™•ì • ë“œë(ì„ íƒ 1íšŒ)
  spawnLoot(boss.x, boss.y, "boss");

  bossDeathSound();
}

/* ===== ì¶©ëŒ/ì´ë™ ê°€ëŠ¥ ===== */
function canMoveTo(x,y){
  let left = Math.floor((x - player.radius) / tileSize);
  let right = Math.floor((x + player.radius) / tileSize);
  let top = Math.floor((y - player.radius) / tileSize);
  let bottom = Math.floor((y + player.radius) / tileSize);

  return (
    map[top] && map[top][left] === 0 &&
    map[top] && map[top][right] === 0 &&
    map[bottom] && map[bottom][left] === 0 &&
    map[bottom] && map[bottom][right] === 0
  );
}
function canEnemyMoveTo(enemy, x, y){
  let left = Math.floor((x - enemy.radius) / tileSize);
  let right = Math.floor((x + enemy.radius) / tileSize);
  let top = Math.floor((y - enemy.radius) / tileSize);
  let bottom = Math.floor((y + enemy.radius) / tileSize);

  return (
    map[top] && map[top][left] === 0 &&
    map[top] && map[top][right] === 0 &&
    map[bottom] && map[bottom][left] === 0 &&
    map[bottom] && map[bottom][right] === 0
  );
}
function isFloorTile(tx, ty){ return !!(map[ty] && map[ty][tx] === 0); }
function canSpawnEnemyAt(enemy, x, y){ return canEnemyMoveTo(enemy, x, y); }
// âœ… í”Œë ˆì´ì–´-ì  ê²¹ì¹¨ ë°©ì§€(ë°€ì–´ë‚´ê¸°)
function resolvePlayerEnemyOverlap(){
  const pad = 2; // ì‚´ì§ ì—¬ìœ 
  for(const e of enemies){
    // ë³´ìŠ¤ ì£½ìŒ ì—°ì¶œ/íŒ© ë¹„í™œì„±/ì‚¬ë§ ì ì€ ìŠ¤í‚µ
    if(e.type === "boss" && e.dead) continue;
    if(e.hp <= 0) continue;
    if(e.pack && !e.pack.activated) continue;

    let dx = e.x - player.x;
    let dy = e.y - player.y;
    let dist = Math.hypot(dx, dy);

    const minDist = player.radius + e.radius + pad;

    // ì™„ì „ ê°™ì€ ì¢Œí‘œë¡œ ê²¹ì¹œ ê²½ìš°(0 ë‚˜ëˆ—ì…ˆ ë°©ì§€)
    if(dist === 0){
      dx = (Math.random() - 0.5) * 0.01;
      dy = (Math.random() - 0.5) * 0.01;
      dist = Math.hypot(dx, dy);
    }

    if(dist < minDist){
      const nx = dx / dist;
      const ny = dy / dist;
      const push = (minDist - dist);

      // ê¸°ë³¸ì€ "ì ì„ ë°€ê¸°" (í”Œë ˆì´ì–´ ì¡°ì‘ê° ìœ ì§€)
      const ex = e.x + nx * push;
      const ey = e.y + ny * push;

      if(canEnemyMoveTo(e, ex, ey)){
        e.x = ex; e.y = ey;
      }else{
        // ì ì´ ëª» ì›€ì§ì´ë©´ í”Œë ˆì´ì–´ë¥¼ ë°˜ëŒ€ë¡œ ì‚´ì§ ë°€ê¸°
        const px = player.x - nx * push;
        const py = player.y - ny * push;
        if(canMoveTo(px, player.y)) player.x = px;
        if(canMoveTo(player.x, py)) player.y = py;
      }
    }
  }
}
/* ===== í”Œë ˆì´ì–´ í”¼ê²© ì²˜ë¦¬ ===== */
function damagePlayer(dmg, knockX, knockY){
  if(player.invul > 0 || gameOver) return;

  // âœ… ë°©ì–´ë ¥ ê¸°ë°˜ í”¼í•´ ê°ì†Œ
  const armor = (player.armor ?? 0);

  // ê°ì‡ ì‹(ìì—°ìŠ¤ëŸ¬ìš´ ê³¡ì„ ): dmg * 50/(50+armor)
  const reduced = dmg * (50 / (50 + Math.max(0, armor)));
  const finalDmg = Math.max(1, Math.floor(reduced)); // ìµœì†Œ 1ì€ ë°›ê²Œ

  player.hp -= finalDmg;
  emitEvent("takeDamage", { dmg: finalDmg });
  player.invul = 25;
  shake = Math.max(shake, 10);

  let nx = player.x + knockX;
  let ny = player.y + knockY;

  if(canMoveTo(nx, player.y)) player.x = nx;
  if(canMoveTo(player.x, ny)) player.y = ny;

  if(player.hp <= 0) handleGameOver();
}

/* ===== ì  ê·¼ì ‘ ê³µê²© ===== */
function enemyTryMeleeAttack(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);
  const reach = e.type === "boss" ? 70 : 42;

  if(dist > reach){
    e.attackFrame = 0;
    return;
  }

  if(e.attackFrame === 0){
    e.swingDir = dx < 0 ? -1 : 1;
  }

  const atkMul = (e.buffs?.atkSpdMul ?? 1);
e.attackFrame += atkMul;

 if(e.attackFrame >= 12 && !e.hitDone){
  e.hitDone = true;

  const len = dist || 1;
  const nx = dx / len;
  const ny = dy / len;
  const kb = e.type === "boss" ? 30 : 18;
  damagePlayer(e.damage, nx*kb, ny*kb);
  hitSound();
}

 if(e.attackFrame >= 25){
  e.attackFrame = 0;
  e.hitDone = false;
}
}

/* ===== ì•„ì²˜ í™”ì‚´ ë°œì‚¬ ===== */
function spawnArrow(fromX, fromY, toX, toY, damage){
  const dx = toX - fromX;
  const dy = toY - fromY;
  const dist = Math.hypot(dx, dy) || 1;
  const speed = 7.5;

  arrows.push({
    x: fromX,
    y: fromY,
    dx: dx/dist * speed,
    dy: dy/dist * speed,
    damage,
    life: 240
  });
}

/* ===== ë©”ì´ì§€ ì¥íŒ ìƒì„± ===== */
function spawnFireZone(x, y, damage){
  fireZones.push({ x, y, radius:55, life:180, tick:0, damage });
}

/* ===== ìŠ¤í° ===== */
function spawnEnemy(){
  if(enemies.length >= 300) return;

  let tileX, tileY;
let found = false;

for(let tries=0; tries<500; tries++){
  tileX = Math.floor(Math.random() * mapSize);
  tileY = Math.floor(Math.random() * mapSize);

  if(
    map[tileY]?.[tileX] === 0 &&
    map[tileY-1]?.[tileX] === 0 &&
    map[tileY+1]?.[tileX] === 0 &&
    map[tileY]?.[tileX-1] === 0 &&
    map[tileY]?.[tileX+1] === 0
  ){
    found = true;
    break;
  }
}

if(!found) return; // âœ… ëª» ì°¾ìœ¼ë©´ ê·¸ëƒ¥ ìŠ¤í° í¬ê¸° (í”„ë¦¬ì¦ˆ ë°©ì§€)
  let ex = tileX * tileSize + tileSize/2;
  let ey = tileY * tileSize + tileSize/2;

  let rand = Math.random();
  let type;
  if(rand < 0.2) type = "mage";
  else if(rand < 0.5) type = "archer";
  else type = "melee";

  const st = makeEnemyStatsByTier(type, mapTier);

  let enemy = {
    x: ex, y: ey,
    radius: 14,
    stun: 0,
    invul: 0,
    attackFrame: 0,
    swingDir: 1,
    type,

    hp: st.hp,
    speed: st.spd,
    damage: st.dmg,

    shootCooldown: 0,
    castCooldown: 120
  };

  // âœ… ì—˜ë¦¬íŠ¸ í™•ë¥ ë„ í‹°ì–´ë§Œ ë”°ë¼ê°€ê²Œ
  if(Math.random() < st.eliteChance){
    enemy.isElite = true;
    enemy.eliteColor = Math.random() < 0.5 ? "yellow" : "blue";
    enemy.speed *= 1.5;
    enemy.damage *= st.eliteDmgMul;
    enemy.radius *= 1.2;
    enemy.hp *= st.eliteHpMul;
  }

  enemies.push(enemy);
}

function spawnEnemyAt(ex, ey, pack){
  let tileX = Math.floor(ex / tileSize);
  let tileY = Math.floor(ey / tileSize);

  if(!isFloorTile(tileX, tileY)) return;
  if(!isFloorTile(tileX-1, tileY) || !isFloorTile(tileX+1, tileY) || !isFloorTile(tileX, tileY-1) || !isFloorTile(tileX, tileY+1)) return;
  if(enemies.length >= 320) return;

  let rand = Math.random();
  let type = rand < 0.2 ? "mage" : rand < 0.5 ? "archer" : "melee";

  const st = makeEnemyStatsByTier(type, mapTier);

  let enemy = {
    x: ex, y: ey,
    radius: 14,
    stun: 0,
    invul: 0,
    attackFrame: 0,
    swingDir: 1,
    type,
    hp: st.hp,
    speed: st.spd,
    damage: st.dmg,
    shootCooldown: 0,
    castCooldown: 120,
    pack
  };

  if(!canSpawnEnemyAt(enemy, ex, ey)) return;

  // íŒ©ì—ì„œë„ ì—˜ë¦¬íŠ¸
  if(Math.random() < st.eliteChance * 0.85){
    enemy.isElite = true;
    enemy.eliteColor = Math.random() < 0.5 ? "yellow" : "blue";
    enemy.speed *= 1.5;
    enemy.damage *= st.eliteDmgMul;
    enemy.radius *= 1.2;
    enemy.hp *= st.eliteHpMul;
  }

  enemies.push(enemy);
  pack.enemies.push(enemy);
}
function spawnPackLeaderAt(ex, ey, pack){
  const st = makeEnemyStatsByTier("melee", mapTier);

  let leader = {
    x: ex, y: ey,
    radius: 18,
    stun: 0,
    invul: 0,
    attackFrame: 0,
    swingDir: 1,
    type: "melee",

    // âœ… ë¦¬ë” ê°•í™” ìˆ˜ì¹˜ (ì—¬ê¸°ë§Œ ì¡°ì ˆí•˜ë©´ ë¨)
    hp: st.hp * 3.2,
    speed: st.spd * 1.08,
    damage: st.dmg * 1.6,

    shootCooldown: 0,
    castCooldown: 120,

    pack,
    isLeader: true
  };

  if(!canSpawnEnemyAt(leader, ex, ey)) return;

  enemies.push(leader);
  pack.enemies.push(leader);
}

function spawnRandomBoss(){
  // ì´ë¯¸ ë³´ìŠ¤ê°€ ìˆìœ¼ë©´ ìŠ¤í‚µ
  if(enemies.some(e => e.type === "boss")) return;

  // bossRoom ì¤‘ì‹¬(íƒ€ì¼ì¢Œí‘œ -> ì›”ë“œì¢Œí‘œ)
  const bx = bossRoom.cx * tileSize + tileSize/2;
  const by = bossRoom.cy * tileSize + tileSize/2;

  const tempBoss = { radius: 30 };

  // ë³´ìŠ¤ë£¸ ì¤‘ì•™ì´ ë²½/ë§‰í˜ì´ë©´(í˜¹ì‹œ ìƒì„± ì‹¤íŒ¨ ëŒ€ë¹„) ê·¸ëƒ¥ ë¦¬í„´
  if(!canEnemyMoveTo(tempBoss, bx, by)) return;

  const bst = makeBossStatsByTier(mapTier);

  enemies.push({
    x: bx, y: by,
    radius: 30,
    type: "boss",

    maxHp: bst.bossHp,
    hp: bst.bossHp,
    speed: bst.bossSpd,
    damage: bst.bossDmg,

    stun: 0,
    attackFrame: 0,
    swordPulled: false,
    phase2Used: false,
    dashCooldown: 120,
    cleaveCooldown: 160,
    invul: 0,
    phaseLock: 0
  });
}

function createPack(cx, cy, count){
  let pack = {
    x: cx, y: cy,
    enemies: [],
    activated: false,
    cleared: false,

    // âœ… ê·¸ë£¹ìš© (ì•„ë˜ â€œíŒ© í•©ì¹˜ê¸°â€ì—ì„œ ì”€)
    groupId: -1,
    groupCleared: false
  };

  // âœ… ë¦¬ë” 1ë§ˆë¦¬ ë¨¼ì €
  spawnPackLeaderAt(cx, cy, pack);

  // âœ… ë‚˜ë¨¸ì§€ ì¼ë°˜ëª¹
  const normalCount = Math.max(0, count - 1);
  let tries = 0;

  while(pack.enemies.length < (normalCount + 1) && tries < count * 8){
    tries++;
    let angle = Math.random()*Math.PI*2;
    let radius = Math.random()*140;
    let ex = cx + Math.cos(angle)*radius;
    let ey = cy + Math.sin(angle)*radius;
    spawnEnemyAt(ex, ey, pack);
  }

  packs.push(pack);
}

/* ===== ê¶ê·¹ê¸° ===== */
function teleportTo(target){
  spawnHitBlood(player.x, player.y, 18);
  if(particles.length < 220){
    for(let i=0;i<10;i++){
      particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 22 });
    }
  }

  if(canMoveTo(target.x, target.y)){
    player.x = target.x;
    player.y = target.y;
  }

  spawnHitBlood(player.x, player.y, 22);
  if(particles.length < 220){
    for(let i=0;i<12;i++){
      particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 26 });
    }
  }

  shake = Math.max(shake, 10);
}


/* ===== ë³´ìŠ¤ ìŠ¤í‚¬ ===== */
function bossEnterPhase2(boss){
  boss.swordPulled = true;
  boss.phase2Used = true;
  boss.speed *= 1.25;
  boss.damage *= 1.2;

  boss.invul = 120;
  boss.phaseLock = 36;

  shake = 30;
  bossUnsheatheSound();

  for(let i=0;i<80;i++){
    particles.push({ x: boss.x, y: boss.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 50 });
  }
}

function bossDash(boss){
  const dx = player.x - boss.x;
  const dy = player.y - boss.y;
  const dist = Math.hypot(dx, dy) || 1;
  const nx = dx / dist;
  const ny = dy / dist;

  const dashDist = 220;
  const steps = 18;
  let hit = false;

  for(let i=0;i<steps;i++){
    let px = boss.x + nx * (dashDist/steps);
    let py = boss.y + ny * (dashDist/steps);

    if(canEnemyMoveTo(boss, px, py)){
      boss.x = px; boss.y = py;
    }else break;

    if(!hit){
      const d = Math.hypot(player.x - boss.x, player.y - boss.y);
      if(d < boss.radius + player.radius + 10){
        damagePlayer(boss.damage*1.2, nx*34, ny*34);
        hit = true;
      }
    }
  }
  shake = Math.max(shake, 16);
}

function bossCleave(boss){
  const radius = 140;

  for(let i=0;i<70;i++){
    const a = Math.random()*Math.PI*2;
    const r = Math.random()*radius;
    particles.push({
      x: boss.x + Math.cos(a)*r,
      y: boss.y + Math.sin(a)*r,
      vx: Math.cos(a)*2 + (Math.random()-0.5)*2,
      vy: Math.sin(a)*2 + (Math.random()-0.5)*2,
      life: 35
    });
  }

  const dist = Math.hypot(player.x - boss.x, player.y - boss.y);
  if(dist < radius){
    const dx = player.x - boss.x;
    const dy = player.y - boss.y;
    const len = Math.hypot(dx, dy) || 1;
    damagePlayer(boss.damage*1.6, (dx/len)*42, (dy/len)*42);
  }
  shake = Math.max(shake, 22);
}
function isEnemyOnScreen(e){
  const camX = player.x - canvas.width/2;
  const camY = player.y - canvas.height/2;

  const screenLeft   = camX - 50;
  const screenRight  = camX + canvas.width + 50;
  const screenTop    = camY - 50;
  const screenBottom = camY + canvas.height + 50;

  return (
    e.x > screenLeft &&
    e.x < screenRight &&
    e.y > screenTop &&
    e.y < screenBottom
  );
}
/* ===== ì—…ë°ì´íŠ¸ ===== */
function update(){
  frameCount++;

  // âœ… ì•„ì´í…œ ì„ íƒì°½ ì—´ë ¤ìˆìœ¼ë©´ ê²Œì„ ì •ì§€(ë Œë”ëŠ” ê³„ì†)
  if(lootOverlayOpen) return;

  if(gameOver) return;

  if(slowMotion > 0){
  slowMotion--;

  // âœ… ìŠ¬ë¡œìš° ì¤‘ì—ë„ ë³´ìŠ¤ ì‚¬ë§ íƒ€ì´ë¨¸/ì—°ì¶œì€ ì§„í–‰ë˜ê²Œ
  updateEnemySystem();

resolvePlayerEnemyOverlap(); // âœ… ì¶”ê°€
  // âœ… íŒŒí‹°í´/í”¼ ê°™ì€ ì´í™íŠ¸ë„ ë©ˆì¶”ì§€ ì•Šê²Œ
  updateEffectSystem();

  return;
}

  updateBuffs(player); // âœ… í”Œë ˆì´ì–´ë„ ë²„í”„ ì—…ë°ì´íŠ¸
updatePlayerState();
  updateUltimateSystem();
   updateEnemySystem();
  resolvePlayerEnemyOverlap(); // âœ… ì¶”ê°€
  updateCombatSystem();
  updateProjectileSystem();
  updateEffectSystem();
  updateEnvironmentSystem();
    // âœ… ë§µí•‘ ì§„í–‰ë„(íŒ© í´ë¦¬ì–´ â†’ ë³´ìŠ¤ ìŠ¤í°)
  

  // âœ… ë³´ìŠ¤ ì²˜ì¹˜ í›„ í¬íƒˆ ì§„ì… ì²˜ë¦¬
  updatePortal();

  /* âœ… (ì¶”ê°€) ê¶ê·¹ê¸° ë²„íŠ¼ ì ê¸ˆ í‘œì‹œ */
}

function updatePlayerState(){
  if(player.hp <= 0){ handleGameOver(); return; }
  updateMovement();
  updateInvulnerability();
  updateLevelGlow();

  // âœ… ì´ˆë‹¹ ì¬ìƒ(hpRegen)ì„ í”„ë ˆì„ë‹¹ìœ¼ë¡œ í™˜ì‚°(60fps ê°€ì •)
  const regen = (player.buffs?.hpRegen ?? 0) / 60;
  if(regen > 0) player.hp = Math.min(player.maxHp, player.hp + regen);
}
function handleGameOver(){
  gameOver = true;
  document.getElementById("ui").style.display = "none";
}
function updateLevelGlow(){
  if(player.levelGlow > 0) player.levelGlow--;
}

function updateUltimateSystem(){
  if(!player.ultiActive) return;

  player.ultiTimer++;
  if(player.ultiTimer % 10 === 0) performUltimateStrike();
  if(player.ultiCount >= 5) endUltimate();
}
function endUltimate(){
  player.ultiActive = false;
  player.ultiTimer = 0;
  player.ultiCount = 0;
  explosionActive = false;
}
/* âœ… (ì£¼ì˜) ë„¤ ì½”ë“œì— endUltimate()ê°€ ì›ë˜ ìˆì–´ì•¼ ì •ìƒë™ì‘í•´.
   ë§Œì•½ ë„¤ íŒŒì¼ ì–´ë”˜ê°€ì— endUltimateê°€ ì—†ë‹¤ë©´ ì•Œë ¤ì¤˜! */
function performUltimateStrike(){
  const target = getRandomVisibleAliveEnemy(); // âœ… í™”ë©´ì— ë³´ì´ëŠ” ì ë§Œ
  if(!target) { endUltimate(); return; }

  teleportTo(target);
  dealUltimateDamage();

  pruneDeadEnemies();
  player.ultiCount++;
}
function dealUltimateDamage(){
  const radius = getUltiAoeRadius(); // âœ… ë³€ê²½
  const r2 = radius * radius;
  let killedAny = false;

  for(let i=0; i<enemies.length; i++){
    const e = enemies[i];
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    if(dx*dx + dy*dy > r2) continue;

    const wasAlive = (e.hp > 0);

    if(e.type === "boss"){
      if(e.invul <= 0 && !e.dead){
        e.hp -= ultiDamage * 1.0;
        e.stun = 25;
        spawnHitBlood(e.x, e.y, 14);
        shake = Math.max(shake, 20);

        // âœ… ê¶ê·¹ê¸°ë¡œ ë³´ìŠ¤ê°€ ì£½ì–´ë„ ì‚¬ë§ì—°ì¶œ/í¬íƒˆ ë¡œì§ íƒ€ê²Œ
        if(e.hp <= 0){
          startBossDeath(e);
        }
      }
      continue;
    }

    e.hp = 0;
      // âœ… ë“œë ìƒì„±
    spawnLoot(e.x, e.y, "ulti");
    e.stun = 30;
    spawnHitBlood(e.x, e.y, 18);

    if(particles.length < 240){
      for(let k=0;k<12;k++){
        particles.push({ x: e.x, y: e.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 40 });
      }
    }

    if(wasAlive){
      giveXP(e);
      player.hp = Math.min(player.maxHp, player.hp + 1);
      slowMotion = 6;
      if(player.kiOrbs < player.maxOrbs) player.kiOrbs++;
      killedAny = true;
    }
  }

  if(killedAny) hitSound();
  shake = Math.max(shake, 35);
    // âœ… ê¶ê·¹ê¸° ê´‘ì—­ ì²˜ì¹˜ í›„ ì£½ì€ ëª¹ ì¦‰ì‹œ ì •ë¦¬
  pruneDeadEnemies();
}

function updateEnemySystem(){
  // âœ… íŒ© í™œì„±í™”: "í”Œë ˆì´ì–´ê°€ íŒ© ê·¼ì²˜ë©´" í™œì„±í™”
  packs.forEach(pack=>{
    if(pack.activated) return;

    const dx = pack.x - player.x;
    const dy = pack.y - player.y;

    // âœ… ì´ ê±°ë¦¬ ì•ˆìœ¼ë¡œ ë“¤ì–´ì˜¤ë©´ í™œì„±í™” (ì›í•˜ë©´ 520 ìˆ«ìë§Œ ì¡°ì ˆ)
    if(dx*dx + dy*dy < 520*520){
      activatePackGroup(pack.groupId);

      // ì›¨ì´ë¸Œ ëŠë‚Œ ì—°ì¶œ
      shake = Math.max(shake, 8);
      slowMotion = Math.max(slowMotion, 1);
    }
  });

  enemies.forEach(e=>{
    if(e.pack && !e.pack.activated) return;
    updateSingleEnemy(e);
  });
 for(const e of enemies){
  updateBuffs(e);
}

  // âœ… ë§¤ í”„ë ˆì„ í•œ ë²ˆ ë” ì²­ì†Œ(ì—°ì† ê¶ê·¹ê¸°/ëŒ€ëŸ‰ ì²˜ì¹˜ ëŒ€ë¹„)
  pruneDeadEnemies();
}

function updateLevelParticles(){
  for(let i = levelParticles.length - 1; i >= 0; i--){
    const p = levelParticles[i];
    p.ox += p.vx;
    p.oy -= p.vy;
    p.vy *= 0.97;
    p.life--;
    if(p.life <= 0) levelParticles.splice(i,1);
  }
  if(levelParticles.length > 200){
    levelParticles.splice(0, levelParticles.length - 200);
  }
}

function updateParticles(){
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }
  if(particles.length > 260){
    particles.splice(0, particles.length - 260);
  }
}

function updateMelee(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  if(dist > 0){
    let moveX = dx / dist * e.speed;
    let moveY = dy / dist * e.speed;

    let newX = e.x + moveX;
    let newY = e.y + moveY;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }

  enemyTryMeleeAttack(e);
}

function updateArcher(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  const desired = 240;
  if(dist < desired - 40){
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;

    const newX = e.x - nx * e.speed * 1.2;
    const newY = e.y - ny * e.speed * 1.2;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }else if(dist > desired + 80){
    updateMelee(e);
  }

  e.shootCooldown--;
  if(e.shootCooldown <= 0 && dist < 520){
    spawnArrow(e.x, e.y, player.x, player.y, e.damage);
    e.shootCooldown = 80 + Math.floor(Math.random()*40);
  }
}

function updateMage(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  if(dist < 180){
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;

    const newX = e.x - nx * e.speed * 1.4;
    const newY = e.y - ny * e.speed * 1.4;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }else{
    updateMelee(e);
  }

  e.castCooldown--;
  if(e.castCooldown <= 0 && dist < 520){
    spawnFireZone(player.x, player.y, e.damage);
    e.castCooldown = 140 + Math.floor(Math.random()*50);
  }
}

function updateBoss(e){
  if(!e.phase2Used && e.hp <= e.maxHp * 0.5) bossEnterPhase2(e);
  updateMelee(e);

  if(e.swordPulled){
    e.dashCooldown--;
    e.cleaveCooldown--;

    const dist = Math.hypot(player.x - e.x, player.y - e.y);

    if(e.dashCooldown <= 0 && dist > 160 && dist < 520){
      bossDash(e);
      e.dashCooldown = 160 + Math.floor(Math.random()*70);
    }
    if(e.cleaveCooldown <= 0 && dist < 220){
      bossCleave(e);
      e.cleaveCooldown = 200 + Math.floor(Math.random()*80);
    }
  }
}

function updateSingleEnemy(e){
  if(e.isLeader){
  const radius = 50;
  const r2 = radius * radius;

  for(const other of enemies){
    if(other === e) continue;

    const dx = other.x - e.x;
    const dy = other.y - e.y;

    if(dx*dx + dy*dy <= r2){
      applyBuff(other, "damage",   1.25, 15, "leader");
applyBuff(other, "atkSpeed", 1.2,  15, "leader");
    }
  }
}
if(e.type === "boss" && e.dead){
  e.deathTimer--;

  // ì—°ì¶œ ì¤‘ íŒŒí‹°í´
  if(e.deathTimer % 10 === 0){
    shake = Math.max(shake, 10);
    spawnHitBlood(
      e.x + (Math.random()-0.5)*12,
      e.y + (Math.random()-0.5)*12,
      10
    );
  }

  // ğŸ”¥ ì—°ì¶œ ëë‚˜ëŠ” ìˆœê°„ í¬íƒˆ 1íšŒ ìƒì„±
  if(e.deathTimer === 1 && !mapRun.bossDefeated){
    mapRun.bossDefeated = true;
    spawnPortal(e.x, e.y);
  }

  return;
}

  if(e.invul > 0) e.invul--;

  if(e.phaseLock > 0){
    e.phaseLock--;
    return;
  }

  if(e.stun > 0){
    e.stun--;
    return;
  }

  switch(e.type){
    case "archer": updateArcher(e); break;
    case "mage": updateMage(e); break;
    case "boss": updateBoss(e); break;
    default: updateMelee(e);
  }
}

function updateProjectileSystem(){
  updateArrows();
  updateFireZones();
}

function updateFireZones(){
  for(let i = fireZones.length - 1; i >= 0; i--){
    const f = fireZones[i];
    f.life--;
    f.tick++;

    if(f.tick % 10 === 0){

      // ğŸ”´ ì¶œí˜ˆ ì¥íŒ (Blood Katana ë“±)
      if(f.isBleed){

        let hitCount = 0;

        for(const e of enemies){
          if(e.hp <= 0) continue;
          if(e.type === "boss" && e.dead) continue;

          const dx = e.x - f.x;
          const dy = e.y - f.y;
          if(dx*dx + dy*dy > f.radius*f.radius) continue;

          const dealt = f.damage;

          if(e.type === "boss"){
            if(e.invul <= 0 && !e.dead){
              e.hp -= dealt;
              if(e.hp <= 0) startBossDeath(e);
            }
          }else{
            e.hp -= dealt;
            if(e.hp <= 0){
              emitEvent("kill", { enemy:e, x:e.x, y:e.y, type:e.type });
              spawnLoot(e.x, e.y, "bleed");
              giveXP(e);
            }
          }

          // í¡í˜ˆ
          player.hp = Math.min(player.maxHp, player.hp + dealt * 0.12);

          spawnHitBlood(e.x, e.y, 3);

          hitCount++;
          if(hitCount >= 10) break;
        }

        pruneDeadEnemies();

      } 
      // ğŸ”¥ ë©”ì´ì§€ ì¥íŒ
      else {
        const dx = player.x - f.x;
        const dy = player.y - f.y;

        if(dx*dx + dy*dy < f.radius*f.radius){
          damagePlayer(f.damage, 0, 0);
        }
      }
    }

    if(f.life <= 0){
      fireZones.splice(i,1);
    }
  }
}

function updateEffectSystem(){
  updateParticles();
  updateBlood();
  updateLevelParticles();

  for(let i=bloodPools.length-1;i>=0;i--){
    bloodPools[i].life--;
    if(bloodPools[i].life <= 0) bloodPools.splice(i,1);
  }
  if(bloodPools.length > 120) bloodPools.splice(0, bloodPools.length-120);
updateLoots(); // âœ… ì¶”ê°€
}

function updateCombatSystem(){
  if(attacking){
    attackFrame++;
    if(attackFrame === 3) checkHit();
    if(attackFrame > 8){
      attacking = false;
      attackFrame = 0;
    }
  }
}

function updateMovement(){
  const moveSpeed = player.speed * (player.buffs?.spdMul ?? 1);
  let dx = 0;
  let dy = 0;

  if(keys["ArrowLeft"] || keys["a"]) dx -= moveSpeed;
if(keys["ArrowRight"] || keys["d"]) dx += moveSpeed;
if(keys["ArrowUp"] || keys["w"]) dy -= moveSpeed;
if(keys["ArrowDown"] || keys["s"]) dy += moveSpeed;

dx += joyDX * moveSpeed;
dy += joyDY * moveSpeed;

  if(Math.abs(dx) > Math.abs(dy)){
    if(dx > 0) player.dir = "right";
    else if(dx < 0) player.dir = "left";
  }else{
    if(dy > 0) player.dir = "down";
    else if(dy < 0) player.dir = "up";
  }

  let newX = player.x + dx;
  let newY = player.y + dy;

  if(canMoveTo(newX, player.y)) player.x = newX;
  if(canMoveTo(player.x, newY)) player.y = newY;
}

function updateInvulnerability(){
  if(player.invul > 0) player.invul--;
}

function updateEnvironmentSystem(){ updateShake(); }
function updateShake(){ if(shake > 0) shake--; }

function updateArrows(){
  for(let i = arrows.length - 1; i >= 0; i--){
    const a = arrows[i];
    a.x += a.dx;
    a.y += a.dy;
    a.life--;

    const tx = Math.floor(a.x / tileSize);
    const ty = Math.floor(a.y / tileSize);
    if(!map[ty] || map[ty][tx] === 1){
      arrows.splice(i,1);
      continue;
    }

    const px = player.x, py = player.y;
    const dxp = a.x - px;
    const dyp = a.y - py;
    const rr = (player.radius + 4);
    if(dxp*dxp + dyp*dyp < rr*rr){
      const dx = px - a.x;
      const dy = py - a.y;
      const len = Math.hypot(dx, dy) || 1;
      damagePlayer(a.damage, (dx/len)*14, (dy/len)*14);
      arrows.splice(i,1);
      continue;
    }

    if(a.life <= 0){
      arrows.splice(i,1);
      continue;
    }
  }
}

/* ===== ë ˆë²¨ì—… ===== */
function levelUpSound(){
  let o = audioCtx.createOscillator();
  let g = audioCtx.createGain();

  o.type = "triangle";
  o.frequency.setValueAtTime(400, audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.3);

  g.gain.setValueAtTime(0.3, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

  o.connect(g);
  g.connect(audioCtx.destination);

  o.start();
  o.stop(audioCtx.currentTime + 0.3);
}


function checkLevelUp(){
  if(xp >= xpToNext){

    xp -= xpToNext;
    level++;

    // ë‹¤ìŒ ë ˆë²¨ ìš”êµ¬ XP (PoE ëŠë‚Œ ê³¡ì„ )
    xpToNext = Math.floor(100 + level * level * 20);

    // ìŠ¤íƒ¯ ì¦ê°€
    player.baseMaxHp += 12;
updateBuffs(player);       // maxHp ê°±ì‹ 
player.hp = player.maxHp;  // ë ˆë²¨ì—… í’€í/ ì¼ë‹¨ ìœ ì§€
 // ë ˆë²¨ì—… í’€í ìœ ì§€í•˜ê³  ì‹¶ìœ¼ë©´ ì´ ì¤„ë§Œ ë‚¨ê²¨ë„ ë¨
    baseDamageBase *= 1.08;
ultiDamageBase *= 1.1;
recalcFromGear();

    player.levelGlow = 60;

    for(let i=0;i<60;i++){
      levelParticles.push({
        ox:(Math.random()-0.5)*40,
        oy:-40+(Math.random()-0.5)*10,
        vx:(Math.random()-0.5)*2,
        vy:Math.random()*3+2,
        life:60
      });
    }

    levelUpSound();
  }
}
// âœ… ë„¤ê°€ ì •í•œ ê¸°ë³¸ ë²”ìœ„
const BASE_MELEE_RANGE = 40;
const BASE_ULTI_AOE    = 40;

// âœ… ë„¤ê°€ ì •í•œ ê¸°ë³¸ ë²”ìœ„
const BASE_MELEE_RANGE = 40;
const BASE_ULTI_AOE    = 40;

// âœ… rangeMul í•˜ë‚˜ë§Œ ì‚¬ìš©
function getMeleeRange(){
  const b = player.buffs || defaultBuffStats();
  return BASE_MELEE_RANGE * (b.rangeMul ?? 1);
}
function getUltiAoeRadius(){
  const b = player.buffs || defaultBuffStats();
  return BASE_ULTI_AOE * (b.rangeMul ?? 1);
}
/* ===== ê³µê²© ===== */
function checkHit(){
  const range = getMeleeRange(); // âœ… ë³€ê²½
  const hitLimit = 12;
  let hitDone = 0;

  for(let i=0;i<enemies.length;i++){
    const e = enemies[i];

    const dx = e.x - player.x;
    const dy = e.y - player.y;

    const r = range + e.radius;
    if(dx*dx + dy*dy > r*r) continue;

    if(player.dir === "up" && dy >= 0) continue;
    if(player.dir === "down" && dy <= 0) continue;
    if(player.dir === "right" && dx <= 0) continue;
    if(player.dir === "left" && dx >= 0) continue;

    hitDone++;
    if(hitDone > hitLimit) break;

    const len = Math.hypot(dx, dy) || 1;
    const nx = dx / len;
    const ny = dy / len;

    let dealt = baseDamage * (player.buffs?.dmgMul ?? 1);
    const bossInvul = (e.type === "boss" && e.invul > 0);

    if(e.invul <= 0){
      e.hp -= dealt;
    }
   emitEvent("hit", { enemy: e, dealt });

    const heal = dealt * 0.05;
    player.hp = Math.min(player.maxHp, player.hp + heal);

    if(Math.random() < 0.2 && player.kiOrbs < player.maxOrbs){
      player.kiOrbs++;
    }

    if(bossInvul){
      spawnHitBlood(e.x, e.y, 14);
    }else{
      e.stun = 15;
      let ex = e.x + nx*18;
      let ey = e.y + ny*18;
      if(canEnemyMoveTo(e, ex, e.y)) e.x = ex;
      if(canEnemyMoveTo(e, e.x, ey)) e.y = ey;
    }

    if(bossInvul) thudSound();
    else hitSound();

    shake = 12;

    if(particles.length < 220){
      particles.push({
        x: e.x, y: e.y,
        vx: nx*4 + (Math.random()-0.5)*4,
        vy: ny*4 + (Math.random()-0.5)*4,
        life: 30
      });
    }

    if(e.hp <= 0){
      if(e.type === "boss"){
  startBossDeath(e);
  // ë³´ìŠ¤ëŠ” ì—¬ê¸°ì„œ killCount ì²˜ë¦¬ ì•ˆ í•  ê±°ë©´ return/continueë¡œ ë¹ ì ¸ë„ ë¨
  // ì¼ë‹¨ì€ ì•„ë˜ ì¼ë°˜ ì£½ìŒ ë¡œì§ì„ íƒ€ì§€ ì•Šê²Œ ë§‰ì:
  continue;
}emitEvent("kill", { enemy: e, x: e.x, y: e.y, type: e.type });
    // âœ… ë“œë ìƒì„±
      spawnLoot(e.x, e.y, "normal");
      giveXP(e);
      killCount++;
      //checkLevelUp();

      player.hp = Math.min(player.maxHp, player.hp + 1);

      if(bloodPools.length < 140){
        bloodPools.push({
          x: e.x, y: e.y,
          size: 10 + Math.random()*6,
          life: 600
        });
      }

      slowMotion = 6;

      if(player.kiOrbs < player.maxOrbs){
        player.kiOrbs++;
      }
    }
  }

  enemies = enemies.filter(e => (e.hp > 0) || (e.type === "boss" && e.dead && e.deathTimer > 0));
  packs.forEach(pack=>{
    pack.enemies = pack.enemies.filter(e=>e.hp>0);
  });
}

function updateBlood(){
  for(let i = bloodParticles.length - 1; i >= 0; i--){
    const p = bloodParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.25;
    p.life--;
    if(p.life <= 0) bloodParticles.splice(i,1);
  }
  if(bloodParticles.length > 260){
    bloodParticles.splice(0, bloodParticles.length - 260);
  }
}

function drawBlood(){
  if(bloodParticles.length === 0) return;

  ctx.save();
  ctx.fillStyle = "#8b0000";
  ctx.beginPath();

  for(let i=0;i<bloodParticles.length;i++){
    const p = bloodParticles[i];
    const a = p.life / 30;
    if(a > 0.66) ctx.globalAlpha = 0.9;
    else if(a > 0.33) ctx.globalAlpha = 0.6;
    else ctx.globalAlpha = 0.35;

    ctx.fillRect(p.x - p.size*0.5, p.y - p.size*0.5, p.size, p.size);
  }
  ctx.restore();
}

/* ===== ë Œë” ===== */
function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";
  ctx.filter = "none";

  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  let camX = player.x - canvas.width/2;
  let camY = player.y - canvas.height/2;
// âœ… shakeê°€ í´ìˆ˜ë¡ í”ë“¤ë¦¼ í­ ì¦ê°€ (ë³´ìŠ¤ ì‚¬ë§ ì—°ì¶œì´ í›¨ì”¬ ê°•í•´ì§)
let amp = shake ? (6 + shake * 0.45) : 0;   // ìˆ«ì ì¡°ì ˆë¡œ ë” ê³¼ê²©/ìˆœí•˜ê²Œ ê°€ëŠ¥
let sx = shake ? (Math.random()-0.5) * amp : 0;
let sy = shake ? (Math.random()-0.5) * amp : 0;

  ctx.save();
  ctx.translate(-camX+sx, -camY+sy);

  for(let y = 0; y < map.length; y++){
    for(let x = 0; x < map[y].length; x++){
      let tile = map[y][x];
      if(tile === 0) ctx.fillStyle = "#222";
      if(tile === 1) ctx.fillStyle = "#555";
      if(tile === 2) ctx.fillStyle = "blue";
      if(tile === 3) ctx.fillStyle = "red";
      ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
    }
  }

  ctx.fillStyle = "#550000";
  for(let i=0;i<bloodPools.length;i++){
    const b = bloodPools[i];
    const a = b.life / 600;
    if(a <= 0.05) continue;
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  fireZones.forEach(f=>{
    ctx.save();
    for(let i=0;i<6;i++){
      let flameHeight = 10 + Math.sin(frameCount*0.2 + i)*6;
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "orange";
      ctx.beginPath();
      ctx.moveTo(f.x - 6 + i*2, f.y);
      ctx.lineTo(f.x - 3 + i*2, f.y - flameHeight);
      ctx.lineTo(f.x + i*2, f.y);
      ctx.fill();
    }
    ctx.restore();
  });

  ctx.fillStyle = "red";
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    ctx.fillRect(p.x, p.y, 3, 3);
  }
  // âœ… í¬íƒˆ(ì›”ë“œ)
  drawPortal();
  // âœ… ë°”ë‹¥ ë“œë ì•„ì´í…œ
  drawLoots();

  drawBlood();
  enemies.forEach(e=>drawEnemy(e));

  levelParticles.forEach(p=>{
    ctx.fillStyle = "gold";
    ctx.fillRect(player.x + p.ox, player.y + p.oy, 4, 4);
  });

  arrows.forEach(a=>{
    ctx.fillStyle = "white";
    ctx.fillRect(a.x-2, a.y-2, 4, 4);
  });

  ctx.restore();

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  drawPlayer(canvas.width/2, canvas.height/2);
  drawUI();

  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";
}

/* ===== í”Œë ˆì´ì–´ ===== */
function drawPlayer(x,y){
  if(player.levelGlow > 0){
    ctx.shadowColor = "gold";
    ctx.shadowBlur = player.levelGlow * 0.5;
  }

  ctx.fillStyle="#880000";
  ctx.fillRect(x-10,y-12,20,22);

  ctx.fillStyle="#aa0000";
  ctx.fillRect(x-7,y-20,14,8);

  ctx.fillStyle="#ffffcc";
  ctx.fillRect(x-8,y-26,4,8);
  ctx.fillRect(x+4,y-26,4,8);

  ctx.fillStyle = "#fff";
  ctx.fillRect(x-3,y-14,2,2);
  ctx.fillRect(x+1,y-14,2,2);

  ctx.shadowBlur = 0;

  if(player.ultiActive){
    ctx.save();
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 25;
    ctx.fillStyle = "#ffaa00";
    ctx.fillRect(x-3,y-14,2,2);
    ctx.fillRect(x+1,y-14,2,2);
    ctx.restore();
  }

  drawSword(x,y);
}

function drawSword(x, y){
  ctx.save();
  ctx.translate(x, y);

  var offsetX = 0;
  var offsetY = 0;
  var angle = 0;
  var t = attackFrame / 8;

  if (player.dir === "right") { offsetX = 18; if (attacking) angle = 1.5 * t; }
  else if (player.dir === "left") { offsetX = -18; if (attacking) angle = -1.5 * t; }
  else if (player.dir === "up") { offsetY = -18; if (attacking) offsetY -= 25 * t; }
  else if (player.dir === "down") { offsetY = 6; angle = Math.PI; if (attacking) offsetY += 25 * t; }

  ctx.translate(offsetX, offsetY);
  ctx.rotate(angle);
  drawSwordShape(ctx);
  ctx.restore();
}

function drawSwordShape(c){
  c.fillStyle = "#552200";
  c.fillRect(-2, 6, 4, 8);

  c.fillStyle = "#bbbbbb";
  c.fillRect(-8, 6, 16, 3);

  c.fillStyle = "#dddddd";
  c.fillRect(-2, -20, 4, 26);

  c.beginPath();
  c.moveTo(-2, -20);
  c.lineTo(0, -32);
  c.lineTo(2, -20);
  c.fill();
}

/* ===== ëª¬ìŠ¤í„° ===== */
function drawEnemy(e){
  if(e.type === "boss"){
    if(e.dead){
  const t = (e.deathTimer / e.deathMax); // 1 -> 0
  ctx.save();
  ctx.globalAlpha = Math.max(0, t);

  // ì»¤ì§€ëŠ” ë¶‰ì€ ì›(í­ë°œ ì”ê´‘)
  ctx.fillStyle = "rgba(255,60,60,0.25)";
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.radius + (1-t)*35, 0, Math.PI*2);
  ctx.fill();

  // ëª¸í†µì€ ì ì  ì‚¬ë¼ì§(ê°„ë‹¨)
  ctx.fillStyle = "#777777";
  ctx.fillRect(e.x-20, e.y-25, 40, 50);

  // ë¶‰ì€ ëˆˆ ê¹œë¹¡
  if(Math.floor(frameCount/3)%2===0){
    ctx.fillStyle = "rgba(255,0,0,0.8)";
    ctx.fillRect(e.x-6, e.y-15, 4,4);
    ctx.fillRect(e.x+2, e.y-15, 4,4);
  }

  ctx.restore();
  return;
}
    if(e.invul > 0){
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius + 10, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    ctx.fillStyle = "#777777";
    ctx.fillRect(e.x-20, e.y-25, 40, 50);

    ctx.fillStyle = "#999999";
    ctx.fillRect(e.x-15, e.y-35, 30, 15);

    ctx.fillStyle = "red";
    ctx.fillRect(e.x-6, e.y-15, 4,4);
    ctx.fillRect(e.x+2, e.y-15, 4,4);

    if(!e.swordPulled){
      ctx.save();
      ctx.translate(e.x+5, e.y-5);
      ctx.rotate(0.7);
      drawSwordShape(ctx);
      ctx.restore();
    }else{
      ctx.save();
      ctx.translate(e.x+28, e.y);
      ctx.rotate(0.2);
      drawSwordShape(ctx);
      ctx.restore();
    }
    return;
  }
  if(e.isLeader){
    ctx.fillStyle = "#ffd000";
    ctx.fillRect(e.x-6, e.y-24, 12, 3);
    ctx.fillRect(e.x-4, e.y-28, 3, 4);
    ctx.fillRect(e.x+1, e.y-28, 3, 4);
  }
  if(e.isElite){
    ctx.fillStyle = (e.eliteColor === "yellow") ? "#ffcc00" : "#00aaff";
  }else if(e.type === "archer"){
    ctx.fillStyle = "#cccccc";
  }else if(e.type === "mage"){
    ctx.fillStyle = "#550088";
  }else{
    ctx.fillStyle = "#006600";
  }
// âœ… ë¦¬ë” ì˜¤ë¼ ë²„í”„(leader) ë°›ëŠ” ì¤‘ì´ë©´ ë¹¨ê°„ ì˜¤ë¡œë¼
if(e.activeBuffs && e.activeBuffs.some(b => b.key === "damage|leader|mul" || b.key === "atkSpeed|leader|mul")){
  const pulse = 0.45 + 0.25*Math.sin(frameCount*0.2);
  ctx.save();
  ctx.globalAlpha = 0.25 + pulse;
  ctx.fillStyle = "rgba(255,0,0,0.35)";
  ctx.beginPath();
  ctx.arc(e.x, e.y, e.radius + 12 + pulse*6, 0, Math.PI*2);
  ctx.fill();
  ctx.restore();
}
  ctx.fillRect(e.x-10,e.y-12,20,22);

  if(e.type === "archer") ctx.fillStyle = "#dddddd";
  else if(e.type === "mage") ctx.fillStyle = "#550088";
  else ctx.fillStyle = "#00aa00";
  ctx.fillRect(e.x-7,e.y-20,14,8);

  ctx.fillStyle="red";
  ctx.fillRect(e.x-4,e.y-14,3,3);
  ctx.fillRect(e.x+1,e.y-14,3,3);

  if(e.attackFrame > 0){
    let t = (25 - e.attackFrame) / 25;
    let swingRange = 1.4;
    let angle = (t - 0.5) * 2 * swingRange * e.swingDir;

    ctx.save();
    ctx.translate(e.x, e.y-5);
    ctx.rotate(angle);

    if(e.type === "archer") ctx.fillStyle = "#dddddd";
    else ctx.fillStyle = "#006600";

    ctx.fillRect(-20,-3,40,6);
    ctx.restore();
  }
}

/* ===== UI ===== */
function drawUI(){
  drawTextUI();
  drawXPBar();   // ğŸ‘ˆ ì¶”ê°€
  drawOrbUI();
  drawHpOrb();
  drawBossHpBar();
  drawMiniMap();
 ctx.font = "12px Arial";
ctx.fillStyle = "#ccc";

let startY = 140;
for(let i=0;i<ownedItems.length && i<8;i++){
  ctx.fillText("â€¢ " + ownedItems[i], 20, startY + i*16);
}
}
  
function drawXPBar(){

  const barW = canvas.width * 0.6;
  const barH = 10;

  const x = canvas.width/2 - barW/2;
  const y = canvas.height - 20;

  const percent = xp / xpToNext;

  ctx.save();

  // ë°°ê²½
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(x, y, barW, barH);

  // XP
  ctx.fillStyle = "#33ccff";
  ctx.fillRect(x, y, barW * percent, barH);

  // í…Œë‘ë¦¬
  ctx.strokeStyle = "rgba(255,255,255,0.3)";
  ctx.strokeRect(x, y, barW, barH);

  ctx.restore();
}
function drawMiniMap(){

  const w = 60;
  const h = 60;
  const margin = 12;

  const x0 = canvas.width - w - margin;
  const y0 = margin;

  const radarRange = 700;
  const scale = w / (radarRange * 2);

  const cx = x0 + w/2;
  const cy = y0 + h/2;

  ctx.save();

  // ===== ë°°ê²½ =====
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = "#000";
  ctx.fillRect(x0, y0, w, h);

  // âœ… ì—¬ê¸°ì„œ ë¯¸ë‹ˆë§µ ì˜ì—­ìœ¼ë¡œ "í´ë¦½" (ë°–ìœ¼ë¡œ ëª» ë‚˜ê°€ê²Œ)
  ctx.beginPath();
  ctx.rect(x0+1, y0+1, w-2, h-2);   // í…Œë‘ë¦¬ 1px ì•ˆìª½
  ctx.clip();

  // ===== ë²½ ì–‡ì€ ì„  í‘œí˜„ =====
  ctx.globalAlpha = 0.7;
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 1;

  const minTX = Math.max(0, Math.floor((player.x - radarRange) / tileSize));
  const maxTX = Math.min(mapSize-1, Math.floor((player.x + radarRange) / tileSize));
  const minTY = Math.max(0, Math.floor((player.y - radarRange) / tileSize));
  const maxTY = Math.min(mapSize-1, Math.floor((player.y + radarRange) / tileSize));

  for(let ty=minTY; ty<=maxTY; ty++){
    for(let tx=minTX; tx<=maxTX; tx++){

      if(map[ty][tx] !== 1) continue;

      const wx = tx * tileSize;
      const wy = ty * tileSize;

      const dx = wx - player.x;
      const dy = wy - player.y;

      const mx = cx + dx * scale;
      const my = cy + dy * scale;

      const size = tileSize * scale;

      // ğŸ”¥ strokeRectëŠ” ë°”ê¹¥ìœ¼ë¡œ ì‚´ì§ ë‚˜ê°€ë„ clipì´ ì˜ë¼ì¤Œ
      ctx.strokeRect(mx, my, size, size);
    }
  }

  // ===== ë³´ìŠ¤ë§Œ í‘œì‹œ =====
  const boss = enemies.find(e => e.type === "boss");
  if(boss){
    const dx = boss.x - player.x;
    const dy = boss.y - player.y;

    if(dx*dx + dy*dy <= radarRange*radarRange){
      const mx = cx + dx * scale;
      const my = cy + dy * scale;

      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.fillRect(mx-3, my-3, 6, 6);
    }
  }
  // ===== ëª¬ìŠ¤í„° í‘œì‹œ(ë¯¸ë‹ˆë§µ) =====
  ctx.globalAlpha = 0.95;

  for(const e of enemies){
    if(e.hp <= 0) continue;
    if(e.type === "boss") continue; // ë³´ìŠ¤ëŠ” ì•„ë˜ì—ì„œ ë”°ë¡œ

    const dx = e.x - player.x;
    const dy = e.y - player.y;
    if(dx*dx + dy*dy > radarRange*radarRange) continue;

    const mx = cx + dx * scale;
    const my = cy + dy * scale;

    // íƒ€ì…ë³„ ìƒ‰(ì›í•˜ë©´ ë°”ê¿”ë„ ë¨)
    if(e.type === "mage") ctx.fillStyle = "#aa55ff";
    else if(e.type === "archer") ctx.fillStyle = "#dddddd";
    else ctx.fillStyle = "#00ff66";

    ctx.fillRect(mx-1.5, my-1.5, 3, 3);
  }
  // ===== í”Œë ˆì´ì–´ =====
  ctx.globalAlpha = 1;
  ctx.fillStyle = "#ff4444";
  ctx.fillRect(cx-2, cy-2, 4, 4);

  // âœ… í…Œë‘ë¦¬(í´ë¦½ ë°–ì—ì„œ ë‹¤ì‹œ ê·¸ë¦¬ê¸° ìœ„í•´ restore ì „ì— ê·¸ë¦¬ë©´ ê¹”ë”)
  ctx.restore();

  // í…Œë‘ë¦¬ ë‹¤ì‹œ ê·¸ë¦¬ê¸°
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "#444";
  ctx.lineWidth = 2;
  ctx.strokeRect(x0+1, y0+1, w-2, h-2);
  ctx.restore();
}
function drawTextUI(){
  ctx.save();
  ctx.textAlign = "left";
  ctx.font = "bold 18px Arial";
  ctx.fillStyle = "white";
  ctx.strokeStyle = "black";
  ctx.lineWidth = 4;

  ctx.strokeText("Level: " + level, 20, 55);
  ctx.fillText("Level: " + level, 20, 55);

  "XP: " + xp + " / " + xpToNext

  ctx.strokeText("TIER: " + mapTier, 20, 105);
  ctx.fillText("TIER: " + mapTier, 20, 105);

  
  if(portal.active){
    ctx.strokeText("PORTAL OPEN!", 20, 155);
    ctx.fillText("PORTAL OPEN!", 20, 155);
  }

  ctx.restore();
}

function drawOrbUI(){

  const btnRect = document.getElementById("attackBtn").getBoundingClientRect();

  // ê³µê²©ë²„íŠ¼ ì¤‘ì‹¬(í™”ë©´ì¢Œí‘œ)
  const centerScreenX = btnRect.left + btnRect.width * 0.5;
  const centerScreenY = btnRect.top  + btnRect.height * 0.5;

  // í™”ë©´ì¢Œí‘œ -> ìº”ë²„ìŠ¤ì¢Œí‘œ (ìº”ë²„ìŠ¤ëŠ” uiHeight ìœ„ê¹Œì§€ë§Œ)
  let cx = centerScreenX;
  let cy = centerScreenY - uiHeight;

  // ì•ˆì „ ë³´ì •(ìº”ë²„ìŠ¤ ë°– ë°©ì§€)
  cx = Math.max(60, Math.min(canvas.width - 60, cx));
  cy = Math.max(60, Math.min(canvas.height - 60, cy));

  const orbR = 10;                 // ì™¸ê³½ ê¸°êµ¬ìŠ¬ ë°˜ì§€ë¦„
  const ringR = 34;                // ì˜¤ê°í˜• ë°˜ì§€ë¦„(í¼ì§)
  const startAngle = -Math.PI/2;   // ë§¨ ìœ„ ê¼­ì§€ì ë¶€í„°

  // âœ… ì¤‘ì•™(ê¶ê·¹ê¸°) ë²„íŠ¼
  const centerR = 24;
  const ready = (player.kiOrbs >= 1 && enemies.length > 0 && !player.ultiActive);

  // ì¤‘ì•™ ë²„íŠ¼ ìƒíƒœë¥¼ ì…ë ¥ìš©ìœ¼ë¡œ ì €ì¥
  orbUIState.cx = cx;
  orbUIState.cy = cy;
  orbUIState.centerR = centerR;
  orbUIState.ready = ready;

  ctx.save();

  // --- ì™¸ê³½ ê¸°êµ¬ìŠ¬(ì˜¤ê°í˜•) ---
  for(let i=0;i<player.maxOrbs;i++){
    const a = startAngle + (i * (Math.PI * 2 / player.maxOrbs));
    const x = cx + Math.cos(a) * ringR;
    const y = cy + Math.sin(a) * ringR;

    ctx.beginPath();
    ctx.arc(x, y, orbR, 0, Math.PI*2);

    if(orbFlash > 0){
      ctx.fillStyle = "#00ff88";
      ctx.shadowColor = "#00ff88";
      ctx.shadowBlur = 35;
    }
    else if(i < player.kiOrbs){
      ctx.fillStyle = "#00ff55";
      ctx.shadowColor = "#00ff55";
      ctx.shadowBlur = 15;
    }
    else{
      ctx.fillStyle = "#002211";
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
    }

    ctx.fill();
  }

  // --- ì¤‘ì•™ ê¶ê·¹ê¸° ë²„íŠ¼(íŒŒë€ êµ¬ìŠ¬) ---
  ctx.shadowBlur = ready ? 25 : 10;
  ctx.shadowColor = ready ? "rgba(120,180,255,0.95)" : "rgba(120,180,255,0.4)";
  ctx.fillStyle = ready ? "rgba(40,120,255,0.95)" : "rgba(40,120,255,0.45)";
  ctx.beginPath();
  ctx.arc(cx, cy, centerR, 0, Math.PI*2);
  ctx.fill();

  // í…Œë‘ë¦¬
  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(170,210,255,0.75)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(cx, cy, centerR+1, 0, Math.PI*2);
  ctx.stroke();

  // U ê¸€ì
  ctx.globalAlpha = 0.95;
  ctx.fillStyle = "white";
  ctx.font = "bold 18px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("U", cx, cy+1);

  ctx.restore();
}
function drawHpOrb(){

  // âœ… UI ë†’ì´(ìº”ë²„ìŠ¤ëŠ” UI ì œì™¸ ë†’ì´ì´ë¯€ë¡œ í™”ë©´ì¢Œí‘œ -> ìº”ë²„ìŠ¤ì¢Œí‘œ ë³€í™˜ì— í•„ìš”)
  const uiH = ui.getBoundingClientRect().height || 120;

  // âœ… XëŠ” ì¡°ì´ìŠ¤í‹±(movePad) ê¸°ì¤€
  const padRect = document.getElementById("movePad").getBoundingClientRect();
  let x = padRect.left + padRect.width * 0.5;

  // âœ… YëŠ” "ê¸°(ì˜¤ë¸Œ) ì¤‘ì‹¬" = ê³µê²©ë²„íŠ¼(attackBtn) ì¤‘ì‹¬ê³¼ ë™ì¼í•˜ê²Œ ë§ì¶¤
  const btnRect = document.getElementById("attackBtn").getBoundingClientRect();
  let y = (btnRect.top + btnRect.height * 0.5) - uiH;

  // í™”ë©´ ë°– ë³´ì •
  x = Math.max(40, Math.min(canvas.width - 40, x));
  y = Math.max(40, Math.min(canvas.height - 40, y));

  ctx.save();

  let radius = 25;
  hpWaveOffset += 0.07;

  let hpPercent = player.hp / player.maxHp;
  let liquidHeight = radius * 2 * hpPercent;
  let topY = y + radius - liquidHeight;

  // ===== ê³ ë”• ì™¸ê³½ ë©”íƒˆ ë§ =====
  let metal = ctx.createRadialGradient(x, y, radius-10, x, y, radius+12);
  metal.addColorStop(0, "#2a0000");
  metal.addColorStop(0.5, "#550000");
  metal.addColorStop(1, "#110000");

  ctx.beginPath();
  ctx.arc(x, y, radius+10, 0, Math.PI*2);
  ctx.fillStyle = metal;
  ctx.fill();

  ctx.lineWidth = 4;
  ctx.strokeStyle = "#000";
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(x, y, radius+6, 0, Math.PI*2);
  ctx.strokeStyle = "#aa0000";
  ctx.lineWidth = 2;
  ctx.stroke();

  // ===== ë‚´ë¶€ í´ë¦¬í•‘ =====
  ctx.save();
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI*2);
  ctx.clip();

  // ë‚´ë¶€ ì–´ë‘ 
  let innerShadow = ctx.createRadialGradient(x, y+15, 10, x, y, radius);
  innerShadow.addColorStop(0, "#330000");
  innerShadow.addColorStop(1, "#000000");
  ctx.fillStyle = innerShadow;
  ctx.fillRect(x-radius, y-radius, radius*2, radius*2);

  // ===== ì•¡ì²´ =====
  ctx.beginPath();
  ctx.moveTo(x-radius, y+radius);
  for(let i=0;i<=radius*2;i++){
    let wave = Math.sin(i*0.12 + hpWaveOffset) * 4;
    ctx.lineTo(x-radius+i, topY + wave);
  }
  ctx.lineTo(x+radius, y+radius);
  ctx.closePath();

  let blood = ctx.createLinearGradient(0, topY, 0, y+radius);
  blood.addColorStop(0, "#ff2a2a");
  blood.addColorStop(1, "#8b0000");
  ctx.fillStyle = blood;
  ctx.fill();

  // ===== ìœ ë¦¬ ë°˜ì‚¬ê´‘ =====
  ctx.beginPath();
  ctx.arc(x-15, y-20, 18, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.25)";
  ctx.fill();

  let glass = ctx.createRadialGradient(x-10, y-15, 5, x, y, radius);
  glass.addColorStop(0, "rgba(255,255,255,0.25)");
  glass.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = glass;
  ctx.fillRect(x-radius, y-radius, radius*2, radius*2);

  // ì €ì²´ë ¥ ê¹œë¹¡ì„
  if(hpPercent < 0.3){
    if(Math.floor(Date.now()/200)%2===0){
      ctx.beginPath();
      ctx.arc(x, y, radius+14, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,0,0,0.25)";
      ctx.fill();
    }
  }

  // ì²´ë ¥ ìˆ«ì
  ctx.fillStyle = "white";
  ctx.font = "bold 16px Arial";
  ctx.textAlign = "center";
  ctx.fillText(Math.floor(player.hp), x, y+6);

  ctx.restore(); // clip ë³µêµ¬
  ctx.restore(); // ì „ì²´ ë³µêµ¬
}

function drawBossHpBar(){
  const boss = enemies.find(e => e.type === "boss");
  if(!boss) return;

  // ===== ì›”ë“œì¢Œí‘œ -> í™”ë©´ì¢Œí‘œ ë³€í™˜ (ì¹´ë©”ë¼/ì‰ì´í¬ ë°˜ì˜) =====
  let camX = player.x - canvas.width/2;
  let camY = player.y - canvas.height/2;

  // draw()ì—ì„œ shakeë¡œ í”ë“¤ë¦¬ë‹ˆê¹Œ, ì—¬ê¸°ì„  ê°„ë‹¨íˆ shakeë§Œí¼ì€ ë°˜ì˜ ì•ˆí•´ë„ ìì—°ìŠ¤ëŸ½ê¸´ í•œë°
  // ì™„ì „ ì¼ì¹˜ ì›í•˜ë©´ draw()ì—ì„œ ì“´ sx,syë¥¼ ì „ì—­ìœ¼ë¡œ ë¹¼ì•¼ í•¨.
  // ì§€ê¸ˆì€ ì•ˆì •ì ìœ¼ë¡œ "ë¨¸ë¦¬ ìœ„" ê³ ì • ëŠë‚Œì´ ë” ì¢‹ì•„ì„œ shakeëŠ” ì œì™¸.

  const screenX = boss.x - camX;
  const screenY = boss.y - camY;

  // ìº”ë²„ìŠ¤ ë°–ì´ë©´ ì•ˆ ê·¸ë¦¼ (ì„±ëŠ¥/ê¹”ë”)
  if(screenX < -100 || screenX > canvas.width + 100 || screenY < -100 || screenY > canvas.height + 100) return;

  // ===== ì‘ê³  ì–‡ì€ ì²´ë ¥ë°” =====
  const barW = 70;     // âœ… ì‘ê²Œ
  const barH = 7;      // âœ… ì–‡ê²Œ
  const x = screenX - barW/2;
  const y = screenY - boss.radius - 18; // âœ… ë¨¸ë¦¬ ìœ„

  let percent = boss.hp / boss.maxHp;
  percent = Math.max(0, Math.min(1, percent));

  ctx.save();
  ctx.globalAlpha = 0.9;

  // ë°°ê²½
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x, y, barW, barH);

  // ì²´ë ¥
  ctx.fillStyle = "#ff4444";
  ctx.fillRect(x, y, barW * percent, barH);

  // í…Œë‘ë¦¬ ì–‡ê²Œ
  ctx.globalAlpha = 0.85;
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, barW - 1, barH - 1);

  // ìˆ«ì(ì„ íƒ) - ë„ˆë¬´ ì‘ê²Œ ì›í•˜ë©´ ì§€ì›Œë„ ë¨
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "10px Arial";
  ctx.textAlign = "center";
  ctx.fillText(Math.ceil(boss.hp), screenX, y - 2);

  ctx.restore();
}

function drawGameOver(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle="rgba(0,0,0,0.6)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="white";
  ctx.font="bold 40px Arial";
  ctx.textAlign="center";
  ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);

  ctx.font="bold 18px Arial";
  ctx.fillText("Tap to Restart", canvas.width/2, canvas.height/2 + 40);
}

function tryUltimate(){
  // âœ… ì´ë¯¸ ê¶ê·¹ê¸° ì¤‘ì´ë©´ ë§‰ê¸°
  if(player.ultiActive) return;

  // âœ… ê¸° 1ê°œ ì´ìƒ + ì  ì¡´ì¬
  if(player.kiOrbs >= 1 && enemies.length > 0){

    // âœ… ê¸° 1ê°œë§Œ ì†Œëª¨
    player.kiOrbs -= 1;

    // âœ… "í•œ ë²ˆë§Œ" ë°œë™í•˜ë„ë¡ ì¹´ìš´íŠ¸ ì„¸íŒ…
    player.ultiActive = true;
    player.ultiTimer = 0;
    player.ultiCount = 0;

    // ë°”ë¡œ 1íƒ€ ì‹¤í–‰
    performUltimateStrike();

    // ì¦‰ì‹œ ì¢…ë£Œ(ì—°íƒ€/íƒ€ì´ë¨¸ êµ¬ì¡° ì•ˆ íƒ€ê²Œ)
    endUltimate();
  }
}

function handleUltimateOrbPress(clientX, clientY){
  // í™”ë©´ì¢Œí‘œ -> ìº”ë²„ìŠ¤ì¢Œí‘œ ë³€í™˜
  const rect = canvas.getBoundingClientRect();
  const tx = clientX - rect.left;
  const ty = clientY - rect.top;

  // íŒŒë€ êµ¬ìŠ¬(ì¤‘ì•™) ëˆŒë €ëŠ”ì§€ íŒì •
  const dx = tx - orbUIState.cx;
  const dy = ty - orbUIState.cy;
  const r = orbUIState.centerR;

  if(dx*dx + dy*dy <= r*r){
    tryUltimate();
    return true;
  }
  return false;
}

canvas.addEventListener("touchstart", (e)=>{
  if(gameOver){ resetGame(); return; }
  if(!e.touches || !e.touches[0]) return;

  // âœ… 1) ê·¼ì²˜ ë“œë ìˆìœ¼ë©´ ì¤ê¸°(ì„ íƒì°½)
  const near = getNearbyLoot();
  if(near){
    openLootChoice(near);
    e.preventDefault();
    return;
  }

  // âœ… 2) ì•„ë‹ˆë©´ ê¶ê·¹ê¸° êµ¬ìŠ¬ í„°ì¹˜ íŒì •
  if(handleUltimateOrbPress(e.touches[0].clientX, e.touches[0].clientY)){
    e.preventDefault();
  }
},{passive:false});
  // íŒŒë€êµ¬ìŠ¬(ì¤‘ì•™) í„°ì¹˜ë©´ ê¶ê·¹ê¸°
  

canvas.addEventListener("mousedown", (e)=>{
  if(gameOver){ resetGame(); return; }

  const near = getNearbyLoot();
  if(near){ openLootChoice(near); return; }

  handleUltimateOrbPress(e.clientX, e.clientY);
});
let lastErr = null;

function drawRuntimeError(e){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle="rgba(0,0,0,0.75)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#fff";
  ctx.font="bold 16px Arial";
  ctx.textAlign="center";
  ctx.fillText("RUNTIME ERROR (F12 Console í™•ì¸)", canvas.width/2, canvas.height/2 - 10);
  ctx.font="14px Arial";
  ctx.fillText(String(e && e.message ? e.message : e), canvas.width/2, canvas.height/2 + 18);
}

function loop(){
  try{
    if(!gameOver){
      update();
      draw();
    }else{
      drawGameOver();
    }
    lastErr = null;
  }catch(e){
    console.error(e);
    lastErr = e;
    drawRuntimeError(e);
  }finally{
    requestAnimationFrame(loop);
  }
}

/* ===== ë¦¬ì…‹ ===== */
function resetGame(){
  mapTier = 1;

  if(audioUnlocked && !bgmOsc){
    bgmOsc = startBGM();
  }

  // í”Œë ˆì´ì–´ ê¸°ë³¸ê°’
  player.baseMaxHp = 100;
player.maxHp = 100;
player.hp = 100;

player.baseArmor = 0;
player.armor = 0;
  player.invul = 0;
  player.kiOrbs = 0;
  player.ultiActive = false;
  player.ultiCount = 0;
  player.ultiTimer = 0;
  player.levelGlow = 0;

  // ì§„í–‰/ë ˆë²¨
  killCount = 0;
  level = 1;
  killsAtLevelStart = 0;
  killsForNextLevel = 20;
  baseDamageBase = 20;
ultiDamageBase = 40;

// gear ì´ˆê¸°í™”
player.gear = {
  dmgMul: 1,
  ultiMul: 1,
  spdMul: 1,
  atkSpdMul: 1,
  rangeMul: 1,
  armorAdd: 0,
  maxHpAdd: 0,
  hpRegen: 0
};

recalcFromGear();

  // íƒ€ì´ë¨¸/ìƒíƒœ
  shake = 0;
  slowMotion = 0;
  gameOver = false;
  document.getElementById("ui").style.display = "flex";

  // âœ… ë§µí•‘ ì‹œìŠ¤í…œìœ¼ë¡œ â€œí•œ íŒ ì‹œì‘â€ í†µì¼
  startNewMap(1);

  resize();
}

/* ===== ê³µê²© ì•„ì´ì½˜ ===== */
const iconCanvas = document.getElementById("attackIcon");
const iconCtx = iconCanvas.getContext("2d");
iconCtx.clearRect(0, 0, 60, 60);
iconCtx.save();
iconCtx.translate(30, 34);
iconCtx.scale(1.4, 1.4);
drawSwordShape(iconCtx);
iconCtx.restore();
  loots = [];
  lootOverlayOpen = false;
  pendingLoot = null;
  lootOverlay.style.display = "none";
resetGame();
loop();
</script>
</body>
</html>
