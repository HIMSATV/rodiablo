<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Oni Samurai</title>
<style>
body { margin:0; overflow:hidden; background:#000; }
canvas { display:block; }
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const TILE = 64;
const MAP_SIZE = 30;
const ZOOM = 3;

let keys = {};
let attacking = false;

document.addEventListener("keydown", e => keys[e.key]=true);
document.addEventListener("keyup", e => keys[e.key]=false);

canvas.addEventListener("mousedown", ()=> startAttack());
canvas.addEventListener("touchstart", ()=> startAttack());

function startAttack(){
  if(!attacking){
    attacking = true;
    player.attackFrame = 0;
  }
}

class Player{
  constructor(){
    this.x=0; this.y=0;
    this.speed=0.08;
    this.dir=0;
    this.attackFrame=0;
  }

  update(){
    let dx=0, dy=0;
    if(keys["w"]) dy-=1;
    if(keys["s"]) dy+=1;
    if(keys["a"]) dx-=1;
    if(keys["d"]) dx+=1;

    if(dx||dy){
      this.x+=dx*this.speed;
      this.y+=dy*this.speed;
      this.dir=Math.atan2(dy,dx);
    }

    if(attacking){
      this.attackFrame++;
      if(this.attackFrame>15){
        attacking=false;
      }
    }
  }

  draw(camX,camY){
    const isoX=(this.x-this.y)*TILE/2;
    const isoY=(this.x+this.y)*TILE/4;

    const sx=canvas.width/2+(isoX-camX)*ZOOM;
    const sy=canvas.height/2+(isoY-camY)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.6,ZOOM*1.6);

    // Í∑∏Î¶ºÏûê
    ctx.fillStyle="rgba(0,0,0,0.5)";
    ctx.beginPath();
    ctx.ellipse(0,8,6,3,0,0,Math.PI*2);
    ctx.fill();

    // Î™∏ÌÜµ
    ctx.fillStyle="#7a0000";
    ctx.fillRect(-5,-10,10,12);

    // Ìà¨Íµ¨
    ctx.fillStyle="#550000";
    ctx.fillRect(-4,-16,8,6);

    // Îøî
    ctx.fillStyle="#ddd";
    ctx.beginPath();
    ctx.moveTo(-3,-16); ctx.lineTo(-6,-22); ctx.lineTo(-2,-18); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(3,-16); ctx.lineTo(6,-22); ctx.lineTo(2,-18); ctx.fill();

    // ÎÖ∏ÎûÄ Îàà
    ctx.shadowColor="yellow";
    ctx.shadowBlur=10;
    ctx.fillStyle="yellow";
    ctx.fillRect(-2,-13,2,2);
    ctx.fillRect(1,-13,2,2);
    ctx.shadowBlur=0;

    // Îã§Î¶¨
    ctx.fillStyle="#222";
    ctx.fillRect(-3,2,3,8);
    ctx.fillRect(1,2,3,8);

    // ‚öî ÌúòÎëêÎ•¥Í∏∞ Î™®ÏÖò
    ctx.strokeStyle="#ddd";
    ctx.lineWidth=2;

    let swingAngle = this.dir;

    if(attacking){
      let progress = this.attackFrame/15; // 0~1
      swingAngle += -1 + progress*2; // -1 rad ~ +1 rad
      ctx.shadowColor="white";
      ctx.shadowBlur=8;
    }

    ctx.beginPath();
    ctx.moveTo(0,-6);
    ctx.lineTo(
      14*Math.cos(swingAngle),
      -6+14*Math.sin(swingAngle)
    );
    ctx.stroke();
    ctx.shadowBlur=0;

    ctx.restore();
  }
}

class Goblin{
  constructor(x,y){
    this.x=x; this.y=y;
    this.speed=0.03;
  }

  update(player){
    let dx=player.x-this.x;
    let dy=player.y-this.y;
    let dist=Math.hypot(dx,dy);
    if(dist<5){
      this.x+=dx/dist*this.speed;
      this.y+=dy/dist*this.speed;
    }
  }

  draw(camX,camY){
    const isoX=(this.x-this.y)*TILE/2;
    const isoY=(this.x+this.y)*TILE/4;
    const sx=canvas.width/2+(isoX-camX)*ZOOM;
    const sy=canvas.height/2+(isoY-camY)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.3,ZOOM*1.3);

    ctx.fillStyle="green";
    ctx.fillRect(-4,-8,8,10);
    ctx.fillStyle="#003300";
    ctx.fillRect(-3,-12,6,4);

    ctx.restore();
  }
}

const player=new Player();
const goblins=[new Goblin(3,3),new Goblin(-4,2)];

let camX=0, camY=0;

function drawMap(){
  for(let x=-MAP_SIZE;x<MAP_SIZE;x++){
    for(let y=-MAP_SIZE;y<MAP_SIZE;y++){
      const isoX=(x-y)*TILE/2;
      const isoY=(x+y)*TILE/4;
      const sx=canvas.width/2+(isoX-camX)*ZOOM;
      const sy=canvas.height/2+(isoY-camY)*ZOOM;

      ctx.fillStyle="#2a2a2a";
      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.lineTo(sx,sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.closePath();
      ctx.fill();
    }
  }
}

function drawDarkness(){
  ctx.fillStyle="rgba(0,0,0,0.65)"; // üîÜ Îçú Ïñ¥Îë°Í≤å
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const isoX=(player.x-player.y)*TILE/2;
  const isoY=(player.x+player.y)*TILE/4;
  const sx=canvas.width/2+(isoX-camX)*ZOOM;
  const sy=canvas.height/2+(isoY-camY)*ZOOM;

  const gradient=ctx.createRadialGradient(sx,sy,100,sx,sy,350);
  gradient.addColorStop(0,"rgba(0,0,0,0)");
  gradient.addColorStop(1,"rgba(0,0,0,0.8)");

  ctx.globalCompositeOperation="destination-out";
  ctx.fillStyle=gradient;
  ctx.beginPath();
  ctx.arc(sx,sy,350,0,Math.PI*2);
  ctx.fill();
  ctx.globalCompositeOperation="source-over";
}

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update();
  goblins.forEach(g=>g.update(player));

  camX+=((player.x-player.y)*TILE/2-camX)*0.1;
  camY+=((player.x+player.y)*TILE/4-camY)*0.1;

  drawMap();
  goblins.forEach(g=>g.draw(camX,camY));
  player.draw(camX,camY);
  drawDarkness();

  requestAnimationFrame(loop);
}

loop();
</script>
</body>
</html>
