<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Oni Samurai ARPG</title>
<style>
body{margin:0;overflow:hidden;background:#111;}
canvas{display:block;}
</style>
</head>
<body>
<canvas id="game"></canvas>
<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
canvas.width=innerWidth;
canvas.height=innerHeight;

const TILE=100;
const MAP=20;
const ZOOM=2.2;

let inputX=0,inputY=0;
let monsters=[];
let effects=[];

function iso(x,y){
  return { x:(x-y)*TILE/2, y:(x+y)*TILE/4 }
}

function distance(a,b){
  return Math.hypot(a.x-b.x,a.y-b.y);
}

// ================= PLAYER =================
class Player{
  constructor(){
    this.x=0;
    this.y=0;
    this.radius=0.5;
    this.speed=0.04;
    this.dir=0;
    this.attackCooldown=0;
  }

  update(){
    // 이동
    this.x+=inputX*this.speed;
    this.y+=inputY*this.speed;

    // 방향
    if(inputX||inputY){
      if(Math.abs(inputX)>Math.abs(inputY)){
        this.dir=inputX>0?1:3;
      }else{
        this.dir=inputY>0?2:0;
      }
    }

    // 자동 공격
    if(this.attackCooldown<=0){
      monsters.forEach(m=>{
        if(!m.dead && distance(this,m)<1.4){
          this.attack();
        }
      });
    }

    if(this.attackCooldown>0) this.attackCooldown--;
  }

  attack(){
    this.attackCooldown=25;
    effects.push(new Slash(this.x,this.y,this.dir));

    monsters.forEach(m=>{
      if(!m.dead && distance(this,m)<1.6){
        m.hp-=50;
        if(m.hp<=0) m.dead=true;
      }
    });
  }

  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*2,ZOOM*2);

    // ===== 다리 =====
    ctx.fillStyle="#200000";
    ctx.fillRect(-6,0,5,10);
    ctx.fillRect(1,0,5,10);

    // ===== 붉은 갑주 =====
    ctx.fillStyle="#8b0000";
    ctx.fillRect(-8,-14,16,14);

    // ===== 흉갑 디테일 =====
    ctx.fillStyle="#b22222";
    ctx.fillRect(-6,-12,12,8);

    // ===== 어깨 =====
    ctx.fillRect(-12,-16,6,6);
    ctx.fillRect(6,-16,6,6);

    // ===== 머리 =====
    ctx.fillStyle="#111";
    ctx.fillRect(-6,-24,12,10);

    // ===== 뿔 (이미지 참고 큰 곡선) =====
    ctx.strokeStyle="white";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.moveTo(-4,-24);
    ctx.quadraticCurveTo(-14,-34,-8,-20);
    ctx.moveTo(4,-24);
    ctx.quadraticCurveTo(14,-34,8,-20);
    ctx.stroke();

    // ===== 눈 =====
    ctx.fillStyle="yellow";
    ctx.fillRect(-3,-20,2,2);
    ctx.fillRect(1,-20,2,2);

    ctx.restore();
  }
}

// ================= MONSTER =================
class Monster{
  constructor(x,y){
    this.x=x;
    this.y=y;
    this.radius=0.5;
    this.hp=60;
    this.dead=false;
  }

  update(player){
    if(this.dead) return;
    let dx=player.x-this.x;
    let dy=player.y-this.y;
    let d=Math.hypot(dx,dy);

    if(d<6){
      this.x+=dx/d*0.02;
      this.y+=dy/d*0.02;
    }
  }

  draw(cam){
    if(this.dead) return;
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*1.6,ZOOM*1.6);

    // 몸
    ctx.fillStyle="#1e8449";
    ctx.fillRect(-6,-10,12,14);

    // 머리
    ctx.fillStyle="#145a32";
    ctx.fillRect(-5,-18,10,8);

    // 눈
    ctx.fillStyle="lime";
    ctx.fillRect(-2,-15,1,1);
    ctx.fillRect(1,-15,1,1);

    ctx.restore();
  }
}

// ================= SLASH =================
class Slash{
  constructor(x,y,dir){
    this.x=x;
    this.y=y;
    this.dir=dir;
    this.life=8;
  }
  update(){ this.life--; }
  draw(cam){
    let p=iso(this.x,this.y);
    let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
    let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

    ctx.save();
    ctx.translate(sx,sy);
    ctx.scale(ZOOM*2.5,ZOOM*2.5);
    ctx.strokeStyle="white";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.arc(0,0,20,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
}

// ================= JOYSTICK (하단 중앙) =================
const joystick={
  x:canvas.width/2,
  y:canvas.height-120,
  r:80
};

canvas.addEventListener("touchmove",e=>{
  let t=e.touches[0];
  let dx=t.clientX-joystick.x;
  let dy=t.clientY-joystick.y;
  let d=Math.hypot(dx,dy);

  if(d<joystick.r){
    inputX=dx/joystick.r;
    inputY=dy/joystick.r;
  }
});

canvas.addEventListener("touchend",()=>{
  inputX=0; inputY=0;
});

// ================= INIT =================
let player=new Player();
for(let i=0;i<6;i++)
  monsters.push(new Monster(Math.random()*4-2,Math.random()*4-2));

let cam={x:0,y:0};

function loop(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  player.update();
  monsters.forEach(m=>m.update(player));
  effects.forEach(e=>e.update());
  effects=effects.filter(e=>e.life>0);
  monsters=monsters.filter(m=>!m.dead);

  cam.x+=(iso(player.x,player.y).x-cam.x)*0.2;
  cam.y+=(iso(player.x,player.y).y-cam.y)*0.2;

  // 바닥
  for(let x=-MAP;x<MAP;x++){
    for(let y=-MAP;y<MAP;y++){
      let p=iso(x,y);
      let sx=canvas.width/2+(p.x-cam.x)*ZOOM;
      let sy=canvas.height/2+(p.y-cam.y)*ZOOM;

      ctx.beginPath();
      ctx.moveTo(sx,sy);
      ctx.lineTo(sx+TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.lineTo(sx,sy+TILE/2*ZOOM);
      ctx.lineTo(sx-TILE/2*ZOOM,sy+TILE/4*ZOOM);
      ctx.closePath();

      ctx.fillStyle=(x+y)%2==0?"#2b2b2b":"#383838";
      ctx.fill();
    }
  }

  monsters.forEach(m=>m.draw(cam));
  effects.forEach(e=>e.draw(cam));
  player.draw(cam);

  // 조이스틱 표시
  ctx.globalAlpha=0.4;
  ctx.beginPath();
  ctx.arc(joystick.x,joystick.y,joystick.r,0,Math.PI*2);
  ctx.fillStyle="gray";
  ctx.fill();
  ctx.globalAlpha=1;

  requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
