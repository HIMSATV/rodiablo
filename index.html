<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Isometric Dungeon</title>
<style>
html,body{
  margin:0;
  overflow:hidden;
  background:#000;
}
canvas{display:block;}
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const TILE_W = 64;
const TILE_H = 32;
const WALL_HEIGHT = 48;

const MAP_W = 40;
const MAP_H = 40;

let map=[];
for(let y=0;y<MAP_H;y++){
  map[y]=[];
  for(let x=0;x<MAP_W;x++){
    if(x===0||y===0||x===MAP_W-1||y===MAP_H-1){
      map[y][x]=1;
    }else{
      map[y][x]=Math.random()<0.12?1:0;
    }
  }
}

let player={
  x:10,
  y:10,
  speed:0.12
};

let keys={};
document.addEventListener("keydown",e=>keys[e.key]=true);
document.addEventListener("keyup",e=>keys[e.key]=false);

let camera={
  x:player.x,
  y:player.y,
  shake:0
};

function isoToScreen(x,y){
  const relX=x-camera.x;
  const relY=y-camera.y;

  let sx=(relX-relY)*(TILE_W/2)+canvas.width/2;
  let sy=(relX+relY)*(TILE_H/2)+canvas.height/2;

  if(camera.shake>0){
    sx+=(Math.random()-0.5)*camera.shake;
    sy+=(Math.random()-0.5)*camera.shake;
  }

  return {x:sx,y:sy};
}

function update(){

  let nx=player.x;
  let ny=player.y;

  if(keys["w"]) ny-=player.speed;
  if(keys["s"]) ny+=player.speed;
  if(keys["a"]) nx-=player.speed;
  if(keys["d"]) nx+=player.speed;

  if(nx>1&&nx<MAP_W-2&&map[Math.floor(player.y)][Math.floor(nx)]===0){
    player.x=nx;
  }
  if(ny>1&&ny<MAP_H-2&&map[Math.floor(ny)][Math.floor(player.x)]===0){
    player.y=ny;
  }

  camera.x+=(player.x-camera.x)*0.08;
  camera.y+=(player.y-camera.y)*0.08;

  if(camera.shake>0){
    camera.shake*=0.9;
    if(camera.shake<0.5) camera.shake=0;
  }
}

function drawFloor(x,y){
  const p=isoToScreen(x,y);

  ctx.beginPath();
  ctx.moveTo(p.x,p.y);
  ctx.lineTo(p.x+TILE_W/2,p.y+TILE_H/2);
  ctx.lineTo(p.x,p.y+TILE_H);
  ctx.lineTo(p.x-TILE_W/2,p.y+TILE_H/2);
  ctx.closePath();

  ctx.fillStyle="#3a3a3a";
  ctx.fill();
}

function drawWall(x,y){
  const p=isoToScreen(x,y);

  ctx.beginPath();
  ctx.moveTo(p.x,p.y-WALL_HEIGHT);
  ctx.lineTo(p.x+TILE_W/2,p.y+TILE_H/2-WALL_HEIGHT);
  ctx.lineTo(p.x,p.y+TILE_H-WALL_HEIGHT);
  ctx.lineTo(p.x-TILE_W/2,p.y+TILE_H/2-WALL_HEIGHT);
  ctx.closePath();
  ctx.fillStyle="#555";
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(p.x+TILE_W/2,p.y+TILE_H/2-WALL_HEIGHT);
  ctx.lineTo(p.x+TILE_W/2,p.y+TILE_H/2);
  ctx.lineTo(p.x,p.y+TILE_H);
  ctx.lineTo(p.x,p.y+TILE_H-WALL_HEIGHT);
  ctx.closePath();
  ctx.fillStyle="#444";
  ctx.fill();

  ctx.beginPath();
  ctx.moveTo(p.x-TILE_W/2,p.y+TILE_H/2-WALL_HEIGHT);
  ctx.lineTo(p.x-TILE_W/2,p.y+TILE_H/2);
  ctx.lineTo(p.x,p.y+TILE_H);
  ctx.lineTo(p.x,p.y+TILE_H-WALL_HEIGHT);
  ctx.closePath();
  ctx.fillStyle="#2e2e2e";
  ctx.fill();
}

function drawSamurai(){
  const p=isoToScreen(player.x,player.y);

  // 그림자
  ctx.fillStyle="rgba(0,0,0,0.4)";
  ctx.beginPath();
  ctx.ellipse(p.x,p.y-2,14,6,0,0,Math.PI*2);
  ctx.fill();

  // 다리
  ctx.fillStyle="#2c2c2c";
  ctx.fillRect(p.x-6,p.y-28,12,18);

  // 몸통
  ctx.fillStyle="#7a1f1f";
  ctx.fillRect(p.x-8,p.y-42,16,16);

  // 어깨 갑옷
  ctx.fillStyle="#999";
  ctx.fillRect(p.x-10,p.y-46,20,6);

  // 머리
  ctx.fillStyle="#e0c097";
  ctx.fillRect(p.x-5,p.y-52,10,8);

  // 투구 장식
  ctx.fillStyle="#aa0000";
  ctx.fillRect(p.x-2,p.y-58,4,6);

  // 카타나
  ctx.strokeStyle="#ccc";
  ctx.lineWidth=2;
  ctx.beginPath();
  ctx.moveTo(p.x+8,p.y-42);
  ctx.lineTo(p.x+20,p.y-60);
  ctx.stroke();
}

function drawLighting(){

  ctx.fillStyle="rgba(0,0,0,0.6)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.globalCompositeOperation="destination-out";

  const torches=[
    {x:8,y:8},
    {x:20,y:15},
    {x:30,y:25}
  ];

  torches.forEach(t=>{
    const p=isoToScreen(t.x,t.y);
    const flicker=100+Math.random()*20;

    const g=ctx.createRadialGradient(p.x,p.y,20,p.x,p.y,flicker);
    g.addColorStop(0,"rgba(0,0,0,1)");
    g.addColorStop(1,"rgba(0,0,0,0)");

    ctx.fillStyle=g;
    ctx.beginPath();
    ctx.arc(p.x,p.y,flicker,0,Math.PI*2);
    ctx.fill();
  });

  const pp=isoToScreen(player.x,player.y);
  const g2=ctx.createRadialGradient(pp.x,pp.y,20,pp.x,pp.y,120);
  g2.addColorStop(0,"rgba(0,0,0,1)");
  g2.addColorStop(1,"rgba(0,0,0,0)");
  ctx.fillStyle=g2;
  ctx.beginPath();
  ctx.arc(pp.x,pp.y,120,0,Math.PI*2);
  ctx.fill();

  ctx.globalCompositeOperation="source-over";
}

function render(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      drawFloor(x,y);
      if(map[y][x]===1) drawWall(x,y);
    }
  }

  drawSamurai();
  drawLighting();
}

function loop(){
  update();
  render();
  requestAnimationFrame(loop);
}

canvas.addEventListener("click",()=>camera.shake=18);

loop();

window.addEventListener("resize",()=>{
  canvas.width=window.innerWidth;
  canvas.height=window.innerHeight;
});
</script>

</body>
</html>
