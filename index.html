<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport"
 content="width=device-width,
 initial-scale=1.0,
 maximum-scale=1.0,
 user-scalable=no">
<title>Oni Slayer</title>

<style>
body{margin:0;background:black;overflow:hidden;}
canvas{position:fixed;top:0;left:0;image-rendering:pixelated;}
#ui{
 position:fixed;bottom:0;width:100%;height:120px;
 background:#111;border-top:3px solid #550000;
 display:flex;align-items:center;
 justify-content:space-between;
 padding:0 25px;box-sizing:border-box;
}
#movePad{position:relative;width:90px;height:90px;
 border-radius:50%;background:#222;}
#stick{position:absolute;width:40px;height:40px;
 border-radius:50%;background:#666;
 left:25px;top:25px;}
#hpContainer{flex:1;margin:0 20px;height:18px;
 background:#330000;border:2px solid #990000;}
#hpBar{height:100%;width:100%;background:red;}
#attackBtn{
 width:90px;height:90px;border-radius:50%;
 background:#990000;border:3px solid #ff4444;
 display:flex;align-items:center;justify-content:center;
 font-size:26px;color:white;
}
#attackBtn.active{background:red;transform:scale(.85);}
</style>
</head>
<body>

<canvas id="game"></canvas>

<div id="ui">
 <div id="movePad"><div id="stick"></div></div>
 <div id="hpContainer"><div id="hpBar"></div></div>
 <div id="attackBtn">⚔</div>
</div>

<script>
const canvas=document.getElementById("game");
const ctx=canvas.getContext("2d");
const uiHeight=120;

function resize(){
 canvas.width=window.innerWidth;
 canvas.height=window.innerHeight-uiHeight;
}
resize();
window.addEventListener("resize",resize);

/* ===== 플레이어 ===== */
let player={
 x:canvas.width/2,
 y:canvas.height/2,
 radius:14,
 speed:2,
 dir:"right"
};

/* ===== 파티클 ===== */
let particles=[];

/* ===== 몬스터 ===== */
let enemies=[];
function spawnEnemy(){
 enemies.push({
  x:Math.random()*canvas.width,
  y:Math.random()*canvas.height,
  radius:14,
  hp:40,
  knockX:0,
  knockY:0,
  anim:0,
  type:Math.floor(Math.random()*3), // AI 타입
  dashCooldown:0
 });
}
for(let i=0;i<6;i++)spawnEnemy();

/* ===== 입력 ===== */
let joyDX=0,joyDY=0;
let attacking=false;
let attackFrame=0;

const pad=document.getElementById("movePad");
const stick=document.getElementById("stick");
let joyActive=false;

pad.addEventListener("touchstart",()=>joyActive=true);

pad.addEventListener("touchmove",e=>{
 if(!joyActive)return;
 let rect=pad.getBoundingClientRect();
 let x=e.touches[0].clientX-rect.left-45;
 let y=e.touches[0].clientY-rect.top-45;
 let dist=Math.hypot(x,y);
 let max=30;
 if(dist>max){x*=max/dist;y*=max/dist;}
 stick.style.left=(x+45-20)+"px";
 stick.style.top=(y+45-20)+"px";
 joyDX=x/max; joyDY=y/max;

 if(Math.abs(x)>Math.abs(y))
  player.dir = x>0?"right":"left";
 else
  player.dir = y>0?"down":"up";
});

pad.addEventListener("touchend",()=>{
 joyActive=false; joyDX=joyDY=0;
 stick.style.left="25px"; stick.style.top="25px";
});

const attackBtn=document.getElementById("attackBtn");
attackBtn.addEventListener("touchstart",()=>{
 attacking=true;
 attackFrame=0;
 attackBtn.classList.add("active");
});
attackBtn.addEventListener("touchend",()=>{
 attackBtn.classList.remove("active");
});

/* ===== 업데이트 ===== */
function update(){

 player.x+=joyDX*player.speed*3;
 player.y+=joyDY*player.speed*3;

 if(attacking){
  attackFrame++;
  if(attackFrame==2)doHit();
  if(attackFrame>10)attacking=false;
 }

 enemies.forEach(e=>{

  let dx=player.x-e.x;
  let dy=player.y-e.y;
  let dist=Math.hypot(dx,dy);

  /* AI 패턴 */
  if(e.type==0){ // 추격형
   if(dist>1){
    e.x+=dx/dist*0.5;
    e.y+=dy/dist*0.5;
   }
  }

  if(e.type==1){ // 돌진형
   if(e.dashCooldown<=0 && dist<150){
    e.knockX=dx/dist*8;
    e.knockY=dy/dist*8;
    e.dashCooldown=60;
   }
   e.dashCooldown--;
  }

  if(e.type==2){ // 회피형
   if(dist<80){
    e.x-=dx/dist*0.6;
    e.y-=dy/dist*0.6;
   }else{
    e.x+=dx/dist*0.3;
    e.y+=dy/dist*0.3;
   }
  }

  e.x+=e.knockX;
  e.y+=e.knockY;
  e.knockX*=0.8;
  e.knockY*=0.8;

  e.anim=(e.anim+1)%20;
 });

 particles.forEach(p=>{
  p.x+=p.vx;
  p.y+=p.vy;
  p.vx*=0.9;
  p.vy*=0.9;
  p.life--;
 });
 particles=particles.filter(p=>p.life>0);

 enemies=enemies.filter(e=>e.hp>0);
}

/* ===== 공격 처리 ===== */
function doHit(){
 enemies.forEach(e=>{
  let dx=e.x-player.x;
  let dy=e.y-player.y;
  let dist=Math.hypot(dx,dy);
  if(dist<70){
   let dirAngle={
    right:0,
    left:Math.PI,
    up:-Math.PI/2,
    down:Math.PI/2
   }[player.dir];
   let angle=Math.atan2(dy,dx);
   let diff=Math.abs(angle-dirAngle);
   if(diff<0.8){
    e.hp-=20;

    // 넉백
    e.knockX=Math.cos(dirAngle)*6;
    e.knockY=Math.sin(dirAngle)*6;

    spawnBlood(e.x,e.y,dirAngle);

    if(e.hp<=0)
     spawnExplosion(e.x,e.y);
   }
  }
 });
}

/* ===== 방향성 피 ===== */
function spawnBlood(x,y,angle){
 for(let i=0;i<8;i++){
  let spread=(Math.random()-0.5)*0.8;
  let speed=3+Math.random()*2;
  particles.push({
   x,y,
   vx:Math.cos(angle+spread)*speed,
   vy:Math.sin(angle+spread)*speed,
   life:20,
   color:"#aa0000",
   size:3
  });
 }
}

/* ===== 사망 폭발 ===== */
function spawnExplosion(x,y){
 for(let i=0;i<20;i++){
  particles.push({
   x,y,
   vx:(Math.random()-0.5)*8,
   vy:(Math.random()-0.5)*8,
   life:30,
   color:Math.random()>0.5?"#550000":"#aa0000",
   size:4
  });
 }
}

/* ===== 렌더 ===== */
function draw(){
 ctx.fillStyle="#111";
 ctx.fillRect(0,0,canvas.width,canvas.height);

 enemies.forEach(e=>drawGoblin(e));
 drawOni(player.x,player.y);

 particles.forEach(p=>{
  ctx.globalAlpha=p.life/30;
  ctx.fillStyle=p.color;
  ctx.fillRect(p.x,p.y,p.size,p.size);
  ctx.globalAlpha=1;
 });
}

function drawOni(x,y){
 ctx.fillStyle="#880000";
 ctx.fillRect(x-10,y-12,20,22);
 ctx.fillStyle="#aa0000";
 ctx.fillRect(x-7,y-20,14,8);
 ctx.fillStyle="#ffffcc";
 ctx.fillRect(x-8,y-26,4,8);
 ctx.fillRect(x+4,y-26,4,8);
 ctx.fillStyle="#fff";
 ctx.fillRect(x-3,y-14,2,2);
 ctx.fillRect(x+1,y-14,2,2);
}

function drawGoblin(e){
 let bob=(e.anim<10)?-1:1;
 ctx.fillStyle=e.type==2?"#004400":"#006600";
 ctx.fillRect(e.x-9,e.y-10+bob,18,20);
 ctx.fillStyle="#00aa00";
 ctx.fillRect(e.x-6,e.y-18+bob,12,8);
 ctx.fillStyle="#fff";
 ctx.fillRect(e.x-3,e.y-14+bob,2,2);
 ctx.fillRect(e.x+1,e.y-14+bob,2,2);
}

function loop(){
 update();
 draw();
 requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
