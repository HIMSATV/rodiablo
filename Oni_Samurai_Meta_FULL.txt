<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Oni Samurai</title>

  <style>
    :root{
      --uiScale: 1.2;
      --uiH: clamp(calc(84px * var(--uiScale)),  calc(16vh * var(--uiScale)),  calc(120px * var(--uiScale)));
      --pad: clamp(calc(66px * var(--uiScale)),  calc(12.5vw * var(--uiScale)), calc(90px  * var(--uiScale)));
      --stick:clamp(calc(28px * var(--uiScale)),  calc(5.6vw * var(--uiScale)),  calc(40px  * var(--uiScale)));
      --btn: clamp(calc(70px * var(--uiScale)),  calc(13vw * var(--uiScale)),   calc(90px  * var(--uiScale)));
    }

    body{ margin:0; background:black; overflow:hidden; touch-action:none; }
    #game{ position:fixed; top:0; left:0; image-rendering:pixelated; }

    /* ============================= */
    /* âœ… í•˜ë‹¨ UI ë°” */
    /* ============================= */
    #ui{
      position:fixed;bottom:0;width:100%;height:var(--uiH);
      background:#111;border-top:3px solid #550000;
      display:flex;align-items:center;justify-content:space-between;
      padding:0 clamp(10px, 4vw, 25px);box-sizing:border-box;
      z-index:50;
    }

    #movePad{
      position:relative;
      width:var(--pad);height:var(--pad);
      border-radius:50%;
      background:#222;
    }
    #stick{
      position:absolute;
      width:var(--stick);
      height:var(--stick);
      border-radius:50%;
      background:#666;
      left: calc(50% - (var(--stick) / 2));
      top:  calc(50% - (var(--stick) / 2));
    }

    /* ì˜¤ë¥¸ìª½ ë²„íŠ¼ ì˜ì—­ */
    #rightBtns{
      position:relative;
      width:var(--btn);
      height:var(--btn);
      display:block;
      overflow:visible;
    }

    #attackBtn{
      position:absolute;
      right:0;
      bottom:0;
      width:var(--btn);height:var(--btn);
      border-radius:50%;
      background:#990000;border:3px solid #ff4444;
      display:flex;align-items:center;justify-content:center;
      font-size:26px;color:white;
      user-select:none;
      -webkit-user-select:none;
    }
    #attackBtn.active{background:red;transform:scale(.85);}

    #attackIcon{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
    }

    /* ============================= */
    /* âœ… ì•„ì´í…œ ì„ íƒ ì˜¤ë²„ë ˆì´ UI     */
    /* ============================= */
    #lootOverlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.75);
      z-index:9999;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    #lootPanel{
      width:min(92vw, 520px);
      background:#111;
      border:2px solid #444;
      border-radius:14px;
      padding:14px;
      box-shadow:0 0 30px rgba(0,0,0,0.6);
    }
    #lootTitle{
      color:#fff;
      font-weight:800;
      font-size:18px;
      margin:4px 2px 10px;
      text-align:center;
    }
    .lootCards{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .lootCard{
      background:#1a1a1a;
      border:2px solid #333;
      border-radius:12px;
      padding:12px;
      color:#eee;
      line-height:1.25;
    }
    .lootCard .name{
      font-weight:900;
      margin-bottom:6px;
    }
    .lootCard .desc{
      color:#cfcfcf;
      font-size:14px;
    }
    .lootCard button{
      margin-top:10px;
      width:100%;
      padding:10px 12px;
      border:0;
      border-radius:10px;
      background:#2d6cff;
      color:#fff;
      font-weight:800;
      font-size:15px;
    }
    .lootCard.normal{
      border-color:#3a3a3a;
      box-shadow:0 0 8px rgba(255,255,255,0.1);
    }
    .lootCard.magic{
      border-color:#2f7bff;
      box-shadow:0 0 14px rgba(0,140,255,0.6);
    }
    .lootCard.rare{
      border-color:#ffd166;
      box-shadow:0 0 16px rgba(255,209,102,0.55);
    }
    .lootCard.unique{
      border-color:#ffb86b;
      box-shadow:0 0 20px rgba(255,184,107,0.70);
      animation:uniqueGlow 1.6s infinite alternate;
    }
    @keyframes uniqueGlow{
      from{ box-shadow:0 0 14px rgba(255,184,107,0.35); }
      to{ box-shadow:0 0 24px rgba(255,184,107,0.85); }
    }
    /* âœ… ì•„ì´í…œ ì •ë³´ì°½ HTML ë Œë” */
.itemInfoWrap{
  white-space: normal;
  line-height: 1.25;
}
.itemInfoName{
  font-weight: 900;
  margin-bottom: 6px;
}
.itemInfoLine{
  white-space: pre-line; /* ì¤„ë°”ê¿ˆ ìœ ì§€ */
  font-size: 13px;
  color: #ddd;
}
.itemInfoTier{
  opacity:0.75;
  font-size:12px;
  margin-left:6px;
}
.itemInfoDim{ color:#aaa; }
.itemInfoGap{ height:8px; }
/* âœ… POEì‹ ì•„ì´í…œ ì´ë¦„ ìƒ‰ìƒ */
.rName{ font-weight:900; }
.r-normal{ color:#ffffff; }
.r-magic{ color:#2f7bff; }
.r-rare{ color:#ffd166; }
.r-unique{ color:#ffb86b; } /* ìœ ë‹ˆí¬ */
    /* ============================= */
    /* âœ… ì¥ë¹„/ê°€ë°©/ì¹´ì˜¤ìŠ¤: ë¶„ë¦¬ ì°½ UI */
    /* ============================= */
    #hudBtns{
      position:fixed;
      top:10px; left:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      z-index:80;
    }
    .hudBtn{
      width:44px;height:44px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(20,20,20,0.86);
      color:#fff;
      font-size:20px;
      box-shadow:0 0 14px rgba(0,0,0,0.45);
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
    }
    .hudBtn:active{ transform:scale(0.96); }

    /* ê³µí†µ ì˜¤ë²„ë ˆì´ */
    .panelOverlay{
      position:fixed;
      inset:0;
      display:none;
      background:rgba(0,0,0,0.55);
      z-index:9999;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
      align-items:center;
      justify-content:center;
    }

    /* ê³µí†µ íŒ¨ë„ */
    .panel{
      width:min(96vw, 980px);
      height:min(90vh, 760px);
      background:#141414;
      border:2px solid #3a3a3a;
      border-radius:14px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .panelTop{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:10px;
    }
    .panelClose{
      padding:8px 12px;
      border-radius:12px;
      border:1px solid #3a3a3a;
      background:#202020;
      color:#f0f0f0;
      cursor:pointer;
      font-size:13px;
    }
    .panelClose:hover{ border-color:#888; }

    /* ===== ì¥ë¹„/ìŠ¤í™ íŒ¨ë„ ===== */
    #equipPanelBody{
      flex:1 1 auto;
      display:flex;
      gap:12px;
      min-height:0;
    }
    #equipSlots{
      flex:0 0 44%;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      align-content:start;
    }
    .eSlot{
      border:1px solid #444;
      border-radius:12px;
      background:#1a1a1a;
      padding:10px;
      min-height:84px;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:6px;
    }
    .eSlot .label, .eSlot .item{ display:none; }

    .eSlot:hover{ border-color:#888; }
    .eSlot.selected{ outline:2px solid #ffd166; }
    .eSlot .label{ font-size:12px; color:#aaa; text-transform:uppercase; letter-spacing:0.06em; }
    .eSlot .item{ font-size:14px; color:#f2f2f2; line-height:1.2; word-break:break-word; }
.eSlot .label{
  display:none !important;
}
   #specBox{
  margin-top:4px;   /* ë˜ëŠ” 4px */
  flex:1 1 auto;
      background:transparent;
      border:none;
      border-radius:0;
      padding:0;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:6px;
      min-height:0;
    }
    #specText{
  margin-top:8px;
  padding:12px;
  font-size:clamp(12px, 2.6vw, 14px);   /* âœ… ê¸€ì”¨ ì¡°ê¸ˆ ì‘ê²Œ */
  line-height:1.35;
  color:#ddd;
  white-space:pre-line;                 /* âœ… 
 ì¤„ë°”ê¿ˆ ê·¸ëŒ€ë¡œ */
  overflow-y:auto;                      /* âœ… ë‚´ìš© ë§ìœ¼ë©´ ìŠ¤í¬ë¡¤ */
  max-height:clamp(140px, 22vh, 190px); /* âœ… ë°•ìŠ¤ ì•ˆì—ì„œë§Œ ìŠ¤í¬ë¡¤ */
  -webkit-overflow-scrolling:touch;
}
  #equipInfo{
  margin-top:4px;   /* ê¸°ì¡´ê°’ë³´ë‹¤ ì¤„ì´ê¸° */
  flex:0 0 auto;
      height:clamp(170px, 26vh, 260px);
      overflow:auto;
      overscroll-behavior:contain;
      -webkit-overflow-scrolling:touch;
      white-space:pre-line;
      font-size:13px;
      color:#ddd;
      background:#0f0f0f;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:10px;
    
      width:100%;
      box-sizing:border-box;
    }

 /* ===== ê°€ë°© íŒ¨ë„ ===== */
#bagBody{
  flex:1 1 auto;
  display:flex;
  flex-direction:column;   /* âœ… ìœ„-ì•„ë˜ ë°°ì¹˜ë¡œ ê³ ì • */
  gap:12px;
  min-height:0;
}

/* âœ… ì•„ì´í…œ ì„¤ëª…: ìœ„ */
#bagInfo{
  flex:0 0 42vh;           /* âœ… ì •ë³´ì°½ ë†’ì´ ê³ ì • */
  height:42vh;             /* âœ… ì•„ì´í…œì— ë”°ë¼ í¬ê¸° ë³€í•˜ì§€ ì•Šê²Œ */
  overflow:auto;
  white-space:pre-line;
  font-size:13px;
  color:#ddd;
  background:#101010;
  border:1px solid #2b2b2b;
  border-radius:12px;
  padding:12px;
  box-sizing:border-box;
}

/* âœ… ì¸ë²¤ ê·¸ë¦¬ë“œ: ì•„ë˜ + ìŠ¤í¬ë¡¤ */
#bagGrid{
  flex:1 1 auto;
  overflow:auto;           /* âœ… ìŠ¤í¬ë¡¤ */
  display:grid;
  grid-template-columns: repeat(6, 1fr);
  gap:8px;
  background:#101010;
  border:1px solid #2b2b2b;
  border-radius:12px;
  padding:10px;
  box-sizing:border-box;
  align-content:start;
  min-height:0;
}
    .bItem{
      border:1px solid #555;
      border-radius:12px;
      background:#171717;
      min-height:56px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }
    .bItem.normal{ border-color:#666; }
    .bItem.magic{ border-color:#2f7bff; box-shadow:0 0 10px rgba(0,140,255,0.35); }
    .bItem.rare{ border-color:#ffd166; box-shadow:0 0 12px rgba(255,209,102,0.30); }
    .bItem.unique{ border-color:#ffb86b; box-shadow:0 0 14px rgba(255,184,107,0.35); }

    .bItem:hover{ border-color:#888; }
    .bItem.selected{ outline:2px solid #6bf178; }
    .bItem.unique{ border-color:#b89b00; }

  .iconCanvas{
  position:static;
  display:block;
  background:rgba(255,255,255,0.06);
  border-radius:10px;
}


    /* ===== ì¹´ì˜¤ìŠ¤ íŒ¨ë„ ===== */
    #chaosBody{
      flex:1 1 auto;
      display:flex;
      gap:12px;
      min-height:0;
    }
    #chaosLeft{
      flex:1 1 auto;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    #chaosCount{
      font-size:18px;
      font-weight:900;
      color:#fff;
    }
    #chaosBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #3a3a3a;
      background:#2d6cff;
      color:#fff;
      font-weight:900;
      cursor:pointer;
    }
    #chaosBtn:active{ transform:scale(0.98); }

    #chaosInfo{
      flex:1 1 auto;
      overflow:auto;
      white-space:pre-line;
      font-size:13px;
      color:#ddd;
      background:#0f0f0f;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
    }

    /* ëª¨ë°”ì¼ */
    @media (max-width: 600px){
      #bagGrid{ grid-template-columns: repeat(4, 1fr); }
      #equipPanelBody{ flex-direction:column; }
      #equipSlots{ grid-template-columns:1fr 1fr; flex:0 0 auto; }
      #bagBody{ flex-direction:column; }
      #bagGrid{
  flex: 1 1 auto;
  min-height: 0;
  overflow: auto;
}
#bagInfo{
  flex:0 0 42vh;
  height:42vh;
  overflow:auto;
}
    }
    /* ============================= */
/* âœ… DIABLO STYLE UI SKIN (ADD) */
/* âœ… <style> ë§¨ ì•„ë˜ì— ë¶™ì—¬ë„£ê¸° */
/* ============================= */

:root{
  --d-bg0:#050505;
  --d-bg1:#0a0a0a;
  --d-bg2:#111;
  --d-panel:#0c0c0c;
  --d-panel2:#101010;
  --d-line:#2a2a2a;
  --d-line2:#3a3a3a;
  --d-gold:#b08a3a;
  --d-gold2:#d9b35a;
  --d-red:#7a0a0a;
  --d-red2:#b01010;
  --d-text:#e7e2d8;
  --d-dim:#b9b2a6;
  --d-shadow: rgba(0,0,0,0.65);
}

/* ì „ì²´ í†¤ ë‹¤ìš´ */
body{
  background: radial-gradient(1200px 800px at 50% 20%, #101010 0%, #050505 60%, #000 100%);
}

/* ============================= */
/* í•˜ë‹¨ UI ë°” (ê°€ì£½+ì²  í…Œë‘ë¦¬)   */
/* ============================= */
#ui{
  background:
    linear-gradient(180deg, rgba(255,255,255,0.04), rgba(0,0,0,0.0) 22%),
    linear-gradient(180deg, #0a0a0a, #050505 70%, #020202);
  border-top: 2px solid rgba(176,139,58,0.35);
  box-shadow:
    0 -10px 30px rgba(0,0,0,0.75),
    inset 0 1px 0 rgba(255,255,255,0.05);
}

/* ============================= */
/* ì™¼ìª½ ì´ë™íŒ¨ë“œ (ë¬´ê²Œê°)        */
/* ============================= */
#movePad{
  background:
    radial-gradient(circle at 30% 30%, rgba(255,255,255,0.06), rgba(0,0,0,0.25) 55%, rgba(0,0,0,0.55)),
    linear-gradient(180deg, #0f0f0f, #050505);
  border: 1px solid rgba(176,139,58,0.25);
  box-shadow:
    0 10px 22px rgba(0,0,0,0.55),
    inset 0 2px 6px rgba(255,255,255,0.05),
    inset 0 -8px 14px rgba(0,0,0,0.6);
}

#stick{
  background:
    radial-gradient(circle at 30% 30%, rgba(255,255,255,0.20), rgba(255,255,255,0.06) 35%, rgba(0,0,0,0.55) 75%),
    linear-gradient(180deg, #1a1a1a, #070707);
  border: 1px solid rgba(255,255,255,0.12);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.55),
    inset 0 2px 6px rgba(255,255,255,0.06),
    inset 0 -8px 14px rgba(0,0,0,0.7);
}

/* ============================= */
/* ì˜¤ë¥¸ìª½ ê³µê²© ë²„íŠ¼ (í•ë¹›+ê¸ˆì†)  */
/* ============================= */
#attackBtn{
  background:
    radial-gradient(circle at 35% 30%, rgba(255,255,255,0.12), rgba(0,0,0,0.0) 35%),
    radial-gradient(circle at 50% 60%, rgba(176,16,16,0.55), rgba(90,0,0,0.75) 55%, rgba(0,0,0,0.85)),
    linear-gradient(180deg, #1a0a0a, #040000);
  border: 2px solid rgba(176,139,58,0.45);
  box-shadow:
    0 14px 26px rgba(0,0,0,0.70),
    inset 0 2px 10px rgba(255,255,255,0.07),
    inset 0 -10px 18px rgba(0,0,0,0.8);
}

#attackBtn.active{
  transform: scale(.90);
  background:
    radial-gradient(circle at 35% 30%, rgba(255,255,255,0.16), rgba(0,0,0,0.0) 38%),
    radial-gradient(circle at 50% 60%, rgba(255,60,60,0.55), rgba(130,0,0,0.8) 55%, rgba(0,0,0,0.9)),
    linear-gradient(180deg, #2a0a0a, #050000);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.75),
    inset 0 2px 12px rgba(255,255,255,0.10),
    inset 0 -10px 18px rgba(0,0,0,0.85);
}

/* ============================= */
/* ìƒë‹¨ HUD ë²„íŠ¼(ìŠ¤í™/ê°€ë°©/ì¹´ì˜¤ìŠ¤)*/
/* ============================= */
.hudBtn{
  border-radius: 14px;
  border: 1px solid rgba(176,139,58,0.22);
  background:
    linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.0) 25%),
    linear-gradient(180deg, #0e0e0e, #050505);
  color: var(--d-text);
  box-shadow:
    0 12px 22px rgba(0,0,0,0.6),
    inset 0 1px 0 rgba(255,255,255,0.06),
    inset 0 -10px 16px rgba(0,0,0,0.7);
}
.hudBtn:active{
  transform: scale(0.96);
}

/* ============================= */
/* íŒ¨ë„ ì˜¤ë²„ë ˆì´/ì°½(ë¬´ê²ê²Œ)       */
/* ============================= */
.panelOverlay{
  background: rgba(0,0,0,0.72);
  backdrop-filter: blur(2px);
}

.panel{
  background:
    radial-gradient(900px 420px at 50% 0%, rgba(255,255,255,0.05), rgba(0,0,0,0.0) 55%),
    linear-gradient(180deg, #0f0f0f, #070707 70%, #040404);
  border: 1px solid rgba(176,139,58,0.28);
  box-shadow:
    0 24px 60px rgba(0,0,0,0.75),
    inset 0 1px 0 rgba(255,255,255,0.05);
}

/* ìƒë‹¨ ë²„íŠ¼(ë‹«ê¸°/ì¥ì°©/í•´ì œ) */
.panelClose{
  border: 1px solid rgba(176,139,58,0.24);
  background:
    linear-gradient(180deg, rgba(255,255,255,0.06), rgba(0,0,0,0.0) 30%),
    linear-gradient(180deg, #121212, #070707);
  color: var(--d-text);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.55),
    inset 0 1px 0 rgba(255,255,255,0.06),
    inset 0 -10px 16px rgba(0,0,0,0.65);
}
.panelClose:hover{
  border-color: rgba(217,179,90,0.45);
}

/* ============================= */
/* ìŠ¬ë¡¯/ì¸ë²¤ ë°•ìŠ¤(ë””ì•„ í†¤)        */
/* ============================= */
#equipSlots, #specBox, #bagGrid, #bagInfo, #chaosLeft, #chaosInfo, #specText, #equipInfo{
  background:
    linear-gradient(180deg, rgba(255,255,255,0.03), rgba(0,0,0,0.0) 20%),
    linear-gradient(180deg, #0d0d0d, #070707);
  border: 1px solid rgba(176,139,58,0.15);
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.04),
    inset 0 -12px 18px rgba(0,0,0,0.65);
}

/* ì¥ë¹„ ìŠ¬ë¡¯ ì¹´ë“œ */
.eSlot{
  background:
    radial-gradient(circle at 30% 25%, rgba(255,255,255,0.05), rgba(0,0,0,0.0) 50%),
    linear-gradient(180deg, #121212, #070707);
  border: 1px solid rgba(176,139,58,0.16);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.55),
    inset 0 1px 0 rgba(255,255,255,0.06),
    inset 0 -10px 16px rgba(0,0,0,0.7);
}
.eSlot.selected{
  outline: 2px solid rgba(217,179,90,0.80);
  box-shadow:
    0 0 0 2px rgba(217,179,90,0.12),
    0 12px 22px rgba(0,0,0,0.6),
    inset 0 1px 0 rgba(255,255,255,0.06);
}
.eSlot .label{
  color: rgba(217,179,90,0.75);
}
.eSlot .item{
  color: var(--d-text);
}

/* ê°€ë°© ì•„ì´í…œ ì¹¸ */
.bItem{
  background:
    radial-gradient(circle at 30% 30%, rgba(255,255,255,0.05), rgba(0,0,0,0.0) 50%),
    linear-gradient(180deg, #121212, #070707);
  border: 1px solid rgba(176,139,58,0.12);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.55),
    inset 0 1px 0 rgba(255,255,255,0.05),
    inset 0 -10px 16px rgba(0,0,0,0.75);
}
.bItem:hover{
  border-color: rgba(217,179,90,0.35);
}
.bItem.selected{
  outline: 2px solid rgba(110,241,120,0.70);
}

/* ì•„ì´ì½˜ ìº”ë²„ìŠ¤ë„ ë” â€œì² â€ ëŠë‚Œ */
.iconCanvas{
  background:
    radial-gradient(circle at 35% 30%, rgba(255,255,255,0.10), rgba(0,0,0,0.0) 40%),
    linear-gradient(180deg, #0f0f0f, #050505);
  border-radius: 10px;
  box-shadow:
    inset 0 1px 0 rgba(255,255,255,0.05),
    inset 0 -10px 14px rgba(0,0,0,0.7);
}

/* ============================= */
/* ì•„ì´í…œ ì •ë³´ì°½(ê¸€/ë¼ì¸)         */
/* ============================= */
.itemInfoWrap{
  color: var(--d-text);
}
.itemInfoLine{
  color: rgba(231,226,216,0.92);
}
.itemInfoDim{
  color: rgba(185,178,166,0.85);
}
.itemInfoTier{
  opacity: 0.78;
  font-size: 12px;
  margin-left: 6px;
  color: rgba(217,179,90,0.75);
}

/* ë“œë¡­ ì„ íƒ íŒ¨ë„(lootOverlay)ë„ í†¤ í†µì¼ */
#lootPanel{
  background:
    radial-gradient(800px 340px at 50% 0%, rgba(255,255,255,0.05), rgba(0,0,0,0.0) 55%),
    linear-gradient(180deg, #0f0f0f, #070707 70%, #040404);
  border: 1px solid rgba(176,139,58,0.22);
  box-shadow: 0 26px 70px rgba(0,0,0,0.8);
}
.lootCard{
  background:
    radial-gradient(circle at 30% 25%, rgba(255,255,255,0.05), rgba(0,0,0,0.0) 55%),
    linear-gradient(180deg, #141414, #080808);
  border-color: rgba(176,139,58,0.16);
}
.lootCard button{
  background:
    linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.0) 35%),
    linear-gradient(180deg, #1b3f9b, #10285f);
  border: 1px solid rgba(217,179,90,0.18);
  box-shadow:
    0 12px 18px rgba(0,0,0,0.55),
    inset 0 1px 0 rgba(255,255,255,0.08),
    inset 0 -10px 16px rgba(0,0,0,0.75);
}
/* =========================================================
   âœ… DIABLO II STYLE UI OVERRIDES (Dark / Heavy / Stone+Metal)
   - ê¸°ì¡´ CSS ì•„ë˜ì— "ê·¸ëŒ€ë¡œ ì¶”ê°€"í•˜ë©´ ë®ì–´ì”Œì›Œì§
   ========================================================= */

:root{
  /* ì „ì²´ í†¤ */
  --d2-bg: #070707;
  --d2-panel: #0c0c0c;
  --d2-panel2:#101010;
  --d2-stone:#141312;
  --d2-stone2:#1a1817;

  /* í…Œë‘ë¦¬ / ìŒì˜ */
  --d2-edge1: rgba(255,255,255,0.06);
  --d2-edge2: rgba(0,0,0,0.85);
  --d2-inset: rgba(0,0,0,0.65);

  /* í¬ì¸íŠ¸(ë””ì•„2 ë¶‰ì€ ëŠë‚Œ) */
  --d2-red1:#5a0b0b;
  --d2-red2:#b11b1b;
  --d2-redGlow: rgba(255,40,40,0.22);

  /* ê¸ˆì†/í™©ë™ í•˜ì´ë¼ì´íŠ¸ */
  --d2-brass1:#c9a86a;
  --d2-brass2:#7a5a2b;

  /* í…ìŠ¤íŠ¸ */
  --d2-txt:#e6e1d8;
  --d2-dim:#b9b0a3;
  --d2-dimmer:#877f75;
}

/* ===== ë°°ê²½ ê¸°ë³¸ ===== */
body{
  background: radial-gradient(ellipse at top, #0b0b0b 0%, #040404 55%, #000 100%);
  color: var(--d2-txt);
}

/* =========================================================
   âœ… í•˜ë‹¨ UI ë°” (ë””ì•„2 ì„ì¬+ê¸ˆì† í”„ë ˆì„)
   ========================================================= */
#ui{
  background:
    linear-gradient(180deg, rgba(255,255,255,0.05), rgba(0,0,0,0.3)),
    radial-gradient(120% 140% at 50% -40%, rgba(255,60,60,0.12), rgba(0,0,0,0) 60%),
    linear-gradient(180deg, #0e0e0e, #070707 55%, #050505);
  border-top: 2px solid rgba(255,255,255,0.06);
  box-shadow:
    0 -10px 25px rgba(0,0,0,0.65),
    0 -2px 0 rgba(0,0,0,0.9) inset,
    0  2px 0 rgba(255,255,255,0.03) inset;
}

/* í•˜ë‹¨ ë°” ìƒë‹¨ì— ì–‡ì€ ë¶‰ì€ ë£¬ ë¼ì¸ */
#ui::before{
  content:"";
  position:absolute;
  left:0; right:0; top:-2px;
  height:2px;
  background: linear-gradient(90deg,
    rgba(0,0,0,0),
    rgba(255,40,40,0.35),
    rgba(0,0,0,0)
  );
  pointer-events:none;
}

/* =========================================================
   âœ… ì´ë™ íŒ¨ë“œ (ì„ì¬ ë§ + ëˆŒë¦¼)
   ========================================================= */
#movePad{
  background:
    radial-gradient(circle at 35% 30%, rgba(255,255,255,0.06), rgba(0,0,0,0) 55%),
    radial-gradient(circle at 50% 60%, #1a1817 0%, #0e0d0d 60%, #080808 100%);
  border: 1px solid rgba(255,255,255,0.07);
  box-shadow:
    0 10px 20px rgba(0,0,0,0.55),
    0 2px 0 rgba(255,255,255,0.03) inset,
    0 -8px 14px rgba(0,0,0,0.75) inset;
}

#stick{
  background:
    radial-gradient(circle at 35% 35%, rgba(255,255,255,0.12), rgba(0,0,0,0) 60%),
    radial-gradient(circle at 50% 60%, #707070 0%, #3a3a3a 55%, #1d1d1d 100%);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow:
    0 8px 14px rgba(0,0,0,0.55),
    0 2px 0 rgba(255,255,255,0.08) inset,
    0 -10px 12px rgba(0,0,0,0.6) inset;
}

/* =========================================================
   âœ… ê³µê²© ë²„íŠ¼ (ë””ì•„2: ë‘¥ê·¼ ì„ì¬+ë¶‰ì€ ì½”ì–´)
   ========================================================= */
#attackBtn{
  background:
    radial-gradient(circle at 35% 30%, rgba(255,255,255,0.09), rgba(0,0,0,0) 55%),
    radial-gradient(circle at 50% 60%, #2b0909 0%, #1a0707 48%, #0a0505 100%);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow:
    0 14px 24px rgba(0,0,0,0.65),
    0  2px 0 rgba(255,255,255,0.06) inset,
    0 -12px 18px rgba(0,0,0,0.75) inset,
    0 0 18px rgba(255,40,40,0.12);
}

#attackBtn::after{
  content:"";
  position:absolute;
  inset:10%;
  border-radius:50%;
  border: 1px solid rgba(255,60,60,0.28);
  box-shadow: 0 0 22px rgba(255,40,40,0.12) inset;
  pointer-events:none;
}

#attackBtn.active{
  transform: scale(0.90);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.7),
    0 2px 0 rgba(255,255,255,0.05) inset,
    0 -16px 24px rgba(0,0,0,0.85) inset,
    0 0 26px rgba(255,40,40,0.22);
}

/* =========================================================
   âœ… ìƒë‹¨ HUD ë²„íŠ¼ (ë¬´ê±°ìš´ ê¸ˆì† ë²„íŠ¼)
   ========================================================= */
#hudBtns .hudBtn{
  background:
    linear-gradient(180deg, rgba(255,255,255,0.07), rgba(0,0,0,0.25)),
    radial-gradient(circle at 40% 35%, #1f1d1c 0%, #0f0f0f 60%, #070707 100%);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.55),
    0 2px 0 rgba(255,255,255,0.05) inset,
    0 -10px 14px rgba(0,0,0,0.75) inset;
  color: #f3eee4;
}

#hudBtns .hudBtn:active{
  transform: scale(0.95);
}

/* =========================================================
   âœ… ê³µí†µ ì˜¤ë²„ë ˆì´ / íŒ¨ë„ (ë””ì•„2 ì°½ ëŠë‚Œ)
   ========================================================= */
.panelOverlay{
  background: rgba(0,0,0,0.68);
  backdrop-filter: blur(2px);
}

.panel{
  background:
    radial-gradient(120% 140% at 50% 0%, rgba(255,60,60,0.10), rgba(0,0,0,0) 55%),
    linear-gradient(180deg, #141312, #0b0b0b 55%, #070707);
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow:
    0 24px 60px rgba(0,0,0,0.75),
    0 2px 0 rgba(255,255,255,0.04) inset,
    0 -18px 26px rgba(0,0,0,0.85) inset;
  position: relative;
}

/* íŒ¨ë„ ìƒë‹¨ ê¸ˆì† í”„ë ˆì„ */
.panel::before{
  content:"";
  position:absolute;
  left:10px; right:10px; top:10px;
  height:10px;
  border-radius:10px;
  background: linear-gradient(90deg,
    rgba(0,0,0,0),
    rgba(201,168,106,0.18),
    rgba(0,0,0,0)
  );
  pointer-events:none;
}

/* íŒ¨ë„ ë‹«ê¸°/íƒ­ ë²„íŠ¼ */
.panelClose{
  background:
    linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.25)),
    linear-gradient(180deg, #1a1817, #0f0f0f);
  border: 1px solid rgba(255,255,255,0.10);
  color: var(--d2-txt);
  box-shadow:
    0 10px 16px rgba(0,0,0,0.45),
    0 2px 0 rgba(255,255,255,0.05) inset,
    0 -10px 14px rgba(0,0,0,0.75) inset;
}

.panelClose:hover{
  border-color: rgba(201,168,106,0.35);
  box-shadow:
    0 10px 16px rgba(0,0,0,0.45),
    0 0 14px rgba(201,168,106,0.12);
}

/* =========================================================
   âœ… ì¥ë¹„ ìŠ¬ë¡¯ / ìŠ¤í™ ë°•ìŠ¤ (ëŒ+ê¸ˆì† ëŠë‚Œ)
   ========================================================= */
#equipSlots, #specBox, #bagInfo, #bagGrid, #chaosLeft, #chaosInfo{
  background:
    radial-gradient(circle at 35% 25%, rgba(255,255,255,0.05), rgba(0,0,0,0) 60%),
    linear-gradient(180deg, #101010, #090909 65%, #070707);
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow:
    0 2px 0 rgba(255,255,255,0.03) inset,
    0 -12px 18px rgba(0,0,0,0.7) inset;
}

.eSlot{
  background:
    radial-gradient(circle at 35% 30%, rgba(255,255,255,0.05), rgba(0,0,0,0) 60%),
    linear-gradient(180deg, #161413, #0e0d0d);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow:
    0 8px 14px rgba(0,0,0,0.45),
    0 2px 0 rgba(255,255,255,0.04) inset,
    0 -10px 14px rgba(0,0,0,0.75) inset;
}

.eSlot:hover{ border-color: rgba(201,168,106,0.35); }
.eSlot.selected{ outline: 2px solid rgba(201,168,106,0.65); }

.eSlot .label{
  color: var(--d2-dimmer);
}
.eSlot .item{
  color: var(--d2-txt);
}

/* ìŠ¤í™ í…ìŠ¤íŠ¸ ë°•ìŠ¤ */
#specText, #equipInfo{
  background:
    linear-gradient(180deg, #0e0e0e, #070707);
  border: 1px solid rgba(255,255,255,0.08);
  box-shadow:
    0 2px 0 rgba(255,255,255,0.03) inset,
    0 -12px 18px rgba(0,0,0,0.75) inset;
  color: var(--d2-txt);
}

/* =========================================================
   âœ… ì¸ë²¤ ì¹¸ (ë””ì•„2 ì¸ë²¤ ëŠë‚Œ: ë” ëˆŒë¦° ì¹¸ + ê¸ˆì† í…Œë‘ë¦¬)
   ========================================================= */
.bItem{
  background:
    radial-gradient(circle at 35% 25%, rgba(255,255,255,0.05), rgba(0,0,0,0) 60%),
    linear-gradient(180deg, #151313, #0d0c0c);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow:
    0 2px 0 rgba(255,255,255,0.03) inset,
    0 -10px 14px rgba(0,0,0,0.8) inset;
}
.bItem:hover{ border-color: rgba(201,168,106,0.28); }
.bItem.selected{ outline: 2px solid rgba(255,70,70,0.45); }
.bItem.unique{ border-color: rgba(201,168,106,0.65); box-shadow: 0 0 14px rgba(201,168,106,0.10); }

.iconCanvas{
  background: rgba(255,255,255,0.04) !important;
  box-shadow: 0 0 0 1px rgba(0,0,0,0.45) inset;
}

/* =========================================================
   âœ… ì•„ì´í…œ ì„ íƒ(loot) ì˜¤ë²„ë ˆì´: ì–´ë‘ìš´ ì„±ì†Œ UI
   ========================================================= */
#lootOverlay{
  background: rgba(0,0,0,0.78);
}

#lootPanel{
  background:
    radial-gradient(120% 140% at 50% 0%, rgba(255,60,60,0.12), rgba(0,0,0,0) 60%),
    linear-gradient(180deg, #141312, #0b0b0b 55%, #070707);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow:
    0 26px 70px rgba(0,0,0,0.78),
    0 2px 0 rgba(255,255,255,0.04) inset,
    0 -20px 30px rgba(0,0,0,0.88) inset;
}

#lootTitle{
  color: #f3eee4;
  text-shadow: 0 2px 0 rgba(0,0,0,0.6);
  letter-spacing: 0.02em;
}

.lootCard{
  background:
    radial-gradient(circle at 30% 20%, rgba(255,255,255,0.05), rgba(0,0,0,0) 60%),
    linear-gradient(180deg, #171514, #0e0d0d);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.55),
    0 2px 0 rgba(255,255,255,0.03) inset,
    0 -12px 18px rgba(0,0,0,0.82) inset;
}

.lootCard button{
  background:
    linear-gradient(180deg, rgba(255,255,255,0.08), rgba(0,0,0,0.2)),
    linear-gradient(180deg, #2a1010, #160909);
  border: 1px solid rgba(255,255,255,0.10);
  box-shadow:
    0 10px 18px rgba(0,0,0,0.55),
    0 0 18px rgba(255,40,40,0.10);
}
.lootCard button:active{ transform: scale(0.98); }

/* í¬ê·€ë„ ê°•ì¡° */
.lootCard.normal{ border-color: rgba(255,255,255,0.10); }
.lootCard.magic{   border-color: rgba(47,123,255,0.55); box-shadow: 0 0 18px rgba(0,140,255,0.22); }
.lootCard.rare{   border-color: rgba(201,168,106,0.70); box-shadow: 0 0 22px rgba(201,168,106,0.22); animation: none; }

/* =========================================================
   âœ… í…ìŠ¤íŠ¸/í¬ê·€ë„ ì»¬ëŸ¬(POE ìƒ‰ ìœ ì§€í•˜ë˜ ë””ì•„í†¤ìœ¼ë¡œ ì‚´ì§)
   ========================================================= */
.r-normal{ color:#f0ece4; }
.r-magic{ color:#7fb2ff; }
.r-rare{ color:#ffd166; }
.r-unique{ color:#ffb86b; }

.itemInfoDim{ color: var(--d2-dimmer); }
.itemInfoLine{ color: var(--d2-txt); }

/* ëª¨ë°”ì¼ì—ì„œ ë„ˆë¬´ ë²ˆì©ì´ì§€ ì•Šê²Œ */
@media (max-width:600px){
  #ui{ box-shadow: 0 -8px 20px rgba(0,0,0,0.65), 0 -14px 18px rgba(0,0,0,0.65) inset; }
}
  
/* ===== ìŠ¤í™ì°½ ì¥ì°© ìŠ¬ë¡¯ (ì‘ê²Œ 4ê°œ ì¼ë ¬) ===== */
#equipSlots{
  display:grid;
  grid-template-columns:repeat(4, 1fr);
  gap:10px;
  margin: 8px 0 12px 0;
}
.eSlotSmall{
  position:relative;
  aspect-ratio:1/1;
  border-radius: 12px;
  background:rgba(0,0,0,0.35);
  border:2px solid rgba(255,255,255,0.12);
  box-shadow: inset 0 0 0 2px rgba(255,255,255,0.06);
  display:flex;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  overflow:hidden;
  user-select:none;
}
.eSlotSmall.selected{
  border-color: rgba(200,160,90,0.9);
  box-shadow: 0 0 0 3px rgba(200,160,90,0.35), inset 0 0 0 2px rgba(255,255,255,0.06);
}
.eSlotSmall .slotLabel{ display:none !important; }
.eSlotSmall canvas{
  width:44px;
  height:44px;
  image-rendering:pixelated;
}
.itemInfoBox{
  background:rgba(0,0,0,0.35);
  border:2px solid rgba(255,255,255,0.12);
  border-radius:22px;
  padding:18px 18px;
  margin: 0 0 12px 0;
}



    /* ===== FIX (index13): ìŠ¬ë¡¯ ê¸€ì”¨ ì œê±° + ìºë¦­í„° ìŠ¤íƒ¯ ë°•ìŠ¤ ì •ë ¬ ===== */
    .eSlotSmall .slotLabel{ display:none !important; }

    /* specBoxëŠ” ì»¨í…Œì´ë„ˆ(íˆ¬ëª…)ë¡œë§Œ ì“°ê³ , ì‹¤ì œ ë°•ìŠ¤ëŠ” #equipInfo/#specTextê°€ ë‹´ë‹¹ */
    #specBox{
      background:transparent !important;
      border:none !important;
      padding:0 !important;
      border-radius:0 !important;
      gap:6px !important; /* ì¥ë¹„ìƒì„¸ â†” ìºë¦­í„°ìŠ¤íƒ¯ ê°„ê²© ì¤„ì´ê¸° */
    }
    #equipInfo, #specText{
      width:100% !important;
      box-sizing:border-box !important;
    }
/* =======================
   CRAFTING PANEL FIX
======================= */

#craftingPanel{
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.92);
  z-index:9999;
  display:none;
  flex-direction:column;
  color:#fff;
}

#craftingPanel.active{
  display:flex;
}

#craftTop{
  display:flex;
  justify-content:space-between;
  padding:20px;
}

#craftItemIcon{
  width:90px;
  height:90px;
  border:2px solid #999;
  border-radius:10px;
}

#craftOptions{
  flex:1;
  margin-left:20px;
  max-height:120px;
  overflow-y:auto;
}

#craftDesc{
  padding:15px;
  border-top:1px solid #333;
  border-bottom:1px solid #333;
  font-size:14px;
}

#craftOrbs{
  display:grid;
  grid-template-columns:repeat(5,1fr);
  gap:10px;
  padding:15px;
}

.craftOrb{
  background:#222;
  border:1px solid #444;
  border-radius:8px;
  padding:10px;
  text-align:center;
  cursor:pointer;
}

.craftOrb:hover{
  border-color:gold;
}

/* ===== ë©”íƒ€ í¬ë˜í”„íŒ… í‘œì‹œ (í•˜ëŠ˜ìƒ‰) ===== */
.itemInfoMeta{
  color:#7fd3ff;
  font-weight:900;
  text-shadow:0 0 6px rgba(127,211,255,0.35);
}

</style>
</head>
<body>
<canvas id="game"></canvas>

<!-- âœ… ìƒë‹¨ í€µ ë²„íŠ¼(ì¥ë¹„/ê°€ë°©/ì¹´ì˜¤ìŠ¤) -->
<div id="hudBtns">
  <button class="hudBtn" id="btnEquip" title="ìŠ¤í™">âš”ï¸</button>
  <button class="hudBtn" id="btnBag"   title="ê°€ë°©">ğŸ’</button>
</div>

<!-- âœ… ì•„ì´í…œ ì„ íƒ UI -->
<div id="lootOverlay">
  <div id="lootPanel">
    <div id="lootTitle">ì•„ì´í…œ ì„ íƒ (1ê°œë§Œ)</div>
    <div class="lootCards" id="lootCards"></div>
    
  </div>
</div>
<!-- âœ… ì¥ë¹„/ìŠ¤í™ íŒ¨ë„ -->
<div class="panelOverlay" id="equipOverlay">
  <div class="panel">
<div class="panelTop">
  <button class="panelClose" id="btnEquipToBag" type="button">ê°€ë°©</button>
        <button class="panelClose" id="btnEquipCraft" type="button">ì œì‘</button>
  <button class="panelClose" id="btnEquipUnequip" type="button">í•´ì œ</button>
  <button class="panelClose" id="btnEquipClose" type="button">ë‹«ê¸°</button>
</div>
    <div id="equipPanelBody">
      <div id="equipSlots"></div>
      <div id="equipInfo" class="itemInfoBox"></div>
      <div id="specBox">
        <div id="specText"></div>
      </div>
    </div>
  </div>
</div>

<!-- âœ… ê°€ë°© íŒ¨ë„ -->
<div class="panelOverlay" id="bagOverlay">
  <div class="panel">
  <div class="panelTop">
  <button class="panelClose" id="btnBagToEquip" type="button">ìŠ¤í™</button>
  <button class="panelClose" id="btnBagEquip" type="button">ì¥ì°©</button>
  <button class="panelClose" id="btnBagClose" type="button">ë‹«ê¸°</button>
</div>

    <div id="bagBody">
      <div id="bagInfo"></div>
      <div id="bagGrid"></div>
    </div>
  </div>
</div>

<!-- âœ… ì¹´ì˜¤ìŠ¤ íŒ¨ë„ -->
<div class="panelOverlay" id="craftOverlay">
  <div class="panel">
    <div class="panelTop">
      <button class="panelClose" id="btnCraftClose" type="button">ë‹«ê¸°</button>
    </div>

    <div id="craftBody">

      <!-- ìƒë‹¨: ì¢Œì¸¡ ì˜µì…˜ / ìš°ì¸¡ ì•„ì´ì½˜ -->
      <div id="craftTopRow">
        <div id="craftItemText"></div>
        <canvas id="craftItemIcon" width="110" height="110"></canvas>
      </div>

      <hr class="panelHr"/>

      <!-- ì˜¤ë¸Œ ì„¤ëª… -->
      <div id="orbDesc">ì˜¤ë¸Œë¥¼ ì„ íƒí•˜ë©´ ì„¤ëª…ì´ í‘œì‹œë©ë‹ˆë‹¤.</div>

      <hr class="panelHr"/>

      <!-- í•˜ë‹¨: ì˜¤ë¸Œë“¤ -->
      <div id="orbCounts"></div>
      <div class="orbGrid" id="craftOrbGrid">
        <button class="orbBtn" id="orbTransmute" type="button">ì§„í™”</button>
        <button class="orbBtn" id="orbAlter" type="button">ë³€í™”</button>
        <button class="orbBtn" id="orbAug" type="button">í™•ì¥</button>
        <button class="orbBtn" id="orbRegal" type="button">ì œì™•</button>

        <button class="orbBtn" id="orbAlchemy" type="button">ì—°ê¸ˆ</button>
        <button class="orbBtn" id="chaosBtn" type="button">ì¹´ì˜¤ìŠ¤</button>
        <button class="orbBtn" id="orbScour" type="button">ì •ì œ</button>
        <button class="orbBtn" id="orbExalt" type="button">ì—‘ì˜</button>

        <button class="orbBtn" id="orbAnnul" type="button">ì†Œë©¸</button>
        <button class="orbBtn" id="orbDivine" type="button">ì‹ ì„±</button>
        <button class="orbBtn" id="orbCorrupt" type="button">íƒ€ë½</button>
      </div>

    </div>
  </div>
</div>

<div id="ui">
  <div id="movePad"><div id="stick"></div></div>
  <div id="rightBtns">
    <div id="attackBtn">
      <canvas id="attackIcon" width="60" height="60"></canvas>
    </div>
  </div>
</div>

<script>
/* =========================================================
   MAINTAINABILITY / EXTENSION HOOKS
   - Safe no-op hooks so you can add features without touching core.
   - Add your own hooks anywhere by setting:
       window.GameHooks = { afterRenderPanels(){ ... } , ... }
   ========================================================= */
window.GameHooks = window.GameHooks || {};
function _callHook(name, ...args){
  try{
    const h = window.GameHooks && window.GameHooks[name];
    if(typeof h === "function") h(...args);
  }catch(err){
    console.warn("Hook error:", name, err);
  }
}


/* =========================================================
   STEP 1) PoEê¸‰ í™•ì¥í˜• íƒœê·¸/Mod ì—”ì§„ (ì½”ì–´ ë¡œì§ "ë¯¸ë³€ê²½" ë²„ì „)
   - ê¸°ì¡´ dmgMul/maxHpAdd ê°™ì€ ëˆ„ì  ë°©ì‹ì€ ê·¸ëŒ€ë¡œ ë‘ê³ ,
     ì•ìœ¼ë¡œ "ëª¨ë“œ"ë¡œ í™•ì¥í•  ê¸°ë°˜ë§Œ ì¶”ê°€í•©ë‹ˆë‹¤.
   - ì´ ë¸”ë¡ì€ <script> ì•ˆ, ì „ì—­(í•¨ìˆ˜ë“¤ ì„ ì–¸ ê°€ëŠ¥í•œ ê³³)ì— ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ê¸°.

   âœ… ì œê³µ ê¸°ëŠ¥
   1) íƒœê·¸ ë§¤ì¹­: hasTag, hasAllTags, mergeTags
   2) Mod êµ¬ì¡°: { id, source, scope, requiresAll, requiresAny, forbids, stat, op, value, stacks, maxStacks, enabled }
   3) Mod í‰ê°€/ì ìš©: modsFor(), statFromMods()
   4) ë””ë²„ê·¸: debugModsForStat()

   âš ï¸ ì•„ì§ì€ ê¸°ì¡´ ë°ë¯¸ì§€/ìŠ¤íƒ¯ ê³„ì‚°ì„ ê±´ë“œë¦¬ì§€ ì•ŠìŠµë‹ˆë‹¤.
      (ë‹¤ìŒ ë‹¨ê³„ì—ì„œ recalcFromGear()ì— í•œ ê²¹ ì¶”ê°€)
   ========================================================= */

/** ---------------------------------------------------------
 *  íƒœê·¸ ìœ í‹¸ (ê°€ë³ê³  ì•ˆì „)
 * -------------------------------------------------------- */
function _normTag(t){ return String(t||"").trim().toLowerCase(); }

function mergeTags(...lists){
  const out = new Set();
  for(const l of lists){
    if(!l) continue;
    for(const t of l){
      const nt = _normTag(t);
      if(nt) out.add(nt);
    }
  }
  return Array.from(out);
}

function hasTag(tags, tag){
  if(!tags || !tags.length) return false;
  const nt = _normTag(tag);
  for(const t of tags){
    if(_normTag(t) === nt) return true;
  }
  return false;
}

function hasAllTags(tags, required){
  if(!required || required.length === 0) return true;
  if(!tags || tags.length === 0) return false;
  for(const r of required){
    if(!hasTag(tags, r)) return false;
  }
  return true;
}

function hasAnyTag(tags, any){
  if(!any || any.length === 0) return true; // anyì¡°ê±´ì´ ì—†ìœ¼ë©´ í†µê³¼
  if(!tags || tags.length === 0) return false;
  for(const r of any){
    if(hasTag(tags, r)) return true;
  }
  return false;
}

function hasNoTags(tags, forbids){
  if(!forbids || forbids.length === 0) return true;
  if(!tags || tags.length === 0) return true;
  for(const f of forbids){
    if(hasTag(tags, f)) return false;
  }
  return true;
}

/** ---------------------------------------------------------
 *  Mod ì—”ì§„ (PoE ìŠ¤íƒ€ì¼ì˜ ìµœì†Œ ì½”ì–´)
 * -------------------------------------------------------- */
/**
 * Mod.op (ì—°ì‚° íƒ€ì…)
 * - "add"  : flat ë”í•˜ê¸° (ì˜ˆ: +25 ìµœëŒ€ì²´ë ¥)
 * - "inc"  : ì¦ê°€ìœ¨ í•©ì‚° (ì˜ˆ: 20% ì¦ê°€ -> 0.20)
 * - "more" : ë°°ìœ¨ ê³± (ì˜ˆ: 30% more -> 0.30)
 *
 * ê¶Œì¥: valueëŠ” ìˆ«ì  (inc/moreëŠ” 0.20 í˜•íƒœ)
 *
 * Mod.scope (ì ìš© ë²”ìœ„) - ì§€ê¸ˆì€ "player"ë§Œ ì“°ê³  í™•ì¥ ì˜ˆì •
 * - "player" | "skill" | "enemy" | "map" | "global"
 */
const MOD_OPS = Object.freeze({ add:"add", inc:"inc", more:"more" });

/**
 * ì „ì—­ ëª¨ë“œ ì €ì¥ì†Œ (ì•„ì§ì€ ì½”ì–´ì— ì—°ê²°í•˜ì§€ ì•ŠìŒ)
 * - equipment / buffs / map / etcì—ì„œ ëª¨ë“œë¥¼ ì´ê³³ìœ¼ë¡œ ëª¨ì„ ì˜ˆì •
 */
window.GameMods = window.GameMods || {
  /** @type {Array<Mod>} */
  list: [],
  add(mod){ this.list.push(mod); return mod; },
  removeById(id){ this.list = this.list.filter(m => m.id !== id); },
  clear(){ this.list.length = 0; }
};

/**
 * Mod ë§¤ì¹­(íƒœê·¸/ì¡°ê±´) ê²€ì‚¬
 * @param {Mod} mod
 * @param {Object} ctx - í‰ê°€ ì»¨í…ìŠ¤íŠ¸
 * @param {Array<string>} ctx.tags - í˜„ì¬ ëŒ€ìƒ(í”Œë ˆì´ì–´/ìŠ¤í‚¬ ë“±)ì˜ íƒœê·¸
 * @param {string} ctx.scope - "player" ë“±
 * @returns {boolean}
 */
function modMatches(mod, ctx){
  if(!mod) return false;
  if(mod.enabled === false) return false;

  // scope ê²€ì‚¬ (ì—†ìœ¼ë©´ global ì·¨ê¸‰)
  const scope = mod.scope || "global";
  if(scope !== "global" && ctx && ctx.scope && scope !== ctx.scope) return false;

  const tags = (ctx && ctx.tags) ? ctx.tags : [];

  // requiresAll: AND ì¡°ê±´
  if(!hasAllTags(tags, mod.requiresAll)) return false;

  // requiresAny: OR ì¡°ê±´
  if(!hasAnyTag(tags, mod.requiresAny)) return false;

  // forbids: ê¸ˆì§€ íƒœê·¸
  if(!hasNoTags(tags, mod.forbids)) return false;

  return true;
}

/**
 * ì»¨í…ìŠ¤íŠ¸ì— ì ìš© ê°€ëŠ¥í•œ ëª¨ë“œ ëª©ë¡ ë°˜í™˜
 * @param {Object} ctx
 * @param {string} ctx.scope
 * @param {Array<string>} ctx.tags
 * @param {string=} statKey - íŠ¹ì • ìŠ¤íƒ¯ë§Œ í•„í„°
 */
function modsFor(ctx, statKey){
  const all = (window.GameMods && window.GameMods.list) ? window.GameMods.list : [];
  const out = [];
  for(const m of all){
    if(statKey && m.stat !== statKey) continue;
    if(modMatches(m, ctx)) out.push(m);
  }
  return out;
}

/**
 * ìŠ¤íƒ¯ ê³„ì‚° (add/inc/more ìˆœì„œë¡œ)
 * @param {number} baseValue - ê¸°ì¡´ ë¡œì§ì´ ê³„ì‚°í•œ ê°’(í˜¹ì€ ê¸°ë³¸ê°’)
 * @param {Object} ctx - { scope, tags }
 * @param {string} statKey - ì˜ˆ: "max_hp", "damage"
 * @param {Object=} opt
 * @param {number=} opt.clampMin
 * @param {number=} opt.clampMax
 * @returns {number}
 */
function statFromMods(baseValue, ctx, statKey, opt){
  const list = modsFor(ctx, statKey);

  let add = 0;
  let inc = 0;     // í•©ì‚°
  let moreMul = 1; // ê³±

  for(const m of list){
    const stacks = Math.max(1, (m.stacks || 1));
    const maxStacks = (m.maxStacks || stacks);
    const s = Math.min(stacks, maxStacks);
    const v = (Number(m.value) || 0) * s;

    const op = m.op || MOD_OPS.add;
    if(op === MOD_OPS.add) add += v;
    else if(op === MOD_OPS.inc) inc += v;
    else if(op === MOD_OPS.more) moreMul *= (1 + v);
  }

  let out = (Number(baseValue)||0) + add;
  out *= (1 + inc);
  out *= moreMul;

  if(opt){
    if(typeof opt.clampMin === "number") out = Math.max(opt.clampMin, out);
    if(typeof opt.clampMax === "number") out = Math.min(opt.clampMax, out);
  }
  return out;
}

/** ---------------------------------------------------------
 *  ë””ë²„ê·¸ ë„êµ¬
 * -------------------------------------------------------- */
function debugModsForStat(ctx, statKey){
  const list = modsFor(ctx, statKey);
  const rows = list.map(m => ({
    id: m.id,
    stat: m.stat,
    op: m.op,
    value: m.value,
    scope: m.scope || "global",
    source: m.source || "",
    requiresAll: (m.requiresAll||[]).join(","),
    requiresAny: (m.requiresAny||[]).join(","),
    forbids: (m.forbids||[]).join(","),
    stacks: m.stacks || 1
  }));
  console.table(rows);
  return rows;
}

/** ---------------------------------------------------------
 *  ìƒ˜í”Œ ëª¨ë“œ (ì‘ë™ í™•ì¸ìš©) - ì›í•˜ë©´ ì§€ì›Œë„ ë¨
 *  - ì•„ì§ recalcFromGear()ì— ì—°ê²° ì „ì´ë¼ ì²´ê°ì€ ì—†ê³ ,
 *    debugModsForStat()ë¡œ ë§¤ì¹­ë§Œ í™•ì¸ ê°€ëŠ¥
 * -------------------------------------------------------- */
/*
window.GameMods.add({
  id:"test_melee_damage_inc",
  source:"debug",
  scope:"player",
  requiresAll:["melee"],    // í”Œë ˆì´ì–´/ìŠ¤í‚¬ tagsì— meleeê°€ ìˆìœ¼ë©´ ì ìš©
  stat:"damage",
  op:"inc",
  value:0.20
});

window.GameMods.add({
  id:"test_maxhp_add",
  source:"debug",
  scope:"player",
  requiresAll:[],
  stat:"max_hp",
  op:"add",
  value:25
});
*/


/* =========================================================
   STEP 5) ìŠ¤í‚¬/ëª¹/ë§µê¹Œì§€ íƒœê·¸ í™•ì¥ (PoEì‹ ìƒí˜¸ì‘ìš© ê¸°ë°˜)
   - ëª©í‘œ: 'ë°ë¯¸ì§€ ê³„ì‚°'ê³¼ 'í”¼í•´ ê³„ì‚°'ì— ê³µí†µ íƒœê·¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë¶™ì—¬,
           ì•ìœ¼ë¡œ "vs boss", "projectile", "fire", "map tier" ê°™ì€ ëª¨ë“œë¥¼
           ì½”ë“œ ìˆ˜ì • ì—†ì´ ëª¨ë“œë§Œ ì¶”ê°€í•´ì„œ êµ¬í˜„ ê°€ëŠ¥í•˜ê²Œ í•¨.
   - ì•ˆì „ì¥ì¹˜: ì•„ë˜ í”Œë˜ê·¸ë¡œ on/off ê°€ëŠ¥
   ========================================================= */
const USE_TAG_CONTEXTS = true;

/** ===== íƒœê·¸ ì›ì²œ(ê¸°ë³¸ê°’) ===== */
const PLAYER_BASE_TAGS = Object.freeze(["player","humanoid","samurai"]);
const SKILL_TAGS = Object.freeze({
  // ê¸°ë³¸ í‰íƒ€(ì¹´íƒ€ë‚˜)
  attack:   ["attack","melee","physical"],
  // ê¶ê·¹ê¸°(ê´‘ì—­ ë² ê¸°)
  ultimate: ["attack","aoe","physical","ultimate"],
  // í™œ(ì›ê±°ë¦¬)
  arrow:    ["attack","projectile","physical"],
  // ë§ˆë²•(ì¥íŒ)
  firezone: ["spell","aoe","fire"]
});

function getPlayerTags(){
  // ë‚˜ì¤‘ì— ì „ì§/íŒ¨ì‹œë¸Œë¡œ í™•ì¥ ê°€ëŠ¥
  return mergeTags(PLAYER_BASE_TAGS, player.tags || []);
}

function getWeaponTags(){
  // ì¥ë¹„ ìŠ¬ë¡¯ weaponì´ ì•„ì´í…œ(gear)ì¼ ìˆ˜ë„ ìˆê³ , ê¸°ë³¸ ë¬´ê¸°(player.weapon)ë§Œ ìˆì„ ìˆ˜ë„ ìˆìŒ
  const it = (typeof equipment !== "undefined" && equipment && equipment.weapon) ? equipment.weapon : null;
  const t = [];
  if(it && Array.isArray(it.tags)) t.push(...it.tags);
  // ìŠ¬ë¡¯/ê¸°ë³¸ ë¶„ë¥˜
  t.push("weapon");
  if(it && it.slot) t.push(it.slot);
  // ê¸°ë³¸ ì¹´íƒ€ë‚˜ ì„±ê²©(ì—†ìœ¼ë©´ melee)
  if(!t.includes("melee") && !t.includes("projectile")) t.push("melee");
  return mergeTags(t);
}

function getMapTags(){
  // tier/seed ê¸°ë°˜ìœ¼ë¡œ ëª¨ë“œ ì¡°ê±´ ë§Œë“¤ ìˆ˜ ìˆê²Œ íƒœê·¸í™”
  const t = ["map"];
  const tier = (mapRun && mapRun.tier) ? mapRun.tier : (typeof mapTier==="number" ? mapTier : 1);
  t.push("tier_"+tier);
  if(tier >= 5) t.push("high_tier");
  if(mapRun && mapRun.bossSpawned) t.push("boss_spawned");
  if(mapRun && mapRun.bossDefeated) t.push("boss_defeated");
  return mergeTags(t);
}

function tagsFromEnemy(e){
  if(!e) return [];
  const t = ["enemy"];
  if(e.type) t.push(e.type);
  if(e.type === "boss") t.push("boss");
  if(e.isElite) t.push("elite");
  if(e.eliteColor) t.push("elite_"+e.eliteColor);
  // ì›ê±°ë¦¬/ê·¼ê±°ë¦¬/ë§ˆë²• íƒœê·¸
  if(e.type === "archer") t.push("projectile");
  if(e.type === "mage") t.push("spell");
  if(e.type === "melee") t.push("melee");
  return mergeTags(t, e.tags || []);
}

/**
 * ê³µí†µ ì „íˆ¬ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
 * @param {string} skillId - "attack" | "ultimate" | "arrow" | "firezone" | ...
 * @param {Object=} enemy
 */
function buildCombatCtx(skillId, enemy){
  const skillTags = SKILL_TAGS[skillId] || ["skill", skillId];
  const tags = mergeTags(
    ["combat","skill", skillId],
    getPlayerTags(),
    getWeaponTags(),
    getMapTags(),
    skillTags,
    tagsFromEnemy(enemy)
  );
  return { scope:"skill", tags, enemy };
}

/** ì•„ì›ƒê³ ì‰(ë‚´ê°€ ì£¼ëŠ”) ë°ë¯¸ì§€ ëª¨ë“œ */
function applyOutgoingDamageMods(baseDmg, ctx){
  if(!USE_TAG_CONTEXTS) return baseDmg;
  if(typeof statFromMods !== "function") return baseDmg;
  // statKeyëŠ” "damage"ë¡œ í†µì¼ (ëª¨ë“œì—ì„œ requiresAllë¡œ ë¶„ê¸°)
  return statFromMods(baseDmg, ctx, "damage");
}

/** ì¸ì»¤ë°(ì ì´ ë°›ëŠ”) ë°ë¯¸ì§€ ëª¨ë“œ (ì˜ˆ: boss takes more) */
function applyEnemyTakenDamageMods(dealt, ctx){
  if(!USE_TAG_CONTEXTS) return dealt;
  if(typeof statFromMods !== "function") return dealt;
  // statKeyëŠ” "damage_taken"ìœ¼ë¡œ í†µì¼
  return statFromMods(dealt, ctx, "damage_taken");
}

/** í”Œë ˆì´ì–´ê°€ ë°›ëŠ” í”¼í•´ ëª¨ë“œ (ì˜ˆ: projectile damage taken) */
function applyPlayerTakenDamageMods(incoming, ctx){
  if(!USE_TAG_CONTEXTS) return incoming;
  if(typeof statFromMods !== "function") return incoming;
  return statFromMods(incoming, ctx, "player_damage_taken");
}

/* =========================================================
   âœ… POEì‹ ë°ë¯¸ì§€ "ë²„ì¼“" (Bucket) ë ˆì´ì–´
   - base(ê¸°ë³¸) â†’ add(ì¶”ê°€) â†’ increased(ì¦ê°€) â†’ more(ì¶”ê°€ë°°ìœ¨)
   - crit(ì¹˜ëª…íƒ€) â†’ enemy_taken(ì ì´ ë°›ëŠ” í”¼í•´) â†’ player_taken(í”Œë ˆì´ì–´ê°€ ë°›ëŠ” í”¼í•´)
   - ì§€ê¸ˆì€ 'ìŠ¤ì¹¼ë¼(ë‹¨ì¼ ìˆ«ì)'ë¡œ ê³„ì‚°í•˜ì§€ë§Œ,
     êµ¬ì¡°ë¥¼ ë²„ì¼“ìœ¼ë¡œ ì¡ì•„ë‘ë©´ ë‚˜ì¤‘ì— ë¬¼ë¦¬/ì›ì†Œ/ì¹´ì˜¤ìŠ¤ ê°™ì€
     DamagePacket(ë‹¤ì¤‘ íƒ€ì…)ë¡œ í™•ì¥í•˜ê¸° ì‰¬ì›€.
   ========================================================= */

/**
 * ê³µê²©ìê°€ ì£¼ëŠ” í”¼í•´ ê³„ì‚°(ì•„ì›ƒê³ ì‰ ë²„ì¼“) + í¬ë¦¬/ë°›ëŠ”í”¼í•´ê¹Œì§€ í•œ ë²ˆì— ì²˜ë¦¬
 * @param {number} base - ë¬´ê¸°/ìŠ¤í‚¬ì´ ë§Œë“  "ê¸°ë³¸ í”¼í•´"
 * @param {Object} ctx  - buildCombatCtx() ê²°ê³¼
 * @param {Object=} opt
 * @param {boolean=} opt.canCrit - ê¸°ë³¸ true (DOT/ì§€ì†í”¼í•´ë©´ false)
 * @returns {{raw:number, afterOutgoing:number, crit:{dmg:number,isCrit:boolean,chance:number,multi:number}, dealt:number}}
 */
function computeFinalDamage(base, ctx, opt){
  opt = opt || {};
  const canCrit = (opt.canCrit !== false);

  // 0) Base â†’ DamagePacket (phys/fire/cold/lightning/chaos)
  const rawPacket = baseToDamagePacket(base, ctx);

  // 1) OUTGOING: add/inc/more (íƒœê·¸ ê¸°ë°˜) íƒ€ì…ë³„ ì ìš©
  const afterOutgoingPacket = applyOutgoingDamageModsPacket(rawPacket, ctx);

  // 2) CRIT: ëª¨ë“  íƒ€ì…ì— ë™ì¼ ë°°ìœ¨ ì ìš© (DOTëŠ” canCrit:false)
  let crit = { dmg: sumDamagePacket(afterOutgoingPacket), isCrit:false, chance:0, multi:1 };
  let afterCritPacket = afterOutgoingPacket;

  if(canCrit){
    const chance = getCritChance();
    const multi = getCritMulti();
    const isCrit = (Math.random() < chance);
    crit = { dmg: isCrit ? sumDamagePacket(afterOutgoingPacket) * multi : sumDamagePacket(afterOutgoingPacket), isCrit, chance, multi };
    afterCritPacket = isCrit ? scaleDamagePacket(afterOutgoingPacket, multi) : afterOutgoingPacket;
  }

  // 3) ENEMY TAKEN: ì˜ˆ) boss takes more (íƒ€ì…ë³„)
  const afterTakenPacket = applyEnemyTakenDamageModsPacket(afterCritPacket, ctx);

  // 4) RESISTS: ì  ì €í•­(ì—†ìœ¼ë©´ 0)
  const dealtPacket = applyEnemyResistsPacket(afterTakenPacket, ctx && ctx.enemy);

  return {
    raw: sumDamagePacket(rawPacket),
    rawPacket,
    afterOutgoing: sumDamagePacket(afterOutgoingPacket),
    afterOutgoingPacket,
    crit,
    dealt: sumDamagePacket(dealtPacket),
    dealtPacket
  };
}

/**
 * (ì˜µì…˜) DamagePacket ê¸°ë°˜ í™•ì¥ìš© ìµœì†Œ êµ¬ì¡°
 * - ì•„ì§ì€ ì‹¤ì œë¡œ ì“°ì§€ ì•Šì§€ë§Œ, "ë²„ì¼“" êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ë ¤ê³  ë‘ .
 */
function makeDamagePacket(phys=0, fire=0, cold=0, lightning=0, chaos=0){
  return { phys, fire, cold, lightning, chaos };
}
function sumDamagePacket(p){
  return (p?.phys||0)+(p?.fire||0)+(p?.cold||0)+(p?.lightning||0)+(p?.chaos||0);
}
function scaleDamagePacket(p, k){
  return makeDamagePacket((p.phys||0)*k, (p.fire||0)*k, (p.cold||0)*k, (p.lightning||0)*k, (p.chaos||0)*k);
}


// âœ… base(ìˆ«ì) â†’ DamagePacket(phys/fire/cold/lightning/chaos)ë¡œ ë¶„ë¦¬
function baseToDamagePacket(base, ctx){
  // baseê°€ ì´ë¯¸ packetì´ë©´ ê·¸ëŒ€ë¡œ
  if(base && typeof base === "object" && ("phys" in base || "fire" in base || "cold" in base || "lightning" in base || "chaos" in base)){
    return makeDamagePacket(base.phys||0, base.fire||0, base.cold||0, base.lightning||0, base.chaos||0);
  }
  const v = (typeof base === "number") ? base : 0;

  // ìŠ¤í‚¬/ë¬´ê¸°/ìƒí™© íƒœê·¸ì— ë”°ë¼ ì›ì†Œë¡œ ë¶„ë°° (PoEì‹: "ì´ ê³µê²©ì€ í™”ì—¼/ëƒ‰ê¸°/ë²ˆê°œë¡œ ê°„ì£¼" ëŠë‚Œ)
  const tags = (ctx && Array.isArray(ctx.tags)) ? ctx.tags : [];
  const has = (t)=>tags.includes(t);

  const elems = [];
  if(has("fire")) elems.push("fire");
  if(has("cold")) elems.push("cold");
  if(has("lightning")) elems.push("lightning");
  if(has("chaos")) elems.push("chaos");

  // ê¸°ë³¸: ë¬¼ë¦¬ 100%
  let p = makeDamagePacket(v, 0, 0, 0, 0);

  // ì›ì†Œ íƒœê·¸ê°€ ìˆìœ¼ë©´ "ê·¸ ì›ì†Œë¡œ ì „í™˜" (ë‹¨ìˆœí™”: ë¬¼ë¦¬ë¥¼ ì›ì†Œë¡œ ë¶„ë°°)
  if(elems.length){
    const share = v / elems.length;
    p.phys = 0;
    for(const e of elems){
      p[e] = (p[e]||0) + share;
    }
  }
  return p;
}

function cloneCtxWithExtraTag(ctx, extraTag){
  if(!ctx) return { scope:"skill", tags:[extraTag] };
  const tags = Array.isArray(ctx.tags) ? ctx.tags.slice() : [];
  if(extraTag && !tags.includes(extraTag)) tags.push(extraTag);
  return { ...ctx, tags };
}

// âœ… OUTGOING / ENEMY_TAKENì„ DamagePacket ë‹¨ìœ„ë¡œ ì ìš©
function applyOutgoingDamageModsPacket(pkt, ctx){
  // ê° íƒ€ì…ë³„ë¡œ "ê·¸ íƒ€ì… íƒœê·¸"ë¥¼ ì¶”ê°€í•œ ctxë¡œ ê³„ì‚°í•˜ë©´,
  // requiresAll:["fire"] ê°™ì€ ëª¨ë“œê°€ fireì—ë§Œ ì ìš©ë¨.
  const phys = applyOutgoingDamageMods(pkt.phys||0, cloneCtxWithExtraTag(ctx, "physical"));
  const fire = applyOutgoingDamageMods(pkt.fire||0, cloneCtxWithExtraTag(ctx, "fire"));
  const cold = applyOutgoingDamageMods(pkt.cold||0, cloneCtxWithExtraTag(ctx, "cold"));
  const lightning = applyOutgoingDamageMods(pkt.lightning||0, cloneCtxWithExtraTag(ctx, "lightning"));
  const chaos = applyOutgoingDamageMods(pkt.chaos||0, cloneCtxWithExtraTag(ctx, "chaos"));
  return makeDamagePacket(phys, fire, cold, lightning, chaos);
}

function applyEnemyTakenDamageModsPacket(pkt, ctx){
  const phys = applyEnemyTakenDamageMods(pkt.phys||0, cloneCtxWithExtraTag(ctx, "physical"));
  const fire = applyEnemyTakenDamageMods(pkt.fire||0, cloneCtxWithExtraTag(ctx, "fire"));
  const cold = applyEnemyTakenDamageMods(pkt.cold||0, cloneCtxWithExtraTag(ctx, "cold"));
  const lightning = applyEnemyTakenDamageMods(pkt.lightning||0, cloneCtxWithExtraTag(ctx, "lightning"));
  const chaos = applyEnemyTakenDamageMods(pkt.chaos||0, cloneCtxWithExtraTag(ctx, "chaos"));
  return makeDamagePacket(phys, fire, cold, lightning, chaos);
}

// âœ… Enemy Resist(ì €í•­) ì ìš© (ì—†ìœ¼ë©´ 0)
function enemyRes(enemy, key){
  if(!enemy) return 0;
  const v = enemy[key];
  return (typeof v === "number") ? v : 0;
}
function clamp01(x){ return Math.max(0, Math.min(1, x)); }

function applyEnemyResistsPacket(pkt, enemy){
  // res ê°’ì€ 0~0.9 ì •ë„ ê¶Œì¥ (0.75 = 75% ì €í•­)
  const physRes = clamp01(enemyRes(enemy, "physRes"));
  const fireRes = clamp01(enemyRes(enemy, "fireRes"));
  const coldRes = clamp01(enemyRes(enemy, "coldRes"));
  const lightningRes = clamp01(enemyRes(enemy, "lightningRes"));
  const chaosRes = clamp01(enemyRes(enemy, "chaosRes"));

  return makeDamagePacket(
    (pkt.phys||0) * (1 - physRes),
    (pkt.fire||0) * (1 - fireRes),
    (pkt.cold||0) * (1 - coldRes),
    (pkt.lightning||0) * (1 - lightningRes),
    (pkt.chaos||0) * (1 - chaosRes)
  );
}


/* ìƒ˜í”Œ(ì›í•˜ë©´ ì§€ì›Œë„ ë¨): ë³´ìŠ¤ ìƒëŒ€ë¡œ 10% more í”¼í•´
window.GameMods.add({
  id:"sample_vs_boss_more",
  source:"step5_sample",
  scope:"global",
  requiresAll:["boss"],
  stat:"damage",
  op:"more",
  value:0.10
});
*/


/* =========================================================
   (ë‹¤ìŒ ë‹¨ê³„ ì˜ˆê³ )
   - 2ë‹¨ê³„: createItemInstance()ì—ì„œ item.mods[] ìƒì„± (data ìœ ì§€)
   - 3ë‹¨ê³„: recalcFromGear()ì—ì„œ statFromMods() í•œ ê²¹ ì ìš©
   ========================================================= */



/* =========================================================
   Oni Samurai â€” Maintenance/Stability Patch (v1)
   - Prevent "white screen": show error overlay on JS errors
   - Guard render/update calls so one error doesn't kill everything
   - Adds small helpers ($, $$, assertEl) for safer DOM access
   ========================================================= */
const __ONI_BUILD = "stable-2026-02-26";

/** DOM helpers (safe, tiny) */
const $  = (sel, root=document)=> root.querySelector(sel);
const $$ = (sel, root=document)=> Array.from(root.querySelectorAll(sel));
function assertEl(el, name){
  if(!el){
    throw new Error(`Missing DOM element: ${name}`);
  }
  return el;
}

/** Error overlay so you can see what broke instead of a blank screen */
(function setupErrorOverlay(){
  const box = document.createElement("div");
  box.id = "fatalErrorOverlay";
  box.style.cssText = [
    "position:fixed","inset:0","z-index:999999",
    "background:rgba(0,0,0,0.92)","color:#fff",
    "padding:16px","font:12px/1.4 monospace",
    "white-space:pre-wrap","overflow:auto","display:none"
  ].join(";");
  document.addEventListener("DOMContentLoaded", ()=> document.body.appendChild(box));

  function show(title, err){
    const msg = (err && (err.stack || err.message)) ? (err.stack || err.message) : String(err || "");
    box.textContent = `${title}\n\n${msg}\n\n(ì´ í™”ë©´ì´ ëœ¨ë©´, ìœ„ ë©”ì‹œì§€/ìŠ¤í¬ë¦°ìƒ·ì„ ë³´ë‚´ì¤˜)`;
    box.style.display = "block";
  }

  window.addEventListener("error", (e)=>{
    show("JS Error", e.error || e.message || e);
  });

  window.addEventListener("unhandledrejection", (e)=>{
    show("Promise Rejection", e.reason || e);
  });
})();

/** Safe call wrapper (prevents one exception from killing everything) */
function safeCall(fn, label){
  try{ return fn(); }
  catch(err){
    console.error(`[SAFE:${label}]`, err);
    // Overlay handler will show it too (window error may not fire for caught errors)
    const ov = document.getElementById("fatalErrorOverlay");
    if(ov){
      ov.style.display = "block";
      ov.textContent = `SAFE ERROR: ${label}\n\n${err && (err.stack||err.message) ? (err.stack||err.message) : String(err)}`;
    }
    return undefined;
  }
}

let gamePaused = false;
let pauseOpts = { dim: 0.60, blur: 2 };
let resumeFade = 0;
let resumeFadeMax = 10;

const pauseCanvas = document.createElement("canvas");
const pauseCtx = pauseCanvas.getContext("2d");

function capturePausedFrame(opts = pauseOpts){
  pauseOpts = opts || pauseOpts;
  draw();
  pauseCanvas.width = canvas.width;
  pauseCanvas.height = canvas.height;

  pauseCtx.setTransform(1,0,0,1,0,0);
  pauseCtx.globalAlpha = 1;
  pauseCtx.filter = (pauseOpts.blur > 0) ? `blur(${pauseOpts.blur}px)` : "none";
  pauseCtx.drawImage(canvas, 0, 0);
  pauseCtx.filter = "none";

  if(pauseOpts.dim > 0){
    pauseCtx.globalAlpha = pauseOpts.dim;
    pauseCtx.fillStyle = "#000";
    pauseCtx.fillRect(0,0,pauseCanvas.width,pauseCanvas.height);
    pauseCtx.globalAlpha = 1;
  }
}

function pauseGame(opts){
  if(gamePaused) return;
  resumeFade = 0;
  capturePausedFrame(opts);
  gamePaused = true;
}

function resumeGame(){
  if(resumeFade > 0) return;
  resumeFade = resumeFadeMax;
  gamePaused = false;
}

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const ui = document.getElementById("ui");

let uiHeight = 120;

function resize(){
  uiHeight = ui.getBoundingClientRect().height || 120;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - uiHeight;
  if(gamePaused) capturePausedFrame(pauseOpts);
}
resize();
window.addEventListener("resize", ()=>requestAnimationFrame(resize));
requestAnimationFrame(resize);

/* ===== ì‚¬ìš´ë“œ (iOS ëŒ€ì‘: ì‚¬ìš©ì ì…ë ¥ í›„ ìƒì„±) ===== */
let audioCtx = null;
let audioUnlocked = false;

function ensureAudioCtx(){
  if (audioCtx) return true;
  try{
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    return true;
  }catch(e){
    console.log("AudioContext blocked:", e);
    return false;
  }
}

function unlockAudio(){
  if (audioUnlocked) return;
  if (!ensureAudioCtx()) return;

  // iOSëŠ” resumeë„ ì‚¬ìš©ì ì œìŠ¤ì²˜ì—ì„œ í˜¸ì¶œë¼ì•¼ ì•ˆì „í•¨
  audioCtx.resume?.();

  // ë¬´ìŒ ë²„í¼ í•œ ë²ˆ ì¬ìƒí•´ì„œ ì–¸ë½(ë¸Œë¼ìš°ì €ë³„ í˜¸í™˜)
  try{
    const buffer = audioCtx.createBuffer(1, 1, 22050);
    const source = audioCtx.createBufferSource();
    source.buffer = buffer;
    source.connect(audioCtx.destination);
    source.start(0);
  }catch(e){
    // ë¬´ì‹œ
  }

  audioUnlocked = true;
}

// âœ… ì²« í„°ì¹˜/í´ë¦­ì—ì„œ ì˜¤ë””ì˜¤ ì–¸ë½
window.addEventListener("pointerdown", unlockAudio, { once:true });
window.addEventListener("touchstart", unlockAudio, { once:true });
window.addEventListener("mousedown", unlockAudio, { once:true });

function startBGM(){
  let isPlaying = true;
  function getTempo(){
    if(killCount >= 100) return 150;
    if(killCount >= 50) return 130;
    return 110;
  }
  function playBeat(){
    if(!isPlaying) return;

    let tempo = getTempo();
    let beatTime = 60 / tempo;
    let now = audioCtx.currentTime;

    let kick = audioCtx.createOscillator();
    let kickGain = audioCtx.createGain();
    kick.type = "triangle";
    kick.frequency.setValueAtTime(90, now);
    kick.frequency.exponentialRampToValueAtTime(50, now + 0.12);
    kickGain.gain.setValueAtTime(0.18, now);
    kickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    kick.connect(kickGain);
    kickGain.connect(audioCtx.destination);
    kick.start(now);
    kick.stop(now + 0.15);

    let tone = audioCtx.createOscillator();
    let toneGain = audioCtx.createGain();
    tone.type = "square";
    tone.frequency.value = 220;
    toneGain.gain.setValueAtTime(0.06, now + beatTime/2);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + beatTime/2 + 0.1);
    tone.connect(toneGain);
    toneGain.connect(audioCtx.destination);
    tone.start(now + beatTime/2);
    tone.stop(now + beatTime/2 + 0.1);

    setTimeout(playBeat, beatTime * 1000);
  }
  playBeat();
  return { stop: () => isPlaying = false };
}
let bgmOsc;

function swingSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="sawtooth";
  o.frequency.setValueAtTime(700,audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(200,audioCtx.currentTime+0.12);
  g.gain.value=0.15;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.12);
}
function bossUnsheatheSound(){
  let now = audioCtx.currentTime;

  let o1 = audioCtx.createOscillator();
  let g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(120, now);
  o1.frequency.exponentialRampToValueAtTime(600, now + 0.6);
  g1.gain.setValueAtTime(0.4, now);
  g1.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
  o1.connect(g1);
  g1.connect(audioCtx.destination);
  o1.start(now);
  o1.stop(now + 0.6);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(900, now);
  o2.frequency.exponentialRampToValueAtTime(200, now + 0.4);
  g2.gain.setValueAtTime(0.3, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.4);
}
function thudSound(){
  let now = audioCtx.currentTime;

  let o = audioCtx.createOscillator();
  let g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.setValueAtTime(120, now);
  o.frequency.exponentialRampToValueAtTime(55, now + 0.14);
  g.gain.setValueAtTime(0.32, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start(now);
  o.stop(now + 0.18);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(220, now);
  o2.frequency.exponentialRampToValueAtTime(90, now + 0.08);
  g2.gain.setValueAtTime(0.12, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.09);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.09);
}
function hitSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="square";
  o.frequency.value=100;
  g.gain.value=0.25;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.08);
}

/* ===== í”Œë ˆì´ì–´ ===== */
let player={
  x:0,y:0,
  dir:"left",
  speed:5,
  radius:14,

  hp:100,
  maxHp:100,
  baseMaxHp:100,

  baseArmor:0,
  invul:0,
  knockbackX:0,
  knockbackY:0,

  kiOrbs:0,
  maxOrbs:5,
  levelGlow:0,
  ultiActive:false,
  ultiCount:0,
  ultiTimer:0,

  buffs: { dmgMul:1, spdMul:1, atkSpdMul:1 },
  activeBuffs: []
};

player.weapon = {
  name: "Rusty Katana",
  min: 14,
  max: 20,
  critChance: 0.06,
  critMulti: 1.50
};

let map = [];
let mapSize = 30;
let tileSize = 48;

for(let y=0; y<mapSize; y++){
  let row = [];
  for(let x=0; x<mapSize; x++){
    if(x===0 || y===0 || x===mapSize-1 || y===mapSize-1) row.push(1);
    else row.push(0);
  }
  map.push(row);
}

player.x = mapSize * tileSize / 2;
player.y = mapSize * tileSize / 2;

let reachableMask = null;
let hpWaveOffset = 0;
let slowMotion = 0;
let spawnTimer = 0;
let spawnInterval = 90;
let enemies=[];
let packs = [];

/* ============================= */
/* âœ… ì•„ì´í…œ ë“œë/ì„ íƒ ì‹œìŠ¤í…œ     */
/* ============================= */
let loots = [];
let lootOverlayOpen = false;
let pendingLoot = null;

const lootOverlay = document.getElementById("lootOverlay");
const lootCardsEl = document.getElementById("lootCards");

/* ============================= */
/* âœ… POEì‹ Affix/Tier/ilvl ì‹œìŠ¤í…œ */
/* ============================= */
function getMapTier(){
  // mapTier ì†ŒìŠ¤ ë‹¤ì–‘í™”(ê²Œì„/ë§µ/ì „ì—­)
  const mt =
    (typeof Game !== "undefined" && Game && (Game.mapTier ?? Game.map_tier)) ? (Game.mapTier ?? Game.map_tier) :
    (typeof mapTier !== "undefined" ? mapTier :
    (typeof currentMapTier !== "undefined" ? currentMapTier : 1));
  return Math.max(1, Math.floor(mt || 1));
}

function randRange(a,b){ return a + Math.random()*(b-a); }
function randInt(a,b){
  return (a + Math.floor(Math.random() * (b - a + 1)));
}

/**
 * PoE ëŠë‚Œ: areaLevel ~= mapTier ê¸°ë°˜.
 * - mapTierê°€ ì˜¤ë¥¼ìˆ˜ë¡ ilvl ìƒìŠ¹
 * - ì•½ê°„ì˜ ëœë¤ í¸ì°¨
 * - í”Œë ˆì´ì–´ ë ˆë²¨ë„ ì•„ì£¼ ì•½í•˜ê²Œ ë°˜ì˜
 */
function rollItemLevelFromMapTier(mt){
  const t = Math.max(1, mt || 1);
  const areaLevel = 1 + t * 5;              // T1=6, T10=51
  const jitter = randInt(-1, 2);            // ì•½ê°„ í”ë“¤ë¦¼
  const lvl = (typeof level !== "undefined") ? (level || 1) : 1;
  const lvlBonus = Math.floor(lvl * 0.25);  // í”Œë ˆì´ì–´ ë ˆë²¨ ì•½ë°˜ì˜
  return Math.max(1, areaLevel + jitter + lvlBonus);
}

// ===============================
// PoE ë“œë ì •êµí™”: ìŠ¬ë¡¯/íƒ€ì… ë¶„í¬ + ì¤‘ë³µ ë°©ì§€
// ===============================

// ë§µ í‹°ì–´ë³„ ìŠ¬ë¡¯ ë¶„í¬(ëŒ€ëµ). í•©ì€ 1.0 í•„ìš” ì—†ìŒ(ê°€ì¤‘ì¹˜).
const SLOT_WEIGHT_TABLE = [
  // mapTier:1..10 (0ì€ dummy)
  null,
  { weapon: 55, chest: 20, helmet: 12, boots: 8, ring: 5 },
  { weapon: 52, chest: 21, helmet: 12, boots: 9, ring: 6 },
  { weapon: 48, chest: 22, helmet: 12, boots: 10, ring: 8 },
  { weapon: 45, chest: 22, helmet: 12, boots: 11, ring: 10 },
  { weapon: 42, chest: 22, helmet: 12, boots: 12, ring: 12 },
  { weapon: 40, chest: 22, helmet: 12, boots: 13, ring: 13 },
  { weapon: 38, chest: 22, helmet: 12, boots: 14, ring: 14 },
  { weapon: 36, chest: 22, helmet: 12, boots: 15, ring: 15 },
  { weapon: 35, chest: 22, helmet: 12, boots: 15, ring: 16 },
  { weapon: 34, chest: 22, helmet: 12, boots: 16, ring: 16 },
];

function clampMapTier(t){
  t = (t|0) || 1;
  if(t < 1) t = 1;
  if(t > 10) t = 10;
  return t;
}


// ===============================
// âœ… PoE Base-Specific Mod Pool Bias (Bì•ˆ)
// - ìŠ¬ë¡¯/íƒœê·¸/ë² ì´ìŠ¤(modBias) ê¸°ë°˜ìœ¼ë¡œ affix ì„ íƒ í™•ë¥ ì„ ë¯¸ì„¸ ì¡°ì •
// ===============================
const SLOT_MOD_BIAS = {
  weapon: { dmgMul:1.25, atkSpdMul:1.10, critChanceAdd:1.10, critMultiAdd:1.05, rangeMul:1.05, armorAdd:0.15 },
  chest:  { armorAdd:1.25, maxHpAdd:1.15, hpRegen:1.05, dmgMul:0.20, atkSpdMul:0.20, critChanceAdd:0.20 },
  helm:   { armorAdd:1.15, maxHpAdd:1.10, hpRegen:1.10, dmgMul:0.25 },
  boots:  { spdMul:1.20, armorAdd:1.05, maxHpAdd:1.05, dmgMul:0.25 },
  ring:   { maxHpAdd:1.10, hpRegen:1.05, dmgMul:0.60, critChanceAdd:0.60 }
};

// íƒœê·¸ë³„ 2ì°¨ ë°”ì´ì–´ìŠ¤(ëŠìŠ¨í•œ ê°€ì¤‘ì¹˜, í•„í„°ë§ ì•„ë‹˜)
const TAG_MOD_BIAS = {
  physical: { dmgMul:1.20, critMultiAdd:1.10 },
  melee:    { dmgMul:1.10, rangeMul:1.05 },
  spell:    { dmgMul:0.85, critChanceAdd:0.90 }, // spell ì „ìš© ìŠ¤íƒ¯ì´ ìˆë‹¤ë©´ ì—¬ê¸°ì„œ ê°•í™” ê°€ëŠ¥
  caster:   { hpRegen:1.10 },
  block:    { armorAdd:1.10 },
  tank:     { armorAdd:1.20, maxHpAdd:1.15 },
  speed:    { spdMul:1.20, atkSpdMul:1.10 }
};

// ===============================
// âœ… Affix Pool ë¶„ë¦¬ (PoEì‹) - Bì•ˆ Step(1)
// - ë‹¨ìˆœ "ë¬´ê¸°/ë°©ì–´êµ¬" ë¶„ë¦¬ë¥¼ ë„˜ì–´ì„œ
//   melee_phys / spell_cast / tank_def ê°™ì€ "í’€"ë¡œ ë‚˜ëˆ ì„œ í™•ë¥ /í›„ë³´ë¥¼ ì¡°ì ˆ
// ===============================

// affixì—ì„œ "í’€"ì„ ìë™ ì¶”ë¡  (ëª…ì‹œ pool ì—†ìœ¼ë©´ group/stat/íƒœê·¸ë¡œ ì¶”ë¡ )
function inferAffixPool(aff, opts){
  if(!aff) return "misc";
  if(aff.pool) return aff.pool;
  if(aff._pool) return aff._pool;

  const g = String(aff.group || aff.stat || "").toLowerCase();
  const stat = String(aff.stat || "").toLowerCase();
  const reqAll = Array.isArray(aff.requiresAll) ? aff.requiresAll : [];
  const hasReq = (t)=>reqAll.includes(t);

  let pool = "misc";

  // ë°©ì–´/ìœ í‹¸ ê³µí†µ
  if(g.includes("resist") || stat.includes("resist")) pool = "resist";
  else if(g.includes("maxhp") || stat.includes("maxhp") || g.includes("life")) pool = "life";
  else if(g.includes("hpregen") || stat.includes("hpregen")) pool = "regen";
  else if(g.includes("arm") || stat.includes("armor")) pool = "def_armor";
  else if(g.includes("evasion") || stat.includes("evasion")) pool = "def_evasion";
  else if(g.includes("es") || stat.includes("energy")) pool = "def_es";
  else if(g.includes("spd") || stat.includes("spd") || g.includes("movespeed")) pool = "move";

  // ê³µê²© ê³„ì—´
  else if(g.includes("cast") || stat.includes("cast")) pool = "spell_cast";
  else if(g.includes("spell") || stat.includes("spell")) pool = "spell_power";
  else if(g.includes("mana") || stat.includes("mana")) pool = "mana";
  else if(g.includes("bleed") || stat.includes("bleed")) pool = "melee_bleed";
  else if(g.includes("atkspd") || stat.includes("atkspd") || g.includes("attackspeed")) pool = "melee_speed";
  else if(g.includes("critchance") || stat.includes("critchance")) pool = (hasReq("spell") ? "spell_crit" : "melee_crit");
  else if(g.includes("critmulti") || stat.includes("critmulti")) pool = (hasReq("spell") ? "spell_crit" : "melee_crit");
  else if(g.includes("dmgmul") || stat.includes("dmgmul") || g.includes("phys") || stat.includes("phys")) pool = "melee_phys";
  else if(g.includes("range") || stat.includes("range")) pool = "melee_range";

  // ë°˜ì§€ ì„±í–¥
  if(opts && opts.tmpl && (opts.tmpl.slot === "ring" || opts.tmpl.slot === "amulet")){
    if(pool === "melee_phys" || pool === "melee_speed" || pool === "melee_crit") pool = "ring_offense";
    if(pool === "spell_power" || pool === "spell_cast" || pool === "spell_crit") pool = "ring_element";
  }

  aff._pool = pool;
  return pool;
}

// ì»¨í…ìŠ¤íŠ¸(ìŠ¬ë¡¯/íƒœê·¸/ë² ì´ìŠ¤)ì— ë”°ë¼ ì–´ë–¤ í’€ì„ ë” ì„ í˜¸í• ì§€ ê°€ì¤‘ì¹˜ ìƒì„±
// ===============================
// âœ… Hard Pool Locks (ì¶œí˜„ ê°€ëŠ¥/ë¶ˆê°€ ì ê¸ˆ)
// - weaponì—ì„œ spell íƒœê·¸ê°€ ì—†ìœ¼ë©´ spell_* / mana í’€ì€ ì™„ì „ ì°¨ë‹¨
// - weaponì—ì„œ spell íƒœê·¸ê°€ ìˆìœ¼ë©´ melee_* í’€ì€ ì™„ì „ ì°¨ë‹¨
// (ìƒì¡´/ì €í•­/ìœ í‹¸ í’€ì€ í—ˆìš©: PoEì²˜ëŸ¼ 'ê½'ì€ ìƒì¡´/ìœ í‹¸ë¡œ ë‚¨ê²¨ë‘ )
// ===============================
function hardPoolAllowed(poolName, itemTags, opts){
  const tags = Array.isArray(itemTags) ? itemTags : [];
  const has = (t)=>tags.includes(t);
  const slot = opts && opts.tmpl ? opts.tmpl.slot : null;

  // -------- ë¬´ê¸°: ì§€íŒ¡ì´(ì£¼ë¬¸) vs ê·¼ì ‘(ì „ìŸì§€íŒ¡ì´/ì–‘ì†ë¬´ê¸°) --------
  if(slot === "weapon"){
    const isSpellWeapon = has("spell");
    if(isSpellWeapon){
      if(String(poolName).startsWith("melee_")) return false;
    }else{
      if(String(poolName).startsWith("spell_")) return false;
      if(poolName === "mana") return false;
    }
  }

  // -------- Cì•ˆ: ë°©ì–´êµ¬/íˆ¬êµ¬ëŠ” ìˆœìˆ˜ ìƒì¡´/ë°©ì–´ ì „ìš© (ê³µê²©/ì£¼ë¬¸/í¡ìˆ˜ ì°¨ë‹¨) --------
  if(slot === "armor" || slot === "helmet"){
    if(String(poolName).startsWith("melee_")) return false;
    if(String(poolName).startsWith("spell_")) return false;
    if(poolName === "ring_offense" || poolName === "ring_element") return false;
    if(poolName === "mana") return false;

    // lifeLeechëŠ” ì•…ì„¸/ë¬´ê¸°ë§Œ
    if(poolName === "life_leech") return false;

    // í—ˆìš© í’€ë§Œ í†µê³¼
    const allowed = new Set(["life","regen","resist","def_armor","def_evasion","def_es","move","misc"]);
    if(!allowed.has(poolName)) return false;
  }

  // -------- Cì•ˆ: ë°˜ì§€/ëª©ê±¸ì´ëŠ” ê³µê²© ì˜µì…˜ í—ˆìš© --------
  if(slot === "ring" || slot === "amulet"){
    // ì „ë¶€ í—ˆìš©(í•˜ë“œë½ ì—†ìŒ). ë‹¨, slot===amuletì´ë©´ inferì—ì„œ ring_*ë¡œ ë°”ê¿”ì¤„ ìˆ˜ ìˆìŒ.
    return true;
  }

  return true;
}

function applyHardPoolLocksToWeights(w, itemTags, opts){
  for(const k in w){
    if(!hardPoolAllowed(k, itemTags, opts)) w[k] = 0;
  }
  return w;
}

function poolWeightsForContext(kind, itemTags, opts){
  const tags = Array.isArray(itemTags) ? itemTags : [];
  const has = (t)=>tags.includes(t);
  const slot = opts && opts.tmpl ? opts.tmpl.slot : null;

  // ê¸°ë³¸ ê°€ì¤‘ì¹˜(ëª¨ë“  ì•„ì´í…œ ê³µí†µ)
  const w = {
    life: 1.0, resist: 1.0, regen: 0.6, move: 0.5,
    def_armor: 0.8, def_es: 0.8, def_evasion: 0.8,
    melee_phys: 0.7, melee_speed: 0.6, melee_crit: 0.5, melee_bleed: 0.35, melee_range: 0.25,
    spell_power: 0.7, spell_cast: 0.6, spell_crit: 0.45, mana: 0.45,
    ring_offense: 0.7, ring_element: 0.7,
    misc: 0.25
  };

  // ìŠ¬ë¡¯ ê¸°ë°˜
  if(slot === "weapon"){
    w.life *= 0.35; w.resist *= 0.35;
    w.def_armor *= 0.10; w.def_es *= 0.10; w.def_evasion *= 0.10; w.move *= 0.10;

    // íƒœê·¸ ê¸°ë°˜(ë¬´ê¸°)
    if(has("spell")){
      w.spell_power *= 2.0; w.spell_cast *= 1.7; w.spell_crit *= 1.25; w.mana *= 1.2;
      w.melee_phys *= 0.15; w.melee_speed *= 0.20; w.melee_crit *= 0.20; w.melee_bleed *= 0.10;
    }else{
      // ê³µê²©/ê·¼ì ‘
      w.melee_phys *= 1.8; w.melee_speed *= 1.45; w.melee_crit *= 1.15; w.melee_range *= 1.05;
      if(has("bleed")) w.melee_bleed *= 2.0;
      w.spell_power *= 0.15; w.spell_cast *= 0.15; w.spell_crit *= 0.15; w.mana *= 0.20;
    }
  }
  else if(slot === "chest" || slot === "helm" || slot === "boots"){
    w.life *= 1.35; w.resist *= 1.25;
    w.melee_phys *= 0.10; w.melee_speed *= 0.10; w.melee_crit *= 0.10;
    w.spell_power *= 0.10; w.spell_cast *= 0.10; w.spell_crit *= 0.10; w.mana *= 0.10;

    if(slot === "boots"){ w.move *= 2.0; }
    if(has("armor")) w.def_armor *= 1.6;
    if(has("es")) w.def_es *= 1.6;
    if(has("evasion")) w.def_evasion *= 1.6;
  }
  else if(slot === "ring"){
    w.life *= 1.15; w.resist *= 1.45;
    w.ring_offense *= 1.2; w.ring_element *= 1.2;
    // ë°˜ì§€ëŠ” ê³µê²©/ë°©ì–´ ì„ì´ê²Œ ìœ ì§€
  }

  // prefix/suffixì— ë”°ë¥¸ ë¶„ìœ„ê¸°(ì•„ì£¼ ì•½í•˜ê²Œ)
  if(kind === "prefix"){
    w.life *= 1.10; w.def_armor *= 1.10; w.def_es *= 1.10; w.def_evasion *= 1.10;
    w.melee_phys *= 1.05; w.spell_power *= 1.05;
  }else{
    w.resist *= 1.20; w.move *= 1.10; w.critChanceAdd ? (w.melee_crit *= 1.05) : 0;
  }

  // ë² ì´ìŠ¤ modBias(ê·¸ë£¹ ë°”ì´ì–´ìŠ¤)ì™€ëŠ” ë³„ê°œë¡œ, baseId íŠ¹ì„± íƒœê·¸ë¡œ í’€ì„ ì¡°ê¸ˆ ë” ë³´ì •
  if(opts && opts.tmpl && opts.tmpl.tags){
    const bt = opts.tmpl.tags;
    const bHas = (t)=>bt.includes(t);
    // ì „ìŸì§€íŒ¡ì´(ê·¼ì ‘) ê°•ì¡°
    if(bHas("warstaff")){
      w.melee_phys *= 1.25; w.melee_range *= 1.20; w.melee_speed *= 1.10;
      w.spell_power *= 0.35; w.spell_cast *= 0.35;
    }
    // ì§€íŒ¡ì´(ì£¼ë¬¸) ê°•ì¡°
    if(bHas("staff")){
      w.spell_power *= 1.35; w.spell_cast *= 1.25; w.spell_crit *= 1.10; w.mana *= 1.15;
      w.melee_phys *= 0.35; w.melee_speed *= 0.35; w.melee_crit *= 0.35;
    }
  }

  return applyHardPoolLocksToWeights(w, itemTags, opts);
}

function getBiasMul(map, key, group){
  const row = map && map[key];
  if(!row) return 1;
  const m = row[group];
  return (typeof m === "number" && isFinite(m)) ? m : 1;
}

function affixEffectiveWeight(affix, opts){
  const baseW = Math.max(0, (affix && affix.weight != null) ? affix.weight : 100);
  if(!affix) return 0;
  const group = affix.group || "";
  let mul = 1;

  const tmpl = opts && opts.tmpl ? opts.tmpl : null;
  const tags = opts && Array.isArray(opts.itemTags) ? opts.itemTags : null;

  // ìŠ¬ë¡¯ ë°”ì´ì–´ìŠ¤
  if(tmpl && tmpl.slot) mul *= getBiasMul(SLOT_MOD_BIAS, tmpl.slot, group);

  // ë² ì´ìŠ¤ ì „ìš© ë°”ì´ì–´ìŠ¤
  if(tmpl && tmpl.modBias && typeof tmpl.modBias === "object"){
    const bm = tmpl.modBias[group];
    if(typeof bm === "number" && isFinite(bm)) mul *= bm;
  }

  // íƒœê·¸ ë°”ì´ì–´ìŠ¤
  if(tags){
    for(const t of tags){
      mul *= getBiasMul(TAG_MOD_BIAS, t, group);
    }
  }

  // ê³¼ë„í•œ ì™œê³¡ ë°©ì§€
  if(mul < 0.05) mul = 0.05;
  if(mul > 6.0) mul = 6.0;

  return baseW * mul;
}

function weightedPickAffix(list, opts){
  const arr = Array.isArray(list) ? list : [];
  if(!arr.length) return null;

  let sum = 0;
  const ws = new Array(arr.length);
  for(let i=0;i<arr.length;i++){
    const w = affixEffectiveWeight(arr[i], opts);
    ws[i] = w;
    sum += w;
  }
  if(!(sum > 0)) return arr[Math.floor(Math.random()*arr.length)] || null;

  let r = Math.random() * sum;
  for(let i=0;i<arr.length;i++){
    r -= ws[i];
    if(r <= 0) return arr[i];
  }
  return arr[arr.length-1] || null;
}

function weightedPickFromMap(obj){
  const entries = Object.entries(obj || {});
  let total = 0;
  for(const [,w] of entries) total += Math.max(0, w||0);
  if(total <= 0) return null;
  let r = Math.random() * total;
  for(const [k,w0] of entries){
    const w = Math.max(0, w0||0);
    r -= w;
    if(r <= 0) return k;
  }
  return entries[entries.length-1]?.[0] || null;
}

function pickSlotForMapTier(mapTier){
  const t = clampMapTier(mapTier);
  const row = SLOT_WEIGHT_TABLE[t] || SLOT_WEIGHT_TABLE[1];
  return weightedPickFromMap(row) || "weapon";
}

// íƒ€ì…ë³„ ë©€í‹°í”Œë¼ì´ì–´(â€œë©‹/í¬ì†Œì„±â€ ëŠë‚Œ). ë¬´ê¸°ë§Œ ì ìš©.
const WEAPON_TYPE_WEIGHT_MULT = {
  "2h_sword": 1.00,
  "2h_axe":   0.95,
  "2h_mace":  0.95,
  "staff":    0.90,
  "warstaff": 0.85
};

function inferWeaponType(base){
  const tags = base?.tags || [];
  if(tags.includes("2h_sword")) return "2h_sword";
  if(tags.includes("2h_axe")) return "2h_axe";
  if(tags.includes("2h_mace")) return "2h_mace";
  if(tags.includes("warstaff")) return "warstaff";
  if(tags.includes("staff")) return "staff";
  return null;
}

function getEligibleBasePoolBySlot(mapTier, slot){
  const t = clampMapTier(mapTier);
  return (ITEM_POOL || []).filter(b=>{
    if(!b) return false;
    if(slot && b.slot !== slot) return false;
    const bt = (b.baseTier ?? 1);
    if(bt > t) return false; // í‹°ì–´ í•´ê¸ˆ
    return true;
  });
}

function pickBaseForMapTier(mapTier, slot){
  const t = clampMapTier(mapTier);
  const wantTier = pickBaseTierForMap(t); // ì´ë¯¸ step3ì—ì„œ ì •ì˜ë¨
  // 1) ì›í•˜ëŠ” í‹°ì–´ë¶€í„° ì•„ë˜ë¡œ ë‚´ë ¤ì˜¤ë©° ì°¾ê¸°
  for(let tier = wantTier; tier >= 1; tier--){
    const pool = getEligibleBasePoolBySlot(t, slot).filter(b => (b.baseTier ?? 1) === tier);
    if(!pool.length) continue;

    // ê°€ì¤‘ì¹˜ ì ìš©(ë¬´ê¸°ëŠ” íƒ€ì… ë©€í‹°í”Œë¼ì´ì–´ ì¶”ê°€)
    const weights = pool.map(b=>{
      let w = (b.weight ?? 100);
      if(b.slot === "weapon"){
        const wt = inferWeaponType(b);
        const mult = wt ? (WEAPON_TYPE_WEIGHT_MULT[wt] ?? 1) : 1;
        w = w * mult;
      }
      return Math.max(1, w);
    });

    // ì•ˆì „ ê°€ì¤‘ì¹˜ í”½
    let total = 0;
    for(const w of weights) total += w;
    let r = Math.random() * total;
    for(let i=0;i<pool.length;i++){
      r -= weights[i];
      if(r <= 0) return pool[i];
    }
    return pool[pool.length-1];
  }

  // 2) ìµœí›„ fallback: ì•„ë¬´ê±°ë‚˜
  const any = getEligibleBasePoolBySlot(t, slot);
  return any[0] || null;
}



// âœ… item level (ilvl)
function getItemLevel(){
  return rollItemLevelFromMapTier(getMapTier());
}

// âœ… ë§µ í‹°ì–´ â†” ë² ì´ìŠ¤ í‹°ì–´ í•´ê¸ˆ(ìƒí•œ)
// (moved) getMaxBaseTierForMap is defined above
function getMaxBaseTierForMap(t){ return 5; }

function getBaseTierDistribution(mt){
  const t = Math.max(1, Math.floor(mt || 1));
  if(BASE_TIER_DISTRIBUTION[t]) return BASE_TIER_DISTRIBUTION[t];
  // 10 ì´ìƒì€ 10ì„ ê¸°ì¤€ìœ¼ë¡œ ë” ê³ í‹°ì–´ í¸ì¤‘
  return BASE_TIER_DISTRIBUTION[10];
}

function pickBaseTierForMap(mt){
  const dist = getBaseTierDistribution(mt);
  // í•´ê¸ˆ ìƒí•œ ì ìš©
  const maxTier = getMaxBaseTierForMap(mt);
  let total = 0;
  for(let i=0;i<dist.length;i++){
    const tier = i+1;
    if(tier > maxTier) continue;
    total += dist[i];
  }
  let r = Math.random() * total;
  for(let i=0;i<dist.length;i++){
    const tier = i+1;
    if(tier > maxTier) continue;
    r -= dist[i];
    if(r <= 0) return tier;
  }
  return Math.min(5, maxTier);
}

function tierCurveMultiplier(mt, baseTier){
  // dist ê¸°ë°˜ multiplier: 0~1
  const dist = getBaseTierDistribution(mt);
  const idx = Math.max(0, Math.min(4, (baseTier||1)-1));
  return dist[idx] || 0;
}

function getMaxBaseTierForMap(t){
  // âœ… ë§µ í‹°ì–´ â†” ë² ì´ìŠ¤ í‹°ì–´ ì—°ë™ (ëŒ€ì¶© PoE ëŠë‚Œ)
  // T1~2 : tier1 / T3~4 : tier2 / T5~6 : tier3 / T7~8 : tier4 / T9+ : tier5
  if(t <= 2) return 1;
  if(t <= 4) return 2;
  if(t <= 6) return 3;
  if(t <= 8) return 4;
  return 5;
}

function getEligibleBasePool(mapTier){
  const mt = Math.max(1, (mapTier ?? getMapTier()));
  const pool = Array.isArray(ITEM_POOL) ? ITEM_POOL : [];
  const maxTier = getMaxBaseTierForMap(mt);

  return pool.filter(base=>{
    if(!base) return false;
    const baseTier = (base.baseTier ?? 1);
    if(baseTier < 1 || baseTier > 5) return false;
    if(baseTier > maxTier) return false;
    // minIlvlë„ ìˆ«ì ë³´ì •
    base.minIlvl = (base.minIlvl ?? 1);
    base.weight = (base.weight ?? 100);
    return true;
  });
}

function pickBaseTemplateUnique(pool, usedIds){
  // ê°€ì¤‘ì¹˜ ë“œë
  const picks = pool.filter(p => !usedIds.has(p.id));
  if(!picks.length) return null;
  const tmp = picks.map(p => ({
    ref:p,
    weight: Math.max(1, (p.weight ?? 50) * (1 + ((p.baseTier ?? 1)-1)*0.18))
  }));
  const chosen = weightedPick(tmp, "weight");
  return chosen ? chosen.ref : null;
}

function weightedPick(list, weightKey="weight"){
  let total = 0;
  for(const it of list) total += (it[weightKey] ?? 0);
  let r = Math.random() * total;
  for(const it of list){
    r -= (it[weightKey] ?? 0);
    if(r <= 0) return it;
  }
  return list[list.length - 1];
}


const AFFIX_DB = {
  // ===============================
  // PREFIX: ì£¼ë¡œ "í•µì‹¬ ë°©í–¥" (í”¼í•´% / ì£¼ë¬¸% / ë°©ì–´% / ì €í•­ / ìµœëŒ€ìƒëª…ë ¥)
  // SUFFIX: ì£¼ë¡œ "ë³´ì¡° ê°•í™”" (ê³µì†/ë²”ìœ„/ì¹˜í™•/ì¹˜í”¼/ì´ì†/ì¬ìƒ/í¡ìˆ˜ ë“±)
  // - tiers: T6(ë‚®ìŒ) ~ T1(ë†’ìŒ)
  // - minIlvl: ilvl ê²Œì´íŒ…
  // ===============================
  prefix: [

    // ====== ë¬´ê¸°: ê·¼ì ‘(ê¸°ë³¸) ======
    {
      id:"p_melee_phys",
      name:"ë§¹ë ¬í•œ",
      group:"phys",
      weight:120,
      tiers:[
        {t:6,minIlvl:1, min:4,  max:8},
        {t:5,minIlvl:10,min:8,  max:12},
        {t:4,minIlvl:20,min:12, max:16},
        {t:3,minIlvl:35,min:16, max:22},
        {t:2,minIlvl:50,min:22, max:30},
        {t:1,minIlvl:70,min:30, max:40}
      ],
      apply:(d,v)=>{ d.dmgMul = (d.dmgMul||1) * (1+v/100); }
    },
    {
      id:"p_melee_flat_phys",
      name:"ì”í˜¹í•œ",
      group:"phys_flat",
      weight:110,
      tiers:[
        {t:6,minIlvl:1, min:1, max:2},
        {t:5,minIlvl:10,min:2, max:3},
        {t:4,minIlvl:20,min:3, max:5},
        {t:3,minIlvl:35,min:5, max:7},
        {t:2,minIlvl:50,min:7, max:10},
        {t:1,minIlvl:70,min:10,max:14}
      ],
      apply:(d,v)=>{ d.flatDamage = (d.flatDamage||0) + v; }
    },

    // ====== ë¬´ê¸°: ì›ì†Œ(ê·¼ì ‘/ì£¼ë¬¸ ê³µí†µ) ======
    {
      id:"p_elem_fire",
      name:"ë¶ˆíƒ€ëŠ”",
      group:"fire_damage",
      weight:90,
      tiers:[
        {t:6,minIlvl:1, min:4,  max:8},
        {t:5,minIlvl:10,min:8,  max:12},
        {t:4,minIlvl:20,min:12, max:16},
        {t:3,minIlvl:35,min:16, max:22},
        {t:2,minIlvl:50,min:22, max:30},
        {t:1,minIlvl:70,min:30, max:40}
      ],
      apply:(d,v)=>{ d.fireMul = (d.fireMul||1) * (1+v/100); }
    },
    {
      id:"p_elem_cold",
      name:"ì„œë¦¿ë°œì˜",
      group:"cold_damage",
      weight:85,
      tiers:[
        {t:6,minIlvl:1, min:4,  max:8},
        {t:5,minIlvl:10,min:8,  max:12},
        {t:4,minIlvl:20,min:12, max:16},
        {t:3,minIlvl:35,min:16, max:22},
        {t:2,minIlvl:50,min:22, max:30},
        {t:1,minIlvl:70,min:30, max:40}
      ],
      apply:(d,v)=>{ d.coldMul = (d.coldMul||1) * (1+v/100); }
    },
    {
      id:"p_elem_light",
      name:"í­í’ì˜",
      group:"light_damage",
      weight:85,
      tiers:[
        {t:6,minIlvl:1, min:4,  max:8},
        {t:5,minIlvl:10,min:8,  max:12},
        {t:4,minIlvl:20,min:12, max:16},
        {t:3,minIlvl:35,min:16, max:22},
        {t:2,minIlvl:50,min:22, max:30},
        {t:1,minIlvl:70,min:30, max:40}
      ],
      apply:(d,v)=>{ d.lightMul = (d.lightMul||1) * (1+v/100); }
    },

    // ====== ë¬´ê¸°: ì£¼ë¬¸ ì „ìš©(ì§€íŒ¡ì´) ======
    {
      id:"p_spell_power",
      name:"ë¹„ì „ì˜",
      group:"spell_damage",
      requiresAll:["spell"],
      weight:120,
      tiers:[
        {t:6,minIlvl:1, min:4,  max:8},
        {t:5,minIlvl:10,min:8,  max:12},
        {t:4,minIlvl:20,min:12, max:16},
        {t:3,minIlvl:35,min:16, max:22},
        {t:2,minIlvl:50,min:22, max:30},
        {t:1,minIlvl:70,min:30, max:40}
      ],
      apply:(d,v)=>{ d.spellMul = (d.spellMul||1) * (1+v/100); }
    },

    // ===============================
    // ë°©ì–´êµ¬/íˆ¬êµ¬: PREFIX (í•µì‹¬ ìƒì¡´/ë°©ì–´)
    // ===============================
    {
      id:"p_life_big",
      name:"ê±°ëŒ€í•œ",
      group:"life",
      weight:130,
      tiers:[
        {t:6,minIlvl:1, min:8,  max:12},
        {t:5,minIlvl:10,min:12, max:18},
        {t:4,minIlvl:20,min:18, max:25},
        {t:3,minIlvl:35,min:25, max:35},
        {t:2,minIlvl:50,min:35, max:45},
        {t:1,minIlvl:70,min:45, max:60}
      ],
      apply:(d,v)=>{ d.maxHP = (d.maxHP||0) + v; }
    },
    {
      id:"p_armor_pct",
      name:"ê²¬ê³ í•œ",
      group:"armor_pct",
      weight:120,
      tiers:[
        {t:6,minIlvl:1, min:6,  max:10},
        {t:5,minIlvl:10,min:10, max:14},
        {t:4,minIlvl:20,min:14, max:18},
        {t:3,minIlvl:35,min:18, max:24},
        {t:2,minIlvl:50,min:24, max:32},
        {t:1,minIlvl:70,min:32, max:45}
      ],
      apply:(d,v)=>{ d.armorMul = (d.armorMul||1) * (1+v/100); }
    },
    {
      id:"p_res_all",
      name:"ìˆ˜í˜¸ì˜",
      group:"resist_all",
      weight:90,
      tiers:[
        {t:6,minIlvl:1, min:3,  max:6},
        {t:5,minIlvl:12,min:6,  max:9},
        {t:4,minIlvl:24,min:9,  max:12},
        {t:3,minIlvl:36,min:12, max:16},
        {t:2,minIlvl:52,min:16, max:20},
        {t:1,minIlvl:72,min:20, max:26}
      ],
      apply:(d,v)=>{
        d.resAll = (d.resAll||0) + v;
      }
    },
    {
      id:"p_res_fire",
      name:"ë¶ˆêµ´ì˜",
      group:"resist_fire",
      weight:95,
      tiers:[
        {t:6,minIlvl:1, min:6,  max:10},
        {t:5,minIlvl:10,min:10, max:14},
        {t:4,minIlvl:20,min:14, max:18},
        {t:3,minIlvl:35,min:18, max:22},
        {t:2,minIlvl:50,min:22, max:28},
        {t:1,minIlvl:70,min:28, max:35}
      ],
      apply:(d,v)=>{ d.resFire = (d.resFire||0) + v; }
    },
    {
      id:"p_res_cold",
      name:"ëƒ‰í˜¹ì˜",
      group:"resist_cold",
      weight:95,
      tiers:[
        {t:6,minIlvl:1, min:6,  max:10},
        {t:5,minIlvl:10,min:10, max:14},
        {t:4,minIlvl:20,min:14, max:18},
        {t:3,minIlvl:35,min:18, max:22},
        {t:2,minIlvl:50,min:22, max:28},
        {t:1,minIlvl:70,min:28, max:35}
      ],
      apply:(d,v)=>{ d.resCold = (d.resCold||0) + v; }
    },
    {
      id:"p_res_light",
      name:"ë²ˆê°œì˜",
      group:"resist_light",
      weight:95,
      tiers:[
        {t:6,minIlvl:1, min:6,  max:10},
        {t:5,minIlvl:10,min:10, max:14},
        {t:4,minIlvl:20,min:14, max:18},
        {t:3,minIlvl:35,min:18, max:22},
        {t:2,minIlvl:50,min:22, max:28},
        {t:1,minIlvl:70,min:28, max:35}
      ],
      apply:(d,v)=>{ d.resLight = (d.resLight||0) + v; }
    }

  ],

  // ===============================
  // SUFFIX
  // ===============================
  suffix: [

    // ===== ë¬´ê¸° ê³µí†µ ë³´ì¡°(ìš”ì²­: ê³µì†/ë²”ìœ„/ì¹˜í™•/ì¹˜í”¼ëŠ” ì ‘ë¯¸) =====
    {
      id:"s_attack_speed",
      name:"í•™ì‚´ìì˜",
      group:"attackspeed",
      weight:100,
      tiers:[
        {t:6,minIlvl:1, min:1, max:2},
        {t:5,minIlvl:10,min:2, max:3},
        {t:4,minIlvl:20,min:3, max:4},
        {t:3,minIlvl:35,min:4, max:6},
        {t:2,minIlvl:50,min:6, max:8},
        {t:1,minIlvl:70,min:8, max:12}
      ],
      apply:(d,v)=>{ d.attackSpeedMul = (d.attackSpeedMul||1) * (1+v/100); }
    },
    {
      id:"s_range",
      name:"í™•ì¥ì˜",
      group:"range",
      weight:90,
      tiers:[
        {t:6,minIlvl:1, min:1, max:2},
        {t:5,minIlvl:10,min:2, max:3},
        {t:4,minIlvl:20,min:3, max:4},
        {t:3,minIlvl:35,min:4, max:6},
        {t:2,minIlvl:50,min:6, max:8},
        {t:1,minIlvl:70,min:8, max:12}
      ],
      apply:(d,v)=>{ d.rangeMul = (d.rangeMul||1) * (1+v/100); }
    },
    {
      id:"s_crit_chance",
      name:"ì‚´ê¸°ì˜",
      group:"critchance",
      weight:90,
      tiers:[
        {t:6,minIlvl:1, min:0.5, max:1.0},
        {t:5,minIlvl:10,min:1.0, max:1.5},
        {t:4,minIlvl:20,min:1.5, max:2.5},
        {t:3,minIlvl:35,min:2.5, max:3.5},
        {t:2,minIlvl:50,min:3.5, max:4.5},
        {t:1,minIlvl:70,min:4.5, max:6.0}
      ],
      apply:(d,v)=>{ d.critChanceAdd = (d.critChanceAdd||0) + (v/100); }
    },
    {
      id:"s_crit_multi",
      name:"ì•”ì‚´ìì˜",
      group:"critmulti",
      weight:75,
      tiers:[
        {t:6,minIlvl:1, min:10, max:20},
        {t:5,minIlvl:12,min:20, max:28},
        {t:4,minIlvl:24,min:28, max:36},
        {t:3,minIlvl:36,min:36, max:45},
        {t:2,minIlvl:52,min:45, max:55},
        {t:1,minIlvl:72,min:55, max:70}
      ],
      apply:(d,v)=>{ d.critMultiAdd = (d.critMultiAdd||0) + (v/100); }
    },

    // ===== ìƒì¡´(ëª¨ë“  ìŠ¬ë¡¯ ê³µí†µ: ì•…ì„¸ì—ë„ í—ˆìš©) =====
    {
      id:"s_max_life",
      name:"ìƒëª…ì˜",
      group:"life",
      weight:120,
      tiers:[
        {t:6,minIlvl:1, min:8,  max:12},
        {t:5,minIlvl:10,min:12, max:18},
        {t:4,minIlvl:20,min:18, max:25},
        {t:3,minIlvl:35,min:25, max:35},
        {t:2,minIlvl:50,min:35, max:45},
        {t:1,minIlvl:70,min:45, max:60}
      ],
      apply:(d,v)=>{ d.maxHP = (d.maxHP||0) + v; }
    },

    // ìƒëª…ë ¥ í¡ìˆ˜ëŠ” ì•…ì„¸/ë¬´ê¸°ì—ë§Œ (ë°©ì–´êµ¬/íˆ¬êµ¬ëŠ” Cì•ˆì´ë¼ ì°¨ë‹¨)
    {
      id:"s_life_leech",
      name:"í¡ìˆ˜ì˜",
      group:"life_leech",
      weight:70,
      tiers:[
        {t:6,minIlvl:10,min:1, max:2},
        {t:5,minIlvl:25,min:2, max:3},
        {t:4,minIlvl:40,min:3, max:4},
        {t:3,minIlvl:55,min:4, max:5},
        {t:2,minIlvl:70,min:5, max:6},
        {t:1,minIlvl:80,min:6, max:8}
      ],
      apply:(d,v)=>{ d.lifeLeech = (d.lifeLeech||0) + (v/100); }
    },

    // ===== ë°©ì–´êµ¬/íˆ¬êµ¬: SUFFIX (ë³´ì¡° ìœ í‹¸) =====
    {
      id:"s_move_speed",
      name:"ì‹ ì†ì˜",
      group:"movespeed",
      weight:90,
      tiers:[
        {t:6,minIlvl:1, min:1, max:2},
        {t:5,minIlvl:12,min:2, max:3},
        {t:4,minIlvl:24,min:3, max:4},
        {t:3,minIlvl:36,min:4, max:6},
        {t:2,minIlvl:52,min:6, max:8},
        {t:1,minIlvl:72,min:8, max:12}
      ],
      apply:(d,v)=>{ d.moveSpeedMul = (d.moveSpeedMul||1) * (1+v/100); }
    },
    {
      id:"s_regen",
      name:"ì¬ìƒì˜",
      group:"hpregen",
      weight:85,
      tiers:[
        {t:6,minIlvl:1, min:0.05, max:0.10},
        {t:5,minIlvl:12,min:0.10, max:0.16},
        {t:4,minIlvl:24,min:0.16, max:0.22},
        {t:3,minIlvl:36,min:0.22, max:0.30},
        {t:2,minIlvl:52,min:0.30, max:0.40},
        {t:1,minIlvl:72,min:0.40, max:0.55}
      ],
      apply:(d,v)=>{ d.hpRegen = (d.hpRegen||0) + v; }
    }

  ]
};


function rollTierValue(affix, ilvl){
  // PoEì‹: ilvlì— ë”°ë¼ ì‚¬ìš© ê°€ëŠ¥í•œ tierë§Œ ì„ íƒ
  if(!affix) return null;

  const tiers = Array.isArray(affix.tiers) ? affix.tiers : null;
  if(!tiers || !tiers.length){
    // tiersê°€ ì—†ëŠ” ì˜› affixëŠ” ë‹¨ì¼ ê°’ìœ¼ë¡œ ì²˜ë¦¬
    const v = (typeof affix.value === "number") ? affix.value : 0;
    return { tier: 1, value: v };
  }

  const avail = tiers.filter(t => t && typeof t.minIlvl === "number" ? (ilvl >= t.minIlvl) : true);
  if(!avail.length) return null;

  const picked = weightedPick(avail.map(t=>({ ...t, weight:(t.w ?? 1) })));
  if(!picked) return null;

  const isInt = Number.isInteger(picked.min) && Number.isInteger(picked.max);
  let v = picked.min + Math.random() * (picked.max - picked.min);
  if(isInt) v = Math.floor(v);
  else v = Math.round(v * 1000) / 1000;

  return { tier:picked.t ?? 1, value:v };
}
function maxAffixesForRarity(r){
  // PoE: normal=0, magic=2, rare=6, unique(ìœ ë‹ˆí¬)=0(ê³ ì •ëª¨ë“œ)
  r = normalizeRarity(r);
  if(r === "normal") return 0;
  if(r === "magic") return 2;
  if(r === "rare") return 6;
  if(r === "unique") return 0;
  return 0;
}
function maxPrefixForRarity(r){ r = normalizeRarity(r); return (r === "rare") ? 3 : (r === "magic" ? 1 : 0); }
function maxSuffixForRarity(r){ r = normalizeRarity(r); return (r === "rare") ? 3 : (r === "magic" ? 1 : 0); }

function tagsPass(itemTags, obj){
  const tags = Array.isArray(itemTags) ? itemTags : [];
  const all = (obj && obj.requiresAll) ? obj.requiresAll : [];
  const any = (obj && obj.requiresAny) ? obj.requiresAny : [];
  const forb = (obj && obj.forbids) ? obj.forbids : [];

  for(const t of forb){ if(tags.includes(t)) return false; }
  for(const t of all){ if(!tags.includes(t)) return false; }
  if(any.length){
    let ok = false;
    for(const t of any){ if(tags.includes(t)){ ok = true; break; } }
    if(!ok) return false;
  }
  return true;
}

function clampAffixLimits(affixes, rarity){
  if(!Array.isArray(affixes)) return [];
  const maxPre = maxPrefixForRarity(rarity);
  const maxSuf = maxSuffixForRarity(rarity);
  const maxTot = maxAffixesForRarity(rarity);

  const pre = affixes.filter(a=>a && a.kind==="prefix").slice(0, maxPre);
  const suf = affixes.filter(a=>a && a.kind==="suffix").slice(0, maxSuf);

  const out = [];
  out.push(...pre);
  out.push(...suf);
  return out.slice(0, maxTot);
}

function rollAffixesPOE(rarity, ilvl, itemTags, opts={}){
  rarity = normalizeRarity(rarity);
  opts.itemTags = itemTags;
  if(rarity === "unique") return [];
  // opts: { total=null, pre=null, suf=null, existingAffixes=null, add=false, keepExisting=false }
  const maxTot = maxAffixesForRarity(rarity);
  const maxPre = maxPrefixForRarity(rarity);
  const maxSuf = maxSuffixForRarity(rarity);

  let targetTot = (typeof opts.total === "number") ? Math.max(0, Math.min(maxTot, opts.total)) : maxTot;

  // PoE ëŠë‚Œ ëœë¤ ê°œìˆ˜:
  // - ë§¤ì§: 1~2
  // - ë ˆì–´: 3~4
  // - ì—í”½: 4~6
  if(opts.total == null){
    if(rarity === "magic") targetTot = (Math.random() < 0.55 ? 1 : 2);
    else if(rarity === "rare") targetTot = (Math.random() < 0.55 ? 3 : 4);
    else if(rarity === "rare"){
      const r = Math.random();
      targetTot = (r < 0.40 ? 4 : (r < 0.75 ? 5 : 6));
    }else targetTot = 0;
  }

  const existing = Array.isArray(opts.existingAffixes) ? opts.existingAffixes : [];
  const keepExisting = !!opts.keepExisting;
  const addMode = !!opts.add;

  let picked = keepExisting ? existing.slice() : [];
  picked = clampAffixLimits(picked, rarity);

  const usedGroups = new Set(picked.map(a=>a && a.affix ? a.affix.group : "").filter(Boolean));

  function eligiblePool(pool, poolName){
    return pool.filter(a => {
      if(!a) return false;
      if(usedGroups.has(a.group)) return false;
      if(!tagsPass(itemTags, a)) return false;

      // âœ… ilvl tier gating: í•´ë‹¹ affixì— ilvlì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” tierê°€ 1ê°œë¼ë„ ìˆì–´ì•¼ í•¨
      if(Array.isArray(a.tiers) && a.tiers.length){
        const ok = a.tiers.some(t => t && (typeof t.minIlvl === "number" ? (ilvl >= t.minIlvl) : true));
        if(!ok) return false;
      }

      // âœ… Pool gating + Hard Locks
      const p = inferAffixPool(a, opts);
      if(!hardPoolAllowed(p, itemTags, opts)) return false;
    // ë¬´ê¸°ì—ëŠ” ë°©ì–´êµ¬ ì „ìš©(ë°©ì–´ë„/ì €í•­) ì ‘ë‘ê°€ ëœ¨ì§€ ì•Šê²Œ í•˜ë“œ ì°¨ë‹¨ (tmplì´ ì—†ì„ ë•Œë„ tagsë¡œ íŒë³„)
      const slot = (opts && opts.tmpl) ? opts.tmpl.slot : null;
      const isWeapon = (slot === "weapon") || (Array.isArray(itemTags) && (itemTags.includes("weapon") || itemTags.includes("attack")));
      if(isWeapon){
        const g = String(a.group||"").toLowerCase();
        const bannedWeaponGroups = new Set(["armor_pct","resist_all","resist_fire","resist_cold","resist_light"]);
        if(bannedWeaponGroups.has(g)) return false;
      }

      if(poolName){
        if(p !== poolName) return false;
      }
      return true;
    });
  }

  function pickOne(kind, pool){
    // 1) ì»¨í…ìŠ¤íŠ¸ì— ë§ëŠ” "í’€"ì„ ë¨¼ì € ì„ íƒ
    const pw = poolWeightsForContext(kind, itemTags, opts);
    let desiredPool = weightedPickFromMap(pw);

    // 2) ì„ íƒëœ í’€ì—ì„œ ë¨¼ì € ë½‘ê¸°
    if(desiredPool){
      const eligP = eligiblePool(pool, desiredPool);
      if(eligP.length) return weightedPickAffix(eligP, opts);
    }

    // 3) ì‹¤íŒ¨í•˜ë©´ ì „ì²´ì—ì„œ ë½‘ê¸°(ë“œë/í¬ë˜ì‹œ ë°©ì§€)
    const elig = eligiblePool(pool, null);
    if(!elig.length) return null;
    return weightedPickAffix(elig, opts);
  }

  let guard = 0;
  while(picked.length < targetTot && guard++ < 1200){
    // prefix/suffix ë°¸ëŸ°ìŠ¤: ìµœëŒ€ì¹˜ ë„˜ì§€ ì•Šê²Œ
    const preCount = picked.filter(x=>x.kind==="prefix").length;
    const sufCount = picked.filter(x=>x.kind==="suffix").length;

    let kind = "prefix";
    if(preCount >= maxPre) kind = "suffix";
    else if(sufCount >= maxSuf) kind = "prefix";
    else kind = (Math.random() < 0.5 ? "prefix" : "suffix");

    const cand = (kind === "prefix")
      ? pickOne(kind, AFFIX_DB.prefix)
      : pickOne(kind, AFFIX_DB.suffix);

    if(!cand) break;
    if(usedGroups.has(cand.group)) continue;

    usedGroups.add(cand.group);
    const rr = rollTierValue(cand, ilvl);
    if(!rr) continue;
    picked.push({ kind, affix:cand, tier:rr.tier, value:rr.value });
  }

  if(addMode){
    // addMode: existing + 1ê°œë§Œ ì¶”ê°€í•˜ê³  ì‹¶ì„ ë•Œ (Aug/Regal/Exalt ìš©)
    // opts.keepExisting=true + opts.total = existing.length + 1 í˜•íƒœë¡œ ì‚¬ìš©
    // ì—¬ê¸°ì„œëŠ” ê·¸ëƒ¥ clampë§Œ ë³´ì¥
    picked = clampAffixLimits(picked, rarity);
  }

  return picked;
}

function rerollValuesPOE(affixes, ilvl){
  if(!Array.isArray(affixes)) return [];
  return affixes.map(r=>{
    if(!r || !r.affix) return r;
    const tiers = Array.isArray(r.affix.tiers) ? r.affix.tiers : [];
    const t = tiers.find(x => x && x.t === r.tier);
    if(!t) return r;
    const isInt = Number.isInteger(t.min) && Number.isInteger(t.max);
    let v = t.min + Math.random() * (t.max - t.min);
    if(isInt) v = Math.floor(v);
    else v = Math.round(v * 1000) / 1000;
    return { ...r, value:v };
  });
}

function makeEmptyItemData(){
  return {
    dmgMul: 1,
    rangeMul: 1,
    spdMul: 1,
    armorAdd: 0,
    maxHpAdd: 0,
    hpRegen: 0,
    critChanceAdd: 0,
    critMultiAdd: 0
  };
}
function mergeItemData(baseData, affixData){
  const out = makeEmptyItemData();
  out.dmgMul   = (baseData.dmgMul   ?? 1) * (affixData.dmgMul   ?? 1);
  out.rangeMul = (baseData.rangeMul ?? 1) * (affixData.rangeMul ?? 1);
  out.spdMul   = (baseData.spdMul   ?? 1) * (affixData.spdMul   ?? 1);

  out.armorAdd      = (baseData.armorAdd      ?? 0) + (affixData.armorAdd      ?? 0);
  out.maxHpAdd      = (baseData.maxHpAdd      ?? 0) + (affixData.maxHpAdd      ?? 0);
  out.hpRegen       = (baseData.hpRegen       ?? 0) + (affixData.hpRegen       ?? 0);
  out.critChanceAdd = (baseData.critChanceAdd ?? 0) + (affixData.critChanceAdd ?? 0);
  out.critMultiAdd  = (baseData.critMultiAdd  ?? 0) + (affixData.critMultiAdd  ?? 0);
  return out;
}



function getItemTemplateById(id){
  const pool = Array.isArray(ITEM_POOL) ? ITEM_POOL : [];
  let t = pool.find(x => x.id === id);
  if(!t){
    // fallback: first weapon or first item
    t = pool.find(x => x.slot === "weapon") || pool[0] || null;
  }
  return t;
}

function buildBaseDataFromItemId(itemId){
  // âœ… PoEì‹: ë² ì´ìŠ¤ì˜ "ê¸°ë³¸ ìˆ˜ì¹˜"ëŠ” í…œí”Œë¦¿ì— ì •ì˜ëœ ê³ ì •ê°’ì„ ì‚¬ìš©
  // - ì ‘ë‘/ì ‘ë¯¸/ì•”ë¬µ(implicit)ì€ ë³„ë„ ë ˆì´ì–´ì—ì„œ ì ìš©
  const base = makeEmptyItemData();
  const id = String(itemId||"");
  const tmpl = getItemTemplateById(id);

  if(!tmpl || !tmpl.baseData) return base;

  const bd = tmpl.baseData;

  // ê¸°ë³¸ ê·œì¹™:
  // - *Mul ê³„ì—´(dmgMul/spdMul/rangeMul/elemDmgMul ë“±)ì€ ê³±
  // - ê·¸ ì™¸ Add/Min/Max/Res ê³„ì—´ì€ ë”í•¨
  for(const k of Object.keys(bd)){
    const v = bd[k];
    if(v == null) continue;
    if(k.endsWith("Mul")){
      base[k] = (base[k] ?? 1) * v;
    } else {
      base[k] = (base[k] ?? 0) + v;
    }
  }
  return base;
}



const ITEM_POOL = [
  // =========================================================
  // âœ… PoEì‹ "ë² ì´ìŠ¤" í’€ (ì™„ì „ ë¦¬ë‰´ì–¼)
  // - baseTier: ë§µí‹°ì–´ì— ë”°ë¼ í•´ê¸ˆ
  // - minIlvl  : ë² ì´ìŠ¤ ìµœì†Œ ì•„ì´í…œ ë ˆë²¨
  // - baseData : ë² ì´ìŠ¤ ê³ ì • ìŠ¤íƒ¯(ì•”ë¬µê³¼ ë³„ê°œ)
  // - implicits: ì•”ë¬µ ì˜µì…˜(ì ‘ë‘/ì ‘ë¯¸ì™€ ë³„ê°œ)
  // - tags     : affix íƒœê·¸ ë§¤ì¹­ìš©
  // - weaponType: ì•„ì´ì½˜/ë°¸ëŸ°ìŠ¤ìš© íƒ€ì… (2h_sword/2h_axe/2h_mace/staff/warstaff)
  // =========================================================

  /* ======================================================= */
  /* WEAPON â€” Two-Handed Sword (ì–‘ì†ê²€) */
  /* ======================================================= */
  { id:"rusted_greatsword", slot:"weapon", name:"ë…¹ìŠ¨ ëŒ€ê²€", baseTier:1, minIlvl:1,  weight:120, weaponType:"2h_sword",
    tags:["weapon","attack","physical","melee","twohand","sword"],
    baseData:{ dmgMul:1.10, spdMul:0.92, rangeMul:1.06, critChanceAdd:0.005 },
    implicits:[ { stat:"critChanceAdd", value:0.010, text:"ì¹˜ëª…íƒ€ í™•ë¥  +1%" } ],
    descGen:(d)=>`ê³µê²© ì†ë„ ${Math.round(((d.spdMul ?? 1)-1)*100)}% / í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"iron_greatsword", slot:"weapon", name:"ì²  ëŒ€ê²€",   baseTier:2, minIlvl:12, weight:95,  weaponType:"2h_sword",
    tags:["weapon","attack","physical","melee","twohand","sword"],
    baseData:{ dmgMul:1.18, spdMul:0.94, rangeMul:1.08, critChanceAdd:0.006 },
    implicits:[ { stat:"dmgMul", value:0.04, op:"more", text:"ê³µê²© í”¼í•´ 4% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`ê³µê²© ì†ë„ ${Math.round(((d.spdMul ?? 1)-1)*100)}% / í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"steel_greatsword", slot:"weapon", name:"ê°•ì²  ëŒ€ê²€", baseTier:3, minIlvl:24, weight:70, weaponType:"2h_sword",
    tags:["weapon","attack","physical","melee","twohand","sword","crit"],
    baseData:{ dmgMul:1.30, spdMul:0.95, rangeMul:1.10, critChanceAdd:0.008 },
    implicits:[ { stat:"critMultiAdd", value:0.10, text:"ì¹˜ëª…íƒ€ í”¼í•´ +10%" } ],
    descGen:(d)=>`ì¹˜í™• +${Math.round((d.critChanceAdd ?? 0)*100)}% / ì¹˜í”¼ +${Math.round((d.critMultiAdd ?? 0)*100)}%`
  },
  { id:"tempered_greatsword", slot:"weapon", name:"ë‹´ê¸ˆì§ˆ ëŒ€ê²€", baseTier:4, minIlvl:36, weight:45, weaponType:"2h_sword",
    tags:["weapon","attack","physical","melee","twohand","sword"],
    baseData:{ dmgMul:1.44, spdMul:0.96, rangeMul:1.12, critChanceAdd:0.010 },
    implicits:[ { stat:"spdMul", value:0.04, op:"more", text:"ê³µê²© ì†ë„ 4% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`ê³µê²© ì†ë„ ${Math.round(((d.spdMul ?? 1)-1)*100)}% / í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"colossus_greatsword", slot:"weapon", name:"ê±°ëŒ€ ëŒ€ê²€", baseTier:5, minIlvl:48, weight:25, weaponType:"2h_sword",
    tags:["weapon","attack","physical","melee","twohand","sword","high_tier"],
    baseData:{ dmgMul:1.62, spdMul:0.98, rangeMul:1.14, critChanceAdd:0.012 },
    implicits:[ { stat:"dmgMul", value:0.06, op:"more", text:"ê³µê²© í”¼í•´ 6% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },

  /* ======================================================= */
  /* WEAPON â€” Two-Handed Axe (ì–‘ì†ë„ë¼) */
  /* ======================================================= */
  { id:"rusted_greataxe", slot:"weapon", name:"ë…¹ìŠ¨ ì–‘ì†ë„ë¼", baseTier:1, minIlvl:1,  weight:115, weaponType:"2h_axe",
    tags:["weapon","attack","physical","melee","twohand","axe"],
    baseData:{ dmgMul:1.14, spdMul:0.88, rangeMul:1.05 },
    implicits:[ { stat:"dmgMul", value:0.03, op:"more", text:"ê³µê²© í”¼í•´ 3% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"iron_greataxe", slot:"weapon", name:"ì²  ì–‘ì†ë„ë¼", baseTier:2, minIlvl:12, weight:92, weaponType:"2h_axe",
    tags:["weapon","attack","physical","melee","twohand","axe"],
    baseData:{ dmgMul:1.24, spdMul:0.90, rangeMul:1.06 },
    implicits:[ { stat:"critChanceAdd", value:0.008, text:"ì¹˜ëª…íƒ€ í™•ë¥  +0.8%" } ],
    descGen:(d)=>`ì¹˜í™• +${Math.round((d.critChanceAdd ?? 0)*100)}% / í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"steel_greataxe", slot:"weapon", name:"ê°•ì²  ì–‘ì†ë„ë¼", baseTier:3, minIlvl:24, weight:68, weaponType:"2h_axe",
    tags:["weapon","attack","physical","melee","twohand","axe"],
    baseData:{ dmgMul:1.38, spdMul:0.91, rangeMul:1.07 },
    implicits:[ { stat:"critMultiAdd", value:0.12, text:"ì¹˜ëª…íƒ€ í”¼í•´ +12%" } ],
    descGen:(d)=>`ì¹˜í”¼ +${Math.round((d.critMultiAdd ?? 0)*100)}%`
  },
  { id:"executioner_greataxe", slot:"weapon", name:"ì²˜í˜•ìì˜ ì–‘ì†ë„ë¼", baseTier:4, minIlvl:36, weight:42, weaponType:"2h_axe",
    tags:["weapon","attack","physical","melee","twohand","axe","elite"],
    baseData:{ dmgMul:1.54, spdMul:0.92, rangeMul:1.08 },
    implicits:[ { stat:"dmgMul", value:0.05, op:"more", text:"ê³µê²© í”¼í•´ 5% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"behemoth_greataxe", slot:"weapon", name:"ê±°ìˆ˜ì˜ ì–‘ì†ë„ë¼", baseTier:5, minIlvl:48, weight:22, weaponType:"2h_axe",
    tags:["weapon","attack","physical","melee","twohand","axe","high_tier"],
    baseData:{ dmgMul:1.74, spdMul:0.93, rangeMul:1.09 },
    implicits:[ { stat:"dmgMul", value:0.07, op:"more", text:"ê³µê²© í”¼í•´ 7% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },

  /* ======================================================= */
  /* WEAPON â€” Two-Handed Mace (ì–‘ì†ì² í‡´) */
  /* ======================================================= */
  { id:"rusted_greatmace", slot:"weapon", name:"ë…¹ìŠ¨ ì–‘ì†ì² í‡´", baseTier:1, minIlvl:1,  weight:110, weaponType:"2h_mace",
    tags:["weapon","attack","physical","melee","twohand","mace"],
    baseData:{ dmgMul:1.16, spdMul:0.86, rangeMul:1.03 },
    implicits:[ { stat:"armorAdd", value:6, text:"ë°©ì–´ë ¥ +6" } ],
    descGen:(d)=>`ê³µê²© ì†ë„ ${Math.round(((d.spdMul ?? 1)-1)*100)}% / í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"iron_greatmace", slot:"weapon", name:"ì²  ì–‘ì†ì² í‡´", baseTier:2, minIlvl:12, weight:88, weaponType:"2h_mace",
    tags:["weapon","attack","physical","melee","twohand","mace"],
    baseData:{ dmgMul:1.30, spdMul:0.87, rangeMul:1.04 },
    implicits:[ { stat:"maxHpAdd", value:10, text:"ìµœëŒ€ ì²´ë ¥ +10" } ],
    descGen:(d)=>`ìµœëŒ€ ì²´ë ¥ +${Math.floor(d.maxHpAdd ?? 0)}`
  },
  { id:"steel_greatmace", slot:"weapon", name:"ê°•ì²  ì–‘ì†ì² í‡´", baseTier:3, minIlvl:24, weight:64, weaponType:"2h_mace",
    tags:["weapon","attack","physical","melee","twohand","mace"],
    baseData:{ dmgMul:1.46, spdMul:0.88, rangeMul:1.05 },
    implicits:[ { stat:"critMultiAdd", value:0.08, text:"ì¹˜ëª…íƒ€ í”¼í•´ +8%" } ],
    descGen:(d)=>`ì¹˜í”¼ +${Math.round((d.critMultiAdd ?? 0)*100)}%`
  },
  { id:"crusher_greatmace", slot:"weapon", name:"ë¶„ì‡„ìì˜ ì–‘ì†ì² í‡´", baseTier:4, minIlvl:36, weight:40, weaponType:"2h_mace",
    tags:["weapon","attack","physical","melee","twohand","mace","boss"],
    baseData:{ dmgMul:1.64, spdMul:0.89, rangeMul:1.06 },
    implicits:[ { stat:"dmgMul", value:0.05, op:"more", text:"ê³µê²© í”¼í•´ 5% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"titan_greatmace", slot:"weapon", name:"ê±°ì¸ì˜ ì–‘ì†ì² í‡´", baseTier:5, minIlvl:48, weight:20, weaponType:"2h_mace",
    tags:["weapon","attack","physical","melee","twohand","mace","high_tier"],
    baseData:{ dmgMul:1.86, spdMul:0.90, rangeMul:1.07 },
    implicits:[ { stat:"maxHpAdd", value:18, text:"ìµœëŒ€ ì²´ë ¥ +18" } ],
    descGen:(d)=>`ìµœëŒ€ ì²´ë ¥ +${Math.floor(d.maxHpAdd ?? 0)}`
  },

  /* ======================================================= */
  /* WEAPON â€” Staff (ì§€íŒ¡ì´) */
  /* ======================================================= */
  { id:"ash_staff", slot:"weapon", name:"ì¿ë¹› ì§€íŒ¡ì´", baseTier:1, minIlvl:1,  weight:120, weaponType:"staff",
    tags:["weapon","attack","melee","twohand","staff"],
    baseData:{ dmgMul:1.04, spdMul:1.00, rangeMul:1.12 },
    implicits:[ { stat:"rangeMul", value:0.04, op:"more", text:"ê³µê²© ë²”ìœ„ 4% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`ê³µê²© ë²”ìœ„ ${Math.round(((d.rangeMul ?? 1)-1)*100)}%`
  },
  { id:"oak_staff", slot:"weapon", name:"ì°¸ë‚˜ë¬´ ì§€íŒ¡ì´", baseTier:2, minIlvl:12, weight:95, weaponType:"staff",
    tags:["weapon","attack","melee","twohand","staff"],
    baseData:{ dmgMul:1.10, spdMul:1.02, rangeMul:1.14 },
    implicits:[ { stat:"hpRegen", value:0.25, text:"ì¬ìƒ +0.25/s" } ],
    descGen:(d)=>`ì¬ìƒ +${(d.hpRegen ?? 0).toFixed(2)}/s`
  },
  { id:"ebony_staff", slot:"weapon", name:"í‘ë‹¨ ì§€íŒ¡ì´", baseTier:3, minIlvl:24, weight:70, weaponType:"staff",
    tags:["weapon","attack","melee","twohand","staff","crit"],
    baseData:{ dmgMul:1.18, spdMul:1.03, rangeMul:1.16, critChanceAdd:0.008 },
    implicits:[ { stat:"critChanceAdd", value:0.012, text:"ì¹˜ëª…íƒ€ í™•ë¥  +1.2%" } ],
    descGen:(d)=>`ì¹˜í™• +${Math.round((d.critChanceAdd ?? 0)*100)}%`
  },
  { id:"elder_staff", slot:"weapon", name:"ì¥ë¡œì˜ ì§€íŒ¡ì´", baseTier:4, minIlvl:36, weight:45, weaponType:"staff",
    tags:["weapon","attack","melee","twohand","staff","elemental"],
    baseData:{ dmgMul:1.26, spdMul:1.04, rangeMul:1.18 },
    implicits:[ { stat:"elemDmgMul", value:0.06, op:"more", text:"ì›ì†Œ í”¼í•´ 6% ì¶”ê°€(ê³±)" } ]
  },
  { id:"astral_staff", slot:"weapon", name:"ì„±ìš´ ì§€íŒ¡ì´", baseTier:5, minIlvl:48, weight:25, weaponType:"staff",
    tags:["weapon","attack","melee","twohand","staff","high_tier"],
    baseData:{ dmgMul:1.34, spdMul:1.05, rangeMul:1.20 },
    implicits:[ { stat:"rangeMul", value:0.06, op:"more", text:"ê³µê²© ë²”ìœ„ 6% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`ê³µê²© ë²”ìœ„ ${Math.round(((d.rangeMul ?? 1)-1)*100)}%`
  },

  /* ======================================================= */
  /* WEAPON â€” Warstaff (ì „ìŸì§€íŒ¡ì´) */
  /* ======================================================= */
  { id:"rusted_warstaff", slot:"weapon", name:"ë…¹ìŠ¨ ì „ìŸì§€íŒ¡ì´", baseTier:1, minIlvl:1,  weight:110, weaponType:"warstaff",
    tags:["weapon","attack","melee","twohand","warstaff","staff"],
    baseData:{ dmgMul:1.12, spdMul:0.98, rangeMul:1.12, critChanceAdd:0.006 },
    implicits:[ { stat:"critMultiAdd", value:0.08, text:"ì¹˜ëª…íƒ€ í”¼í•´ +8%" } ],
    descGen:(d)=>`ì¹˜í”¼ +${Math.round((d.critMultiAdd ?? 0)*100)}%`
  },
  { id:"iron_warstaff", slot:"weapon", name:"ì²  ì „ìŸì§€íŒ¡ì´", baseTier:2, minIlvl:12, weight:88, weaponType:"warstaff",
    tags:["weapon","attack","melee","twohand","warstaff","staff"],
    baseData:{ dmgMul:1.22, spdMul:0.99, rangeMul:1.14, critChanceAdd:0.008 },
    implicits:[ { stat:"dmgMul", value:0.04, op:"more", text:"ê³µê²© í”¼í•´ 4% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"steel_warstaff", slot:"weapon", name:"ê°•ì²  ì „ìŸì§€íŒ¡ì´", baseTier:3, minIlvl:24, weight:64, weaponType:"warstaff",
    tags:["weapon","attack","melee","twohand","warstaff","staff","crit"],
    baseData:{ dmgMul:1.34, spdMul:1.00, rangeMul:1.16, critChanceAdd:0.010 },
    implicits:[ { stat:"critChanceAdd", value:0.012, text:"ì¹˜ëª…íƒ€ í™•ë¥  +1.2%" } ],
    descGen:(d)=>`ì¹˜í™• +${Math.round((d.critChanceAdd ?? 0)*100)}%`
  },
  { id:"warlord_warstaff", slot:"weapon", name:"êµ°ì£¼ì˜ ì „ìŸì§€íŒ¡ì´", baseTier:4, minIlvl:36, weight:40, weaponType:"warstaff",
    tags:["weapon","attack","melee","twohand","warstaff","staff","boss"],
    baseData:{ dmgMul:1.48, spdMul:1.01, rangeMul:1.18, critChanceAdd:0.010 },
    implicits:[ { stat:"dmgMul", value:0.05, op:"more", text:"ê³µê²© í”¼í•´ 5% ì¶”ê°€(ê³±)" } ],
    descGen:(d)=>`í‰íƒ€ í”¼í•´ ${Math.round(((d.dmgMul ?? 1)-1)*100)}%`
  },
  { id:"titan_warstaff", slot:"weapon", name:"ê±°ì¸ì˜ ì „ìŸì§€íŒ¡ì´", baseTier:5, minIlvl:48, weight:22, weaponType:"warstaff",
    tags:["weapon","attack","melee","twohand","warstaff","staff","high_tier"],
    baseData:{ dmgMul:1.66, spdMul:1.02, rangeMul:1.20, critChanceAdd:0.012 },
    implicits:[ { stat:"critMultiAdd", value:0.12, text:"ì¹˜ëª…íƒ€ í”¼í•´ +12%" } ],
    descGen:(d)=>`ì¹˜í”¼ +${Math.round((d.critMultiAdd ?? 0)*100)}%`
  },

  /* ======================================================= */
  /* HELM (íˆ¬êµ¬) */
  /* ======================================================= */
  { id:"leather_cap", slot:"helm", name:"ê°€ì£½ ëª¨ì", baseTier:1, minIlvl:1,  weight:120,
    tags:["helm","armor","defense"],
    baseData:{ armorAdd:6 },
    implicits:[ { stat:"maxHpAdd", value:6, text:"ìµœëŒ€ ì²´ë ¥ +6" } ],
    descGen:(d)=>`ë°©ì–´ë ¥ +${Math.floor(d.armorAdd ?? 0)}`
  },
  { id:"iron_helmet", slot:"helm", name:"ì²  íˆ¬êµ¬", baseTier:2, minIlvl:12, weight:95,
    tags:["helm","armor","defense"],
    baseData:{ armorAdd:14 },
    implicits:[ { stat:"armorAdd", value:6, text:"ë°©ì–´ë ¥ +6" } ],
    descGen:(d)=>`ë°©ì–´ë ¥ +${Math.floor(d.armorAdd ?? 0)}`
  },
  { id:"soldier_helm", slot:"helm", name:"ë³‘ì‚¬ì˜ íˆ¬êµ¬", baseTier:3, minIlvl:24, weight:70,
    tags:["helm","armor","defense"],
    baseData:{ armorAdd:22 },
    implicits:[ { stat:"critChanceAdd", value:0.006, text:"ì¹˜ëª…íƒ€ í™•ë¥  +0.6%" } ],
    descGen:(d)=>`ì¹˜í™• +${Math.round((d.critChanceAdd ?? 0)*100)}%`
  },
  { id:"templar_helm", slot:"helm", name:"ì„±ê¸°ì‚¬ íˆ¬êµ¬", baseTier:4, minIlvl:36, weight:45,
    tags:["helm","armor","defense"],
    baseData:{ armorAdd:32 },
    implicits:[ { stat:"allResAdd", value:8, text:"ëª¨ë“  ì €í•­ +8%" } ]
  },
  { id:"warlord_helm", slot:"helm", name:"êµ°ì£¼ì˜ íˆ¬êµ¬", baseTier:5, minIlvl:48, weight:25,
    tags:["helm","armor","defense","high_tier"],
    baseData:{ armorAdd:44 },
    implicits:[ { stat:"maxHpAdd", value:14, text:"ìµœëŒ€ ì²´ë ¥ +14" } ],
    descGen:(d)=>`ë°©ì–´ë ¥ +${Math.floor(d.armorAdd ?? 0)}`
  },

  /* ======================================================= */
  /* CHEST (ê°‘ì˜·) */
  /* ======================================================= */
  { id:"tattered_armor", slot:"chest", name:"ëˆ„ë”ê¸° ê°‘ì˜·", baseTier:1, minIlvl:1,  weight:120,
    tags:["chest","armor","life","defense"],
    baseData:{ maxHpAdd:16 },
    implicits:[ { stat:"hpRegen", value:0.25, text:"ì¬ìƒ +0.25/s" } ],
    descGen:(d)=>`ìµœëŒ€ ì²´ë ¥ +${Math.floor(d.maxHpAdd ?? 0)}`
  },
  { id:"chainmail", slot:"chest", name:"ì‚¬ìŠ¬ ê°‘ì˜·", baseTier:2, minIlvl:12, weight:95,
    tags:["chest","armor","life","defense"],
    baseData:{ armorAdd:16, maxHpAdd:22 },
    implicits:[ { stat:"armorAdd", value:10, text:"ë°©ì–´ë ¥ +10" } ],
    descGen:(d)=>`ë°©ì–´ë ¥ +${Math.floor(d.armorAdd ?? 0)} / ìµœëŒ€ ì²´ë ¥ +${Math.floor(d.maxHpAdd ?? 0)}`
  },
  { id:"scalemail", slot:"chest", name:"ë¹„ëŠ˜ ê°‘ì˜·", baseTier:3, minIlvl:24, weight:70,
    tags:["chest","armor","life","defense"],
    baseData:{ armorAdd:28, maxHpAdd:30 },
    implicits:[ { stat:"maxHpAdd", value:10, text:"ìµœëŒ€ ì²´ë ¥ +10" } ],
    descGen:(d)=>`ìµœëŒ€ ì²´ë ¥ +${Math.floor(d.maxHpAdd ?? 0)}`
  },
  { id:"plate_armor", slot:"chest", name:"íŒê¸ˆ í‰ê°‘", baseTier:4, minIlvl:36, weight:45,
    tags:["chest","armor","life","defense"],
    baseData:{ armorAdd:40, maxHpAdd:40 },
    implicits:[ { stat:"allResAdd", value:10, text:"ëª¨ë“  ì €í•­ +10%" } ],
    descGen:(d)=>`ìµœëŒ€ ì²´ë ¥ +${Math.floor(d.maxHpAdd ?? 0)}`
  },
  { id:"astral_plate", slot:"chest", name:"ì„±ìš´ í‰ê°‘", baseTier:5, minIlvl:48, weight:25,
    tags:["chest","armor","life","defense","high_tier"],
    baseData:{ armorAdd:56, maxHpAdd:54 },
    implicits:[ { stat:"allResAdd", value:12, text:"ëª¨ë“  ì €í•­ +12%" } ],
    descGen:(d)=>`ìµœëŒ€ ì²´ë ¥ +${Math.floor(d.maxHpAdd ?? 0)}`
  },

  /* ======================================================= */
  /* RING (ë°˜ì§€) */
  /* ======================================================= */
  { id:"iron_ring", slot:"ring", name:"ì²  ë°˜ì§€", baseTier:1, minIlvl:1,  weight:130,
    tags:["ring","jewelry","physical"],
    baseData:{},
    implicits:[ { stat:"physAddedMin", value:1, text:"ë¬¼ë¦¬ í”¼í•´ +1~2" }, { stat:"physAddedMax", value:2 } ]
  },
  { id:"coral_ring", slot:"ring", name:"ì‚°í˜¸ ë°˜ì§€", baseTier:1, minIlvl:1,  weight:120,
    tags:["ring","jewelry","life"],
    baseData:{ maxHpAdd:10 },
    implicits:[ { stat:"maxHpAdd", value:10, text:"ìµœëŒ€ ì²´ë ¥ +10" } ]
  },
  { id:"paua_ring", slot:"ring", name:"íŒŒìš°ì•„ ë°˜ì§€", baseTier:2, minIlvl:12, weight:95,
    tags:["ring","jewelry","regen"],
    baseData:{},
    implicits:[ { stat:"hpRegen", value:0.35, text:"ì¬ìƒ +0.35/s" } ]
  },
  { id:"sapphire_ring", slot:"ring", name:"ì‚¬íŒŒì´ì–´ ë°˜ì§€", baseTier:2, minIlvl:12, weight:90,
    tags:["ring","jewelry","cold"],
    baseData:{},
    implicits:[ { stat:"coldResAdd", value:18, text:"ëƒ‰ê¸° ì €í•­ +18%" } ]
  },
  { id:"ruby_ring", slot:"ring", name:"ë£¨ë¹„ ë°˜ì§€", baseTier:3, minIlvl:24, weight:75,
    tags:["ring","jewelry","fire"],
    baseData:{},
    implicits:[ { stat:"fireResAdd", value:18, text:"í™”ì—¼ ì €í•­ +18%" } ]
  },
  { id:"topaz_ring", slot:"ring", name:"í† íŒŒì¦ˆ ë°˜ì§€", baseTier:3, minIlvl:24, weight:75,
    tags:["ring","jewelry","lightning"],
    baseData:{},
    implicits:[ { stat:"lightResAdd", value:18, text:"ë²ˆê°œ ì €í•­ +18%" } ]
  },
  { id:"amethyst_ring", slot:"ring", name:"ììˆ˜ì • ë°˜ì§€", baseTier:4, minIlvl:36, weight:45,
    tags:["ring","jewelry","chaos"],
    baseData:{},
    implicits:[ { stat:"chaosResAdd", value:14, text:"ì¹´ì˜¤ìŠ¤ ì €í•­ +14%" } ]
  },
  { id:"two_stone_ring", slot:"ring", name:"íˆ¬ìŠ¤í†¤ ë°˜ì§€", baseTier:4, minIlvl:36, weight:45,
    tags:["ring","jewelry","elemental"],
    baseData:{},
    implicits:[ { stat:"allResAdd", value:8, text:"ëª¨ë“  ì €í•­ +8%" } ]
  },
  { id:"opal_ring", slot:"ring", name:"ì˜¤íŒ” ë°˜ì§€", baseTier:5, minIlvl:48, weight:25,
    tags:["ring","jewelry","elemental","high_tier"],
    baseData:{},
    implicits:[ { stat:"elemDmgMul", value:0.10, op:"more", text:"ì›ì†Œ í”¼í•´ 10% ì¶”ê°€(ê³±)" } ]
  },
  { id:"steel_ring", slot:"ring", name:"ê°•ì²  ë°˜ì§€", baseTier:5, minIlvl:48, weight:25,
    tags:["ring","jewelry","physical","high_tier"],
    baseData:{},
    implicits:[ { stat:"physAddedMin", value:2, text:"ë¬¼ë¦¬ í”¼í•´ +2~4" }, { stat:"physAddedMax", value:4 } ]
  }
];



/* =========================================================
   STEP 2) createItemInstance()ì—ì„œ mods ìƒì„± ë³‘í–‰
   - ê¸°ì¡´ data/affixData/totalData ë¡œì§ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
   - item.tags / item.mods ë¥¼ ì¶”ê°€ë¡œ ë§Œë“¤ì–´ ë‘  (ì•„ì§ ê³„ì‚°ì— ë¯¸ì‚¬ìš©)
   ========================================================= */

function inferItemTagsFromTemplate(tmpl, baseId){
  const tags = [];
  if(tmpl && tmpl.slot) tags.push(tmpl.slot);
  tags.push("gear");

  // baseId ê¸°ë°˜ ê°€ë²¼ìš´ ë¶„ë¥˜(ë‚˜ì¤‘ì— ì•„ì´í…œ DB í™•ì¥ ì‹œ êµì²´)
  const id = String(baseId||"").toLowerCase();
  if(id.includes("ring")) tags.push("jewelry");
  if(id.includes("dmg") || id.includes("ulti")) tags.push("damage");
  if(id.includes("speed")) tags.push("speed");
  if(id.includes("armor")) tags.push("defense");
  if(id.includes("hp") || id.includes("regen")) tags.push("life");

  // slot ê¸°ë°˜ ë¶„ë¥˜
  if(tmpl && tmpl.slot === "weapon") tags.push("attack");
  if(tmpl && (tmpl.slot === "helm" || tmpl.slot === "chest")) tags.push("armor");

  
  // âœ… í…œí”Œë¦¿ì´ tagsë¥¼ ì œê³µí•˜ë©´ ê°™ì´ í•©ì¹œë‹¤
  if(tmpl && Array.isArray(tmpl.tags)){
    for(const t of tmpl.tags) tags.push(t);
  }

  return mergeTags(tags);
}

const MUL_KEYS = Object.freeze(["dmgMul","rangeMul","spdMul","atkSpdMul","critChanceMul","hpMul","armorMul"]);

function keyToModOp(statKey){
  // í˜„ì¬ ì•„ì´í…œ ë°ì´í„° ìŠ¤í‚¤ë§ˆì—ì„œ mul ê³„ì—´ì€ "more"ë¡œ ì·¨ê¸‰
  return (MUL_KEYS.includes(statKey) ? MOD_OPS.more : MOD_OPS.add);
}

function makeBaseModsFromBaseData(baseId, baseData, itemTags){
  const mods = [];
  if(!baseData) return mods;

  // mul ê³„ì—´
  for(const k of MUL_KEYS){
    const mul = (baseData[k] ?? 1);
    if(typeof mul === "number" && Math.abs(mul - 1) > 1e-9){
      mods.push({
        id: `base:${baseId}:${k}`,
        source: "base",
        scope: "gear",
        stat: k,
        op: MOD_OPS.more,
        value: (mul - 1),
        requiresAll: itemTags,
        requiresAny: [],
        forbids: []
      });
    }
  }

  // add ê³„ì—´
  const addKeys = ["armorAdd","maxHpAdd","hpRegen","critChanceAdd","critMultiAdd"];
  for(const k of addKeys){
    const v = (baseData[k] ?? 0);
    if(typeof v === "number" && Math.abs(v) > 1e-9){
      mods.push({
        id: `base:${baseId}:${k}`,
        source: "base",
        scope: "gear",
        stat: k,
        op: MOD_OPS.add,
        value: v,
        requiresAll: itemTags,
        requiresAny: [],
        forbids: []
      });
    }
  }
  return mods;
}

function makeImplicitModsFromTemplate(tmpl, itemTags){
  const mods = [];
  if(!tmpl || !Array.isArray(tmpl.implicits)) return mods;

  for(const imp of tmpl.implicits){
    if(!imp) continue;
    const stat = imp.stat;
    if(!stat) continue;

    // ê¸°ë³¸ opëŠ” keyToModOpì— ë§¡ê¹€(ì—†ìœ¼ë©´ add)
    const op = imp.op || keyToModOp(stat) || "add";

    // imp.value ì—†ê³ , min/max ì§ì´ë©´ ê°ê° ë”°ë¡œ ë“¤ì–´ì˜¬ ìˆ˜ ìˆìœ¼ë‹ˆ íŒ¨ìŠ¤
    if(typeof imp.value !== "number") continue;

    mods.push({
      id: `implicit:${tmpl.id}:${stat}`,
      source: "implicit",
      kind: "implicit",
      stat,
      op,
      value: imp.value,
      label: imp.text || null,
      tier: null,
      baseId: tmpl.id,
      requiresAll: itemTags,
      requiresAny: [],
      forbids: []
    });
  }
  return mods;
}



function makeAffixModFromRoll(roll, itemTags){
  // roll: { kind, affix, tier, value }
  if(!roll || !roll.affix) return null;
  const statKey = roll.affix.group; // í˜„ì¬ AFFIX_DBëŠ” groupì„ ê³§ë°”ë¡œ ë°ì´í„° í‚¤ë¡œ ì‚¬ìš©
  if(!statKey) return null;

  const op = keyToModOp(statKey);
  const val = (Number(roll.value) || 0);

  return {
    id: `affix:${roll.kind}:${roll.affix.id}:t${roll.tier}`,
    source: roll.kind,
    scope: "gear",
    stat: statKey,
    op,
    value: (op === MOD_OPS.more ? val : val),
    meta: { tier: roll.tier, name: roll.affix.name, group: roll.affix.group, affixId: roll.affix.id },
    requiresAll: itemTags,
    requiresAny: [],
    forbids: []
  };
}


function buildImplicitMods(item){
  const t = getItemTemplateById(item.baseId || item.id);
  const imps = (t && Array.isArray(t.implicits)) ? t.implicits : [];
  const out = [];
  for(let i=0;i<imps.length;i++){
    const imp = imps[i];
    if(!imp) continue;
    out.push({
      id: (item.baseId || item.id) + "_implicit_" + i,
      source: "implicit",
      scope: imp.scope || "global",
      requiresAll: imp.requiresAll || [],
      requiresAny: imp.requiresAny || [],
      forbids: imp.forbids || [],
      stat: imp.stat,
      op: imp.op,
      value: imp.value,
      stacks: 1,
      enabled: true
    });
  }
  return out;
}

function buildItemMods(baseId, baseData, affixes, itemTags, tmpl=null){
  const mods = [];
  mods.push(...makeBaseModsFromBaseData(baseId, baseData, itemTags));
  mods.push(...makeImplicitModsFromTemplate(tmpl, itemTags));
  if(Array.isArray(affixes)){
    for(const a of affixes){
      const m = makeAffixModFromRoll(a, itemTags);
      if(m) mods.push(m);
    }
  }
  return mods;
}
// =========================================================
// STEP 4) affix.apply â†’ mods ê¸°ë°˜ ë°ì´í„° ìƒì„±(ì ì§„ ì´ê´€)
// - AFFIX_DB.applyëŠ” ë‹¹ë¶„ê°„ ìœ ì§€(í˜¸í™˜)
// - ì•„ì´í…œ data/affixData/totalData ìƒì„±ë§Œ modsë¡œ ëŒ€ì²´ ì‹œì‘
// =========================================================
const USE_MODS_FOR_ITEMDATA = true;

function buildDataFromMods(mods, { includeBase=true } = {}){
  // mods -> makeEmptyItemData í˜•íƒœë¡œ í™˜ì› (UI/descGenìš©)
  const d = makeEmptyItemData();
  if(!Array.isArray(mods)) return d;

  for(const m of mods){
    if(!m || m.scope !== "gear") continue;
    if(!includeBase && (m.source === "base" || m.source === "implicit")) continue;

    const k = m.stat;
    if(!k) continue;

    if(m.op === MOD_OPS.more){
      const cur = (typeof d[k] === "number" ? d[k] : 1);
      d[k] = cur * (1 + (Number(m.value) || 0));
    }else{
      const cur = (typeof d[k] === "number" ? d[k] : 0);
      d[k] = cur + (Number(m.value) || 0);
    }
  }
  return d;
}

function buildAffixDataFromMods(mods){
  return buildDataFromMods(mods, { includeBase:false });
}


/* ============================= */
/* âœ… POEì‹ ì´ë¦„ ìƒì„± (ì ‘ë‘/ì ‘ë¯¸, ë ˆì–´ ì´ë¦„) */
/* ============================= */
const RARE_NAME_A = ["ë§ë ¹","ì•”í‘","í”¼ì˜","í­í’","ì² ","ê·¸ë¦¼ì","ê³µí—ˆ","íŒŒë©¸","ì„œë¦¬","ë²ˆê°œ","ì”í˜¹","ê´‘ê¸°ì˜","ë§ê°","ê·€ì‹ ","ì§€ì˜¥","ì£½ìŒ","ì¹ í‘","ë¶€íŒ¨","ë…","ì§€ë°°"];
const RARE_NAME_B = ["ì•½íƒˆì","í•™ì‚´ì","ì†¡ê³³ë‹ˆ","ì¹¼ë‚ ","ë°œí†±","ìˆ˜í˜¸ì","ì§•í‘œ","ì‹¬ì¥","íŒŒìˆ˜ê¾¼","íŒŒê´´ì","ì‚¬ëƒ¥ê¾¼","ì¶”ì ì","ì‹¬ì—°","ë§ì¹˜","ì°½","ê²€","ë°©íŒ¨","ì˜ì§€","ì„œì•½","íŒŒë©¸"];
function randPick(arr){ return arr[(Math.random()*arr.length)|0]; }
function rollRareName(){ return randPick(RARE_NAME_A) + " " + randPick(RARE_NAME_B); }

function normalizeRarity(r){
  const x = String(r || "normal").toLowerCase();
  // legacy compat (ì´ì „ common/epic/legendary â†’ PoEì‹ normal/rare/unique)
  if(x === "common") return "normal";
  if(x === "epic") return "rare";
  if(x === "legendary") return "unique";
  if(x === "normal" || x === "magic" || x === "rare" || x === "unique") return x;
  return "normal";
}


function createItemInstance(baseId, rarityOverride=null, opts=null){
  // âœ… ì•ˆì „: ì¡´ì¬í•˜ì§€ ì•ŠëŠ” baseIdê°€ ë“¤ì–´ì™€ë„ í¬ë˜ì‹œ ì•ˆ ë‚˜ê²Œ fallback
  let tmpl = getItemTemplateById(baseId);
  if(!tmpl){
    console.warn("Invalid baseId:", baseId);
    const pool = Array.isArray(ITEM_POOL) ? ITEM_POOL : [];
    tmpl = pool.find(x => x && x.slot === "weapon") || pool[0] || null;
    if(!tmpl) return null;
    baseId = tmpl.id;
  }

  const rarity = normalizeRarity(rarityOverride || tmpl.rarity || "normal");
  const ilvl = Math.max(((opts && opts.ilvl)!=null ? opts.ilvl : getItemLevel()), (tmpl.minIlvl ?? 1));

  // âœ… ê¸°ì¡´ ë¡œì§(ë² ì´ìŠ¤/ì ‘ì‚¬ ë°ì´í„° ê³„ì‚°) ìœ ì§€
  const baseData = buildBaseDataFromItemId(baseId);

  // âœ… tags ë¨¼ì € ì‚°ì¶œ â†’ íƒœê·¸ ê¸°ë°˜ affix ì„ íƒ ê°€ëŠ¥
  const tags = inferItemTagsFromTemplate(tmpl, baseId);

  const affixes = rollAffixesPOE(rarity, ilvl, tags, { tmpl, baseId });

  // âœ… STEP2: tags/mods ë³‘í–‰ ìƒì„±
  const mods = buildItemMods(baseId, baseData, affixes, tags, tmpl);

  // âœ… STEP4: affix.apply ëŒ€ì‹  modsë¡œ affixData ìƒì„±(ì ì§„ ì´ê´€)
  const affixData = USE_MODS_FOR_ITEMDATA
    ? buildAffixDataFromMods(mods)
    : (function(){
        const d = makeEmptyItemData();
        for(const a of affixes){
          if(a && a.affix && typeof a.affix.apply === "function") a.affix.apply(d, a.value);
        }
        return d;
      })();

  const totalData = mergeItemData(baseData, affixData);

  const preNames = affixes.filter(x=>x.kind==="prefix").map(x=>x.affix.name);
  const sufNames = affixes.filter(x=>x.kind==="suffix").map(x=>x.affix.name);

  // âœ… POE ìŠ¤íƒ€ì¼:
  // - ì¼ë°˜(ë§¤ì§): ì²« prefix/ì²« suffixë§Œ ì´ë¦„ì— ë°˜ì˜
  // - ë ˆì–´/ì—í”½: ì ‘ë‘/ì ‘ë¯¸ë¥¼ ì´ë¦„ì—ì„œ ì œê±°í•˜ê³ , ëœë¤ ë ˆì–´ëª… ë¶€ì—¬
  let nm = tmpl.name;
  if(rarity === "magic"){
    const pre = preNames[0] || "";
    const suf = sufNames[0] || "";
    if(pre) nm = pre + " " + nm;
    if(suf) nm = nm + " " + suf;
  }else if(rarity === "rare"){
    nm = rollRareName();
  }

  return {
    id: baseId,
    baseId,
    baseName: tmpl.name,
    baseTier: (tmpl.baseTier ?? 1),
    implicits: Array.isArray(tmpl.implicits) ? tmpl.implicits : [],
    name: nm,
    rarity,
    slot: tmpl.slot,
    ilvl,
    isUnique: false,

    // âœ… ê¸°ì¡´ í•„ë“œë“¤
    data: totalData,
    totalData,
    baseData,
    affixData,
    affixes,
    shownDesc: tmpl.descGen ? tmpl.descGen(totalData) : "",

    // âœ… ì‹ ê·œ í•„ë“œ(ëª¨ë“œ ì—”ì§„ìš©)
    tags,
    mods
  };
}


function giveStarterItems(){
  // âœ… ë² ì´ìŠ¤ í’€ ê¸°ë°˜ ìŠ¤íƒ€í„° ì§€ê¸‰ (ë² ì´ìŠ¤ê°€ ë°”ë€Œì–´ë„ ì•ˆ í„°ì§)
  const pool = Array.isArray(ITEM_POOL) ? ITEM_POOL : [];
  const pickBySlot = (slot)=>{
    return pool.find(x=>x && x.slot===slot && ((x.baseTier ?? 1) <= 1)) ||
           pool.find(x=>x && x.slot===slot) || null;
  };

  const starters = [
    pickBySlot("weapon"),
    pickBySlot("chest"),
    pickBySlot("ring"),
    pickBySlot("boots")
  ].filter(Boolean);

  for(const t of starters){
    const it = createItemInstance(t.id, "normal");
    if(it) inventory.push(it);
  }
}

/* ============================= */
/* âœ… ì „ì„¤(Unique) ì‹œìŠ¤í…œ         */
/* ============================= */
let ownedUniques = [];
let uniqueState = {};

function emitEvent(type, payload){
  for(const u of ownedUniques){
    if(u.onEvent) u.onEvent(type, payload);
  }
}
function cloneLegendary(template){
  return {
    id: template.id,
    name: template.name,
    rarity: template.rarity ?? "legendary",
    desc: template.desc ?? "",
    applyStat: template.applyStat,
    onEvent: template.onEvent,
  };
}

function acquireLegendary(template, ilvl){
  if(ownedUniques.some(u => u.id === template.id)){
    shake = Math.max(shake, 6);
    return;
  }
  const u = cloneLegendary(template);
  if(u.applyStat) u.applyStat();
  ownedUniques.push(u);

  inventory.push({
    id: u.id,
    slot: "unique",
    name: u.name,
    rarity: "legendary",
    ilvl,
    isUnique: true,
    uniqueRef: u,
    data: null,
    affixes: []
  });

  recalcFromGear();
}

const LEGENDARY_POOL = [
  {
    id:"unique_thunderstep",
    name:"ì²œë‘¥ê±¸ìŒ (Thunderstep)",
    rarity:"unique",
    desc:"ì  ì²˜ì¹˜ ì‹œ ë²ˆê°œê°€ ì£¼ë³€ìœ¼ë¡œ ì—°ì‡„ (ì¿¨ 0.8ì´ˆ)",
    applyStat(){ applyGearDelta({ dmgMul: 1.10 }); },
    onEvent(type, p){
      if(type !== "kill") return;

      const now = frameCount;
      const key = this.id + "_cd";
      const cd = uniqueState[key] ?? 0;
      if(now < cd) return;
      uniqueState[key] = now + 48;

      const cx = p.x, cy = p.y;
      let hits = 0;

      for(const e of enemies){
        if(e.hp <= 0) continue;
        if(e.type === "boss" && e.dead) continue;

        const dx = e.x - cx, dy = e.y - cy;
        if(dx*dx + dy*dy > 200*200) continue;

        const ctxChain = buildCombatCtx("lightning_chain", e);
        const chainRes = computeFinalDamage(baseDamage * 0.65, ctxChain, { canCrit:false });
        e.hp -= chainRes.dealt;
        spawnHitBlood(e.x, e.y, 8);

        if(particles.length < 260){
          for(let i=0;i<6;i++){
            particles.push({ x:e.x, y:e.y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:18 });
          }
        }
        hits++;
        if(hits >= 4) break;
      }
      pruneDeadEnemies();
    }
  },
  {
    id:"unique_oni_aegis",
    name:"ì˜¤ë‹ˆì˜ ìˆ˜í˜¸ (Oni Aegis)",
    rarity:"unique",
    desc:"í”¼ê²© ì‹œ ë³´í˜¸ë§‰ 1íšŒ ìƒì„± (í”¼í•´ 35% ê°ì†Œ ëŠë‚Œ, 2ì´ˆ, ì¿¨ 6ì´ˆ)",
    applyStat(){
      player.baseArmor += 4;
      player.baseMaxHp += 20;
      player.hp += 20;
    },
    onEvent(type, p){
      if(type !== "takeDamage") return;
      const now = frameCount;
      const cdKey = this.id + "_cd";
      if((uniqueState[cdKey] ?? 0) > now) return;

      applyBuff(player, "armor", 30, 120, "oni_aegis", "add");
      uniqueState[cdKey] = now + 360;

      shake = Math.max(shake, 12);
      for(let i=0;i<22;i++){
        particles.push({ x:player.x, y:player.y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:22 });
      }
    }
  },
  {
    id:"unique_bloodkatana",
    name:"í˜ˆê·€ì˜ ë„ (Blood Katana)",
    rarity:"unique",
    desc:"íƒ€ê²© ì‹œ 20% í™•ë¥ ë¡œ ì¶œí˜ˆ ì¥íŒ ìƒì„±(3ì´ˆ). ì¥íŒì€ ì´ˆë‹¹ í”¼í•´ + í¡í˜ˆ",
    applyStat(){
      baseDamageBase *= 1.08;
      recalcFromGear();
    },
    onEvent(type, p){
      if(type !== "hit") return;
      if(Math.random() > 0.20) return;

      const x = p.enemy.x;
      const y = p.enemy.y;

      fireZones.push({
        x, y,
        radius:60,
        life:180,
        tick:0,
        damage: Math.max(2, baseDamage * 0.18),
        isBleed:true
      });
    }
  }
];

function rollRarity(){
  const t = mapTier;

  // PoE ëŠë‚Œ: unique(ì•„ì£¼ ë‚®ìŒ) / rare / magic / normal
  const uniqueP = clamp(0.004 + (t-1)*0.00035, 0.004, 0.020);
  const rareP   = clamp(0.055 + (t-1)*0.0020, 0.055, 0.140);
  const magicP  = clamp(0.240 + (t-1)*0.0060, 0.240, 0.420);

  const r = Math.random();
  if(r < uniqueP) return "unique";
  if(r < uniqueP + rareP) return "rare";
  if(r < uniqueP + rareP + magicP) return "magic";
  return "normal";
}


function pickItemsForChoice(count){

  // âœ… mapTierëŠ” ì „ì—­ ë³€ìˆ˜(mapTier)ë¥¼ ì‚¬ìš© (Game ë¯¸ì •ì˜ë¡œ ì¸í•œ ReferenceError ë°©ì§€)
  const mapTier = Math.max(1,
    (typeof globalThis!=="undefined" && typeof globalThis.mapTier==="number")
      ? globalThis.mapTier
      : 1
  );
  if(!Array.isArray(ITEM_POOL) || ITEM_POOL.length === 0){
    console.warn("ITEM_POOL empty");
    return [];
  }

  // helpers may not exist in some builds; provide safe fallbacks
  const safePickSlot = (typeof pickSlotForMapTier === "function")
    ? pickSlotForMapTier
    : (t)=> "weapon";

  const safePickBaseTier = (typeof pickBaseTierForMap === "function")
    ? pickBaseTierForMap
    : (t)=> t;

  const safeRollIlvl = (typeof rollItemLevelFromMapTier === "function")
    ? rollItemLevelFromMapTier
    : (t)=> Math.max(1, t*5);

  const results = [];
  const usedBaseIds = new Set();

  for(let i=0;i<count;i++){

    let slot = null;
    try { slot = safePickSlot(mapTier); } catch(e){ slot = null; }
    if(!slot) slot = "weapon";

    let pool = ITEM_POOL.filter(b => b && b.slot === slot);
    if(!pool.length) pool = ITEM_POOL.filter(b => b) || [];

    if(!pool.length){
      console.warn("No base pool for slot:", slot);
      continue;
    }

    let targetTier = null;
    try { targetTier = safePickBaseTier(mapTier); } catch(e){ targetTier = null; }
    if(!targetTier) targetTier = mapTier;

    let filtered = pool.filter(b => (b.baseTier ?? 1) <= targetTier);
    if(!filtered.length) filtered = pool;

    // build weighted list safely (cap expansion)
    const weighted = [];
    const CAP = 3000;
    for(const b of filtered){
      if(!b) continue;
      const w = Math.max(1, Math.floor(b.weight ?? 100));
      for(let k=0;k<w && weighted.length < CAP;k++){
        weighted.push(b);
      }
      if(weighted.length >= CAP) break;
    }

    if(!weighted.length){
      console.warn("Weighted empty for slot:", slot, "tier:", targetTier);
      continue;
    }

    let choice = null;
    for(let t=0;t<7;t++){
      const cand = weighted[Math.floor(Math.random()*weighted.length)];
      if(cand && cand.id && !usedBaseIds.has(cand.id)){
        choice = cand;
        break;
      }
    }
    if(!choice){
      const cand = weighted[Math.floor(Math.random()*weighted.length)];
      if(cand && cand.id) choice = cand;
    }
    if(!choice || !choice.id){
      console.warn("No choice resolved");
      continue;
    }

    usedBaseIds.add(choice.id);

    const ilvl = Math.max(1, safeRollIlvl(mapTier));

    let item = null;
    try{
      // createItemInstance signature differs across builds; support both
      if(typeof createItemInstance === "function"){
        item = createItemInstance(choice.id, null, { ilvl });
      }
    }catch(e){
      console.warn("createItemInstance failed:", e);
      item = null;
    }

    if(item) results.push(item);
  }

  
  // âœ… ì•ˆì „ì¥ì¹˜: ì–´ë–¤ ì´ìœ ë¡œë“  ê²°ê³¼ê°€ ë¹„ë©´ ìµœì†Œ 1ê°œëŠ” ê°•ì œë¡œ ìƒì„±
  if(results.length === 0){
    try{
      const fallback = (Array.isArray(ITEM_POOL) && ITEM_POOL.length) ? ITEM_POOL[Math.floor(Math.random()*ITEM_POOL.length)] : null;
      if(fallback && fallback.id && typeof createItemInstance==="function"){
        const ilvl = Math.max(1, safeRollIlvl(mapTier));
        const it = createItemInstance(fallback.id, null, { ilvl });
        if(it) results.push(it);
      }
    }catch(e){ /* ignore */ }
  }
return results;
}


function spawnLoot(x, y, source="mob"){
  if(loots.length > 25) loots.splice(0, loots.length-25);
const choices = pickItemsForChoice(3);
if(!choices || !choices.length){
  console.warn("No items rolled");
  return;
}
loots.push({ x, y, r: 14, ttl: 60*45, choices, taken: false, source });
}

function getNearbyLoot(){
  for(const L of loots){
    if(L.taken) continue;
    const dx = L.x - player.x;
    const dy = L.y - player.y;
    const rr = (L.r + player.radius + 18);
    if(dx*dx + dy*dy <= rr*rr) return L;
  }
  return null;
}

function openLootChoice(L){
  if(!L || L.taken) return;
  pauseGame({ dim: 0.60, blur: 2 });
  lootOverlayOpen = true;
  pendingLoot = L;

  lootOverlay.style.display = "flex";
  lootCardsEl.innerHTML = "";

  L.choices.forEach((it)=>{
    const card = document.createElement("div");
    card.className = `lootCard ${normalizeRarity(it.rarity)}`;

    const ilvl = getItemLevel();
    const pick = { it, ilvl };

    if(normalizeRarity(it.rarity) === "unique"){
      pick.kind = "unique";
      pick.shownName = it.name;
      pick.shownDesc = it.desc;
    }else{
      pick.kind = "normal";
      pick.baseData = buildBaseDataFromItemId(it.id);
      pick.tags = inferItemTagsFromTemplate(it, it.id);
      pick.affixes = rollAffixesPOE(it.rarity, ilvl, pick.tags);

      // âœ… STEP2/4: tags/mods + mods ê¸°ë°˜ ë°ì´í„° ìƒì„±
      pick.mods = buildItemMods(it.id, pick.baseData, pick.affixes, pick.tags);

      const affixData = USE_MODS_FOR_ITEMDATA
        ? buildAffixDataFromMods(pick.mods)
        : (function(){
            const d = makeEmptyItemData();
            for(const a of pick.affixes){ if(a && a.affix && typeof a.affix.apply === "function") a.affix.apply(d, a.value); }
            return d;
          })();

      pick.affixData = affixData;
      pick.totalData = mergeItemData(pick.baseData, pick.affixData);

      const preNames = pick.affixes.filter(x=>x.kind==="prefix").map(x=>x.affix.name);
      const sufNames = pick.affixes.filter(x=>x.kind==="suffix").map(x=>x.affix.name);

      pick.baseName = it.name;
      pick.baseId = it.id;

      let nm = pick.baseName;
      if(preNames.length) nm = preNames.join(" ") + " " + nm;
      if(sufNames.length) nm = nm + " " + sufNames.join(" ");
      pick.name = nm;

      pick.shownName = pick.name;
      pick.shownDesc = it.descGen ? it.descGen(pick.totalData) : (it.desc || "");
    }

    const rKey = normalizeRarity(it.rarity);

card.innerHTML = `
  <div class="name rName r-${rKey}">${pick.shownName}</div>
  <div class="desc">${pick.shownDesc}</div>
  <button type="button">ì´ê±¸ ì„ íƒ</button>
`;

    card.querySelector("button").addEventListener("click", ()=>{
      if(pick.kind === "legendary"){
        acquireLegendary(pick.it, pick.ilvl);
      } else {
        const chosen = {
          id: pick.baseId,
          baseId: pick.baseId,
          baseName: pick.baseName,
          name: pick.name,
          rarity: pick.it.rarity,
          slot: pick.it.slot,
          ilvl: pick.ilvl,
          isUnique: false,
          data: pick.totalData,
          totalData: pick.totalData,
          baseData: pick.baseData,
          affixData: pick.affixData,
          affixes: pick.affixes,
          shownDesc: pick.shownDesc
        };
        inventory.push(chosen);
        if(panelOpen) renderAllPanels();
      }
      L.taken = true;
      closeLootChoice();
      shake = Math.max(shake, 10);
    });

    lootCardsEl.appendChild(card);
  });
}

function closeLootChoice(){
  lootOverlayOpen = false;
  pendingLoot = null;
  lootOverlay.style.display = "none";
  resumeGame();
}

function updateLoots(){
  for(let i=loots.length-1;i>=0;i--){
    const L = loots[i];
    if(L.taken){ loots.splice(i,1); continue; }
    L.ttl--;
    if(L.ttl <= 0) loots.splice(i,1);
  }
}
function drawLoots(){
  if(loots.length === 0) return;

  ctx.save();
  for(const L of loots){
    if(L.taken) continue;

    const pulse = 0.5 + 0.5*Math.sin(frameCount*0.15);
    ctx.globalAlpha = 0.75 + pulse*0.25;

    ctx.fillStyle = "rgba(80,140,255,0.25)";
    ctx.beginPath();
    ctx.arc(L.x, L.y, L.r + 10 + pulse*6, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(40,120,255,0.9)";
    ctx.beginPath();
    ctx.arc(L.x, L.y, L.r, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.fillStyle = "#fff";
    ctx.font = "bold 16px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("!", L.x, L.y+1);
  }
  ctx.restore();
}

/* ============================= */
/* âœ… POEì‹ ì¥ë¹„ ìŠ¬ë¡¯ / ì¸ë²¤í† ë¦¬  */
/* ============================= */
const EQUIP_SLOTS = ["weapon","helm","chest","ring"];
let equipment = { weapon:null, helm:null, chest:null, ring:null };

let inventory = [];
let selectedInvIndex = -1;

let transmuteOrbs = 6;   // ë³€í™˜ì˜ ì˜¤ë¸Œ
let alterationOrbs = 10; // ë³€í™”ì˜ ì˜¤ë¸Œ
let augmentationOrbs = 6;// ì¦ê°•ì˜ ì˜¤ë¸Œ
let regalOrbs = 3;       // ì œì™•ì˜ ì˜¤ë¸Œ
let alchemyOrbs = 3;     // ì—°ê¸ˆìˆ ì‚¬ì˜ ì˜¤ë¸Œ
let chaosOrbs = 2;       // ì¹´ì˜¤ìŠ¤ì˜ ì˜¤ë¸Œ
let scouringOrbs = 3;    // ì„¸ê³µì˜ ì˜¤ë¸Œ
let exaltedOrbs = 1;     // ìŠ¹ê²©ì˜ ì˜¤ë¸Œ
let annulOrbs = 1;       // ì†Œë©¸ì˜ ì˜¤ë¸Œ
let divineOrbs = 1;      
let corruptOrbs = 5;
// ì‹ ì„±í•œ ì˜¤ë¸Œ


let orbUIState = { cx:0, cy:0, centerR:24, ready:false };
let particles=[];
let bloodPools=[];
let shake=0;
let xp = 0;
let xpToNext = 120;
let level = 1;
let gameOver = false;
let orbFlash = 0;
let flashEffect = 0;

let baseDamageBase = 20;
let ultiDamageBase = 40;

let baseDamage = baseDamageBase;
let ultiDamage = ultiDamageBase;

player.gear = {
  dmgMul: 1,
  spdMul: 1,
  atkSpdMul: 1,
  rangeMul: 1,
  armorAdd: 0,
  maxHpAdd: 0,
  hpRegen: 0,
  critChanceAdd: 0,
  critChanceMul: 1,
  critMultiAdd: 0,
};


/* =========================================================
   STEP 3) recalcFromGear()ì—ì„œ mods ê¸°ë°˜ ê³„ì‚° ë ˆì´ì–´ ì¶”ê°€
   - item.data(ê¸°ì¡´)ì™€ ë³„ê°œë¡œ item.mods ë¥¼ ì´ìš©í•´ gearDeltaë¥¼ ë§Œë“¤ì–´ applyGearDeltaì— ì£¼ì…
   - ë‚˜ì¤‘ì— affix.apply â†’ mods ìƒì„±ìœ¼ë¡œ ì™„ì „ ì´ê´€í•˜ê¸° ìœ„í•œ ë°œíŒ
   - í˜¹ì‹œ ìŠ¤íƒ¯ì´ ì´ìƒí•˜ë©´ ì•„ë˜ í”Œë˜ê·¸ë¥¼ falseë¡œ ë°”ê¾¸ë©´ ì¦‰ì‹œ ì›ë³µë¨
   ========================================================= */
const USE_GEAR_MODS_LAYER = true;

function gearTagsFromItem(it){
  const tags = [];
  if(it && it.slot) tags.push(it.slot);
  if(it && Array.isArray(it.tags)) tags.push(...it.tags);
  tags.push("gear");
  return mergeTags(tags);
}

function gearDeltaFromMods(modList, ctx){
  const out = {};
  if(!Array.isArray(modList) || modList.length === 0) return out;

  const mctx = {
    scope: (ctx && ctx.scope) ? ctx.scope : "gear",
    tags:  (ctx && ctx.tags)  ? ctx.tags  : []
  };

  for(const m of modList){
    if(!m) continue;

    // íƒœê·¸/ìŠ¤ì½”í”„ ë§¤ì¹­ (ì—”ì§„ ê³µí†µ ê·œì¹™)
    if(typeof modMatches === "function" && !modMatches(m, mctx)) continue;

    const k = m.stat;
    if(!k) continue;

    const op = m.op || MOD_OPS.add;
    const v  = (Number(m.value) || 0);

    if(op === MOD_OPS.add){
      out[k] = (out[k] || 0) + v;
    }else if(op === MOD_OPS.inc){
      // gear ìª½ì€ Inc í‚¤ë¥¼ ì“°ëŠ” ê²½ìš°ê°€ ë§ì•„ì„œ, kInc í˜•íƒœë¡œ ë„£ì–´ë‘ 
      const kk = (String(k).endsWith("Inc") ? k : (k + "Inc"));
      out[kk] = (out[kk] || 0) + v;
    }else if(op === MOD_OPS.more){
      const mul = 1 + v;
      out[k] = (out[k] || 1) * mul;
    }
  }
  return out;
}


function recalcFromGear(){
  // âœ… ì „ì²´ë¥¼ ë‹¤ì‹œ ê³„ì‚°(ì•ˆì •í™”): ì¥ë¹„/ë²„í”„ ëˆ„ì  â†’ ìµœì¢… ìŠ¤íƒ¯ ë°˜ì˜
  player.gear = defaultBuffStats();

  // 1) ì¥ë¹„ ëˆ„ì 
  for(const slot of EQUIP_SLOTS){
    const it = equipment[slot];
    if(!it) continue;

    // âœ… STEP3: mods ê¸°ë°˜ ë ˆì´ì–´ (ê¸°ì¡´ data ë¡œì§ì€ ìœ ì§€í•œ ì±„ë¡œ ì„ íƒ ì‚¬ìš©)
    if(USE_GEAR_MODS_LAYER && Array.isArray(it.mods) && it.mods.length){
      const tags = gearTagsFromItem(it);
      const d2 = gearDeltaFromMods(it.mods, { scope:"gear", tags });
      if(d2) applyGearDelta(d2);
      continue;
    }

    // totalData ìš°ì„ , ì—†ìœ¼ë©´ data ì‚¬ìš©
    const d = it.totalData || it.data || null;
    if(!d) continue;

    applyGearDelta(d);
  }

  // 2) ìµœì¢… ì¶œë ¥ê°’ ê³„ì‚° (POEì‹)
  const g = player.gear;

  g.dmgMul    = (1 + (g.dmgInc || 0))    * (g.dmgMore    || 1);
  g.atkSpdMul = (1 + (g.atkSpdInc || 0)) * (g.atkSpdMore || 1);
  g.spdMul    = (1 + (g.spdInc || 0))    * (g.spdMore    || 1);
  g.rangeMul  = (1 + (g.rangeInc || 0))  * (g.rangeMore  || 1);

  // 3) í”Œë ˆì´ì–´ ê¸°ë³¸ ëŠ¥ë ¥ì¹˜ì— ë°˜ì˜
  const baseMaxHp = (player.baseMaxHp ?? 100);
  const baseArmor = (player.baseArmor ?? 0);

  player.maxHp = baseMaxHp + (g.maxHpAdd || 0);
  player.armor = baseArmor + (g.armorAdd || 0);

  // í˜„ì¬ HPê°€ maxë¥¼ ë„˜ì§€ ì•Šê²Œ
  if(player.hp > player.maxHp) player.hp = player.maxHp;
}

function applyGearDelta(d){
  // âœ… ì¥ë¹„/ë²„í”„ ìŠ¤íƒ¯ ëˆ„ì  (POEì‹)
  if(!d) return;
  if(!player.gear) player.gear = defaultBuffStats();

  const g = player.gear;

  // 1) ê¸°ì¡´(Add) ê³ ì •ê°’
  if(d.maxHpAdd) g.maxHpAdd += d.maxHpAdd;
  if(d.armorAdd) g.armorAdd += d.armorAdd;
  if(d.hpRegen)  g.hpRegen  += d.hpRegen;

  // 2) increased(Inc) / more(Mul) â€” ì—†ìœ¼ë©´ ë¬´ì‹œ
  // í”¼í•´
  if(d.dmgInc) g.dmgInc += d.dmgInc;
  if(d.dmgMul) g.dmgMore *= d.dmgMul;

  // ê³µê²©ì†ë„
  if(d.atkSpdInc) g.atkSpdInc += d.atkSpdInc;
  if(d.atkSpdMul) g.atkSpdMore *= d.atkSpdMul;

  // ì´ë™ì†ë„
  if(d.spdInc) g.spdInc += d.spdInc;
  if(d.spdMul) g.spdMore *= d.spdMul;

  // ì‚¬ê±°ë¦¬
  if(d.rangeInc) g.rangeInc += d.rangeInc;
  if(d.rangeMul) g.rangeMore *= d.rangeMul;

  // ì¹˜ëª…íƒ€ í™•ë¥ /ë°°ìˆ˜
  if(d.critChanceAdd) g.critChanceAdd += d.critChanceAdd;
  if(d.critChanceInc) g.critChanceInc += d.critChanceInc;
  if(d.critChanceMul) g.critChanceMore *= d.critChanceMul;

  if(d.critMultiAdd) g.critMultiAdd += d.critMultiAdd;
  if(d.critMultiInc) g.critMultiInc += d.critMultiInc;
}

let levelParticles = [];
let arrows = [];
let bloodParticles = [];
let fireZones = [];
let frameCount = 0;

let killCount = 0;
let killsAtLevelStart = 0;
let killsForNextLevel = 20;
let explosionActive = false;
let bossSpawned = false;
let bossTimer = 0;
let bossInterval = 45 * 60;

let mapTier = 1;
let mapSeed = 0;
let mapRun = {
  tier: 1,
  seed: 0,
  packsToClear: 10,
  clearedPacks: 0,
  bossSpawned: false,
  bossDefeated: false,
};

let portal = {
  active: false,
  x: 0,
  y: 0,
  r: 32,
  hold: 0,
  holdNeed: 25
};
let bossRoom = { x:0, y:0, w:0, h:0, cx:0, cy:0, doorX:0, doorY:0 };

/* ===== ì…ë ¥ ===== */
let joyDX=0, joyDY=0;
let attacking=false;
let attackFrame=0;
let keys = {};

window.addEventListener("keydown", e=>{ keys[e.key] = true; });
window.addEventListener("keyup", e=>{ keys[e.key] = false; });

const pad = document.getElementById("movePad");
const stick = document.getElementById("stick");
const attackBtn = document.getElementById("attackBtn");
let joyActive=false;

function bossDeathSound(){
  let now = audioCtx.currentTime;

  let o1 = audioCtx.createOscillator();
  let g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(220, now);
  o1.frequency.exponentialRampToValueAtTime(45, now + 0.6);
  g1.gain.setValueAtTime(0.25, now);
  g1.gain.exponentialRampToValueAtTime(0.001, now + 0.65);
  o1.connect(g1); g1.connect(audioCtx.destination);
  o1.start(now); o1.stop(now + 0.65);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "square";
  o2.frequency.setValueAtTime(900, now + 0.05);
  o2.frequency.exponentialRampToValueAtTime(180, now + 0.18);
  g2.gain.setValueAtTime(0.12, now + 0.05);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.22);
  o2.connect(g2); g2.connect(audioCtx.destination);
  o2.start(now + 0.05); o2.stop(now + 0.22);
}

function setStickByVector(vx, vy){
  const r = pad.getBoundingClientRect();
  const max = Math.min(r.width, r.height) * 0.33;
  let d = Math.hypot(vx, vy) || 1;
  if(d > max){ vx *= max/d; vy *= max/d; }

  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;

  stick.style.left = (r.width/2 - sw/2 + vx) + "px";
  stick.style.top  = (r.height/2 - sh/2 + vy) + "px";

  joyDX = vx / max;
  joyDY = vy / max;

  if(Math.abs(vx) > Math.abs(vy))
    player.dir = vx > 0 ? "right" : "left";
  else
    player.dir = vy > 0 ? "down" : "up";
}

function handlePadMove(clientX, clientY){
  const r = pad.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top + r.height/2;
  const vx = clientX - cx;
  const vy = clientY - cy;
  setStickByVector(vx, vy);
}

pad.addEventListener("touchstart", (e)=>{
  joyActive = true;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchmove", (e)=>{
  if(!joyActive) return;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchend", ()=>{
  joyActive=false; joyDX=joyDY=0;
  const r = pad.getBoundingClientRect();
  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;
  stick.style.left = (r.width/2 - sw/2) + "px";
  stick.style.top  = (r.height/2 - sh/2) + "px";
});

/* ===== attackBtn = í‰íƒ€ë§Œ ===== */
attackBtn.addEventListener("touchstart", ()=>{
  attacking = true;
  attackFrame = 0;
  swingSound();
  attackBtn.classList.add("active");
},{passive:true});

attackBtn.addEventListener("touchend", ()=>{
  attackBtn.classList.remove("active");
},{passive:true});

/* ===== ìœ í‹¸ ===== */
function rollWeaponDamage(){
  const w = player.weapon;
  return w.min + Math.random() * (w.max - w.min);
}

function getCritChance(){
  // ê¸°ë³¸ì¹˜ + Add â†’ increased â†’ more
  const g = player.gear || {};
  const base = (player.baseCritChance ?? 0.05); // 5% ê¸°ë³¸
  const add = (g.critChanceAdd || 0);
  const inc = (g.critChanceInc || 0);
  const more = (g.critChanceMore || 1);
  return Math.max(0, (base + add) * (1 + inc) * more);
}
function getCritMulti(){
  // ê¸°ë³¸ì¹˜ + Add â†’ increased â†’ more
  const g = player.gear || {};
  const base = (player.baseCritMulti ?? 1.50); // x1.50 ê¸°ë³¸
  const add = (g.critMultiAdd || 0);
  const inc = (g.critMultiInc || 0);
  const more = (g.critMultiMore || 1);
  return Math.max(1, (base + add) * (1 + inc) * more);
}
function applyCrit(dmg){
  const chance = getCritChance();
  const multi = getCritMulti();
  const isCrit = (Math.random() < chance);
  return { dmg: isCrit ? dmg * multi : dmg, isCrit, chance, multi };
}

function defaultBuffStats(){
  // âœ… POEì‹(ê¸°ë³¸ + ì¦ê°€(increased) + ì¶”ê°€ë°°ìœ¨(more))ë¥¼ ë‚´ë¶€ì—ì„œ ì§€ì›
  // - Add : ê³ ì • ìˆ˜ì¹˜(+)   ì˜ˆ) maxHpAdd, armorAdd, hpRegen
  // - Inc : ì¦ê°€(%)        ì˜ˆ) dmgInc = 0.15  (15% increased)
  // - Mul : ì¶”ê°€ ë°°ìœ¨(x)   ì˜ˆ) dmgMul = 1.20  (20% more)
  return {
    maxHpAdd: 0,
    armorAdd: 0,
    hpRegen: 0,

    // í”¼í•´/ì†ë„/ì´ë™/ì‚¬ê±°ë¦¬ (POEì‹)
    dmgInc: 0,     dmgMore: 1,
    atkSpdInc: 0,  atkSpdMore: 1,
    spdInc: 0,     spdMore: 1,
    rangeInc: 0,   rangeMore: 1,

    // ì¹˜ëª…íƒ€ (POEì‹)
    critChanceAdd: 0,
    critChanceInc: 0,
    critChanceMore: 1,

    critMultiAdd: 0,
    critMultiInc: 0,
    critMultiMore: 1,

    // ğŸ”» ìµœì¢… ì¶œë ¥(ì•„ë˜ recalcFromGearì—ì„œ ì±„ì›€)
    dmgMul: 1,
    atkSpdMul: 1,
    spdMul: 1,
    rangeMul: 1,
  };
}

function applyBuff(target, type, value, duration, source="", mode="mul"){
  if(!target.activeBuffs) target.activeBuffs = [];
  const key = type + "|" + source + "|" + mode;
  const b = target.activeBuffs.find(x => x.key === key);

  if(b){
    b.value = value;
    b.duration = Math.max(b.duration, duration);
  }else{
    target.activeBuffs.push({ key, type, value, duration, mode });
  }
}

function mapBuffTypeToStat(type){
  if(type === "damage")   return "dmgMul";
  if(type === "speed")    return "spdMul";
  if(type === "atkSpeed") return "atkSpdMul";
  if(type === "range")        return "rangeMul";
  if(type === "meleeRange")   return "meleeRangeMul";
  if(type === "aoe")          return "aoeMul";
  if(type === "ultiAoe")      return "ultiAoeMul";
  if(type === "armor")        return "armorAdd";
  if(type === "armorMul")     return "armorMul";
  if(type === "maxHpMul")     return "maxHpMul";
  if(type === "maxHp")        return "maxHpAdd";
  if(type === "hpRegen")      return "hpRegen";
  return null;
}

function updateBuffs(target){
  if(!target.activeBuffs) target.activeBuffs = [];
  target.buffs = defaultBuffStats();

  if(target === player){
    target.buffs.dmgMul   *= (player.gear.dmgMul ?? 1);
    target.buffs.rangeMul *= (player.gear.rangeMul ?? 1);
    target.buffs.spdMul    *= (player.gear.spdMul ?? 1);
    target.buffs.atkSpdMul *= (player.gear.atkSpdMul ?? 1);
    target.buffs.armorAdd += (player.gear.armorAdd ?? 0);
    target.buffs.maxHpAdd += (player.gear.maxHpAdd ?? 0);
    target.buffs.hpRegen  += (player.gear.hpRegen ?? 0);
  }

  for(let i = target.activeBuffs.length - 1; i >= 0; i--){
    const b = target.activeBuffs[i];
    b.duration--;
    if(b.duration <= 0){
      target.activeBuffs.splice(i,1);
      continue;
    }
    const stat = mapBuffTypeToStat(b.type);
    if(!stat) continue;

    if(b.mode === "mul"){
      if(target.buffs[stat] !== undefined) target.buffs[stat] *= b.value;
    }else if(b.mode === "add"){
      if(target.buffs[stat] !== undefined) target.buffs[stat] += b.value;
    }
  }

  if(target === player){
    const b = target.buffs;
    const newMax = Math.max(1, Math.floor(target.baseMaxHp * (b.maxHpMul ?? 1) + (b.maxHpAdd ?? 0)));
    target.maxHp = newMax;
    if(target.hp > target.maxHp) target.hp = target.maxHp;
    target.armor = Math.max(0, (target.baseArmor + (b.armorAdd ?? 0)) * (b.armorMul ?? 1));
  }
}

/* ===== ì—¬ê¸° ì•„ë˜ëŠ” ë„ˆê°€ ì˜¬ë ¤ì¤€ ì›ë³¸ ë¡œì§ ê·¸ëŒ€ë¡œ(ë§µ/ëª¹/ì „íˆ¬/ë Œë”) ===== */
/* NOTE: ë¸”ë™ìŠ¤í¬ë¦° ì›ì¸(êµ¬ ì¸ë²¤ ë§ˆí¬ì—… + CSS ê¹¨ì§ + prettyItemText ì¤„ë°”ê¿ˆ ë²„ê·¸)ì„ ì œê±°/ìˆ˜ì •í–ˆìŒ.
   ì•„ë˜ ë¡œì§ì€ ë„ˆë¬´ ê¸¸ì–´ì„œ ìƒëµí•˜ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ì´ì–´ì ¸ì•¼ í•¨. */

/* ---------------------------------------------------------------------- */
/* ë„ˆê°€ ì˜¬ë¦° ì½”ë“œì—ì„œ ì—¬ê¸° ì´í›„(ë§µ ìƒì„±/ëª¬ìŠ¤í„°/ë Œë”/íŒ¨ë„ ë¡œì§/loop/resetGame)
   ëŠ” ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ë˜, ì•„ë˜ ë‘ ê°€ì§€ë§Œ ê¼­ ì ìš©ë¼ ìˆì–´ì•¼ í•´:

   âœ… 1) 'prettyItemText' ë§ˆì§€ë§‰ return:
      return lines.join("\\n");

   âœ… 2) êµ¬ë²„ì „ ì¸ë²¤ HTML ë¸”ë¡( invHeaderSub ~ invHint )ì€ ì•„ì˜ˆ ì—†ìŒ.

   ì´ íŒŒì¼ì€ ë¸”ë™ìŠ¤í¬ë¦° ì›ì¸ ì œê±°ìš© â€œì •ë¦¬ë³¸ í…œí”Œë¦¿â€ì´ì•¼.
   ë„ˆê°€ ì›ë³¸ ì½”ë“œì˜ ë‚˜ë¨¸ì§€ ë¶€ë¶„ì„ ì—¬ê¸° ì•„ë˜ì— ê·¸ëŒ€ë¡œ ë¶™ì—¬ë„£ìœ¼ë©´ ë°”ë¡œ ì‹¤í–‰ë¨.
*/
/* ---------------------------------------------------------------------- */
function pruneDeadEnemies(){
  enemies = enemies.filter(e =>
    (e.hp > 0) ||
    (e.type === "boss" && e.dead && e.deathTimer > 0)
  );
  for(const p of packs){
    p.enemies = p.enemies.filter(e => e.hp > 0 || (e.type==="boss" && e.dead && e.deathTimer > 0));
  }
}

function getRandomVisibleAliveEnemy(){
  const visible = enemies.filter(e =>
    e.hp > 0 &&
    !(e.type === "boss" && e.dead) &&
    isEnemyOnScreen(e)
  );
  if(visible.length === 0) return null;
  return visible[(Math.random() * visible.length) | 0];
}

function getRandomAliveEnemy(){
  const alive = enemies.filter(e => e.hp > 0 && !(e.type === "boss" && e.dead));
  if(alive.length === 0) return null;
  return alive[(Math.random() * alive.length) | 0];
}

function getLevelPenalty(playerLv, monsterLv){
  const diff = monsterLv - playerLv;
  if(diff >= 0) return 1 + diff * 0.04;
  if(diff <= -6) return 0.1;
  return 1 + diff * 0.12;
}

/* ===== POE ë§µí•‘: í‹°ì–´ ìŠ¤ì¼€ì¼/ë§µ ìƒì„± ===== */
function tierScale(t){
  const hpMul  = 1 + (t-1) * 0.22;
  const dmgMul = 1 + (t-1) * 0.16;
  const spdMul = 1 + Math.min(0.25, (t-1) * 0.02);
  const eliteChance = clamp(0.06 + (t-1) * 0.008, 0.06, 0.22);
  const eliteHpMul = 2.4;
  const eliteDmgMul = 1.9;
  return { hpMul, dmgMul, spdMul, eliteChance, eliteHpMul, eliteDmgMul };
}

function giveXP(enemy){
  let base = 0;
  if(enemy.type === "mage") base = 14;
  else if(enemy.type === "archer") base = 12;
  else if(enemy.type === "melee") base = 10;
  else if(enemy.type === "boss") base = 200 * mapTier;

  if(enemy.isElite) base *= 3;
  if(enemy.isLeader) base *= 4;

  const levelMul = getLevelPenalty(level, mapTier);
  const mapMul = 1 + (mapTier - 1) * 0.08;

  const finalXP = Math.floor(base * levelMul * mapMul);
  xp += finalXP;
  checkLevelUp();
}

function makeEnemyStatsByTier(type, t){
  const s = tierScale(t);

  let baseHp, baseDmg, baseSpd;
  if(type === "mage"){
    baseHp  = 42;
    baseDmg = 9;
    baseSpd = 0.48;
  }else if(type === "archer"){
    baseHp  = 30;
    baseDmg = 14;
    baseSpd = 0.55;
  }else{
    baseHp  = 55;
    baseDmg = 11;
    baseSpd = 0.85;
  }

  return {
    hp:  baseHp  * s.hpMul,
    dmg: baseDmg * s.dmgMul,
    spd: baseSpd * s.spdMul,
    eliteChance: s.eliteChance,
    eliteHpMul: s.eliteHpMul,
    eliteDmgMul: s.eliteDmgMul
  };
}

function makeBossStatsByTier(t){
  const baseHp  = 900;
  const baseDmg = 26;
  const baseSpd = 0.62;

  const bossHp  = baseHp  * (1 + (t-1)*0.28);
  const bossDmg = baseDmg * (1 + (t-1)*0.18);
  const bossSpd = baseSpd * (1 + Math.min(0.18, (t-1)*0.015));

  return { bossHp, bossDmg, bossSpd };
}

function dist2(ax, ay, bx, by){
  const dx = ax - bx;
  const dy = ay - by;
  return dx*dx + dy*dy;
}

function srand(seed){
  let s = seed >>> 0;
  return function(){
    s = (s * 1664525 + 1013904223) >>> 0;
    return s / 4294967296;
  };
}

function clearSpawnArea(cx, cy, radiusTiles=3){
  const tx = Math.floor(cx / tileSize);
  const ty = Math.floor(cy / tileSize);
  for(let y=ty-radiusTiles; y<=ty+radiusTiles; y++){
    for(let x=tx-radiusTiles; x<=tx+radiusTiles; x++){
      if(x<=0||y<=0||x>=mapSize-1||y>=mapSize-1) continue;
      map[y][x] = 0;
    }
  }
}

function carveBossRoomAndCorridor(){
  const w = 7 + Math.floor(Math.random()*5);
  const h = 7 + Math.floor(Math.random()*5);
  const margin = 2;

  const corner = (Math.random()*4)|0;
  let x0, y0;

  if(corner===0){ x0 = mapSize - margin - w; y0 = margin; }
  if(corner===1){ x0 = margin; y0 = margin; }
  if(corner===2){ x0 = margin; y0 = mapSize - margin - h; }
  if(corner===3){ x0 = mapSize - margin - w; y0 = mapSize - margin - h; }

  for(let y=y0; y<y0+h; y++){
    for(let x=x0; x<x0+w; x++){
      map[y][x] = 0;
    }
  }

  const cx = Math.floor(mapSize/2), cy = Math.floor(mapSize/2);
  const roomCx = x0 + (w>>1), roomCy = y0 + (h>>1);

  let doorX = roomCx;
  let doorY = roomCy;

  if(Math.abs(roomCx - cx) > Math.abs(roomCy - cy)){
    if(roomCx > cx){ doorX = x0;       doorY = roomCy; }
    else           { doorX = x0+w-1;   doorY = roomCy; }
  }else{
    if(roomCy > cy){ doorY = y0;       doorX = roomCx; }
    else           { doorY = y0+h-1;   doorX = roomCx; }
  }

  map[doorY][doorX] = 0;

  const startX = Math.floor(player.x / tileSize);
  const startY = Math.floor(player.y / tileSize);

  let x = startX, y = startY;
  const stepX = doorX > x ? 1 : -1;
  while(x !== doorX){
    map[y][x] = 0;
    map[y-1] && (map[y-1][x] = 0);
    map[y+1] && (map[y+1][x] = 0);
    x += stepX;
  }
  const stepY = doorY > y ? 1 : -1;
  while(y !== doorY){
    map[y][x] = 0;
    map[y][x-1] !== undefined && (map[y][x-1] = 0);
    map[y][x+1] !== undefined && (map[y][x+1] = 0);
    y += stepY;
  }
  map[doorY][doorX] = 0;

  bossRoom = { x:x0, y:y0, w, h, cx:roomCx, cy:roomCy, doorX, doorY };
}

function buildEmptyMap(){
  map = [];
  for(let y=0; y<mapSize; y++){
    let row = [];
    for(let x=0; x<mapSize; x++){
      if(x===0 || y===0 || x===mapSize-1 || y===mapSize-1) row.push(1);
      else row.push(0);
    }
    map.push(row);
  }
}

function placeRandomWalls(rng, wallCount){
  for(let i=0;i<wallCount;i++){
    const w = 2 + Math.floor(rng()*5);
    const h = 2 + Math.floor(rng()*5);
    const x0 = 1 + Math.floor(rng()*(mapSize-2-w));
    const y0 = 1 + Math.floor(rng()*(mapSize-2-h));

    const cx = Math.floor(mapSize/2);
    const cy = Math.floor(mapSize/2);
    if(Math.abs((x0 + (w>>1)) - cx) < 4 && Math.abs((y0 + (h>>1)) - cy) < 4){
      continue;
    }

    for(let y=y0; y<y0+h; y++){
      for(let x=x0; x<x0+w; x++){
        if(x<=0||y<=0||x>=mapSize-1||y>=mapSize-1) continue;
        map[y][x] = 1;
      }
    }
  }
}

function buildReachableMaskFromPlayer(){
  const startX = Math.floor(player.x / tileSize);
  const startY = Math.floor(player.y / tileSize);

  const vis = Array.from({length: mapSize}, ()=>Array(mapSize).fill(false));
  if(!map[startY] || map[startY][startX] !== 0) return vis;

  const q = [[startX, startY]];
  vis[startY][startX] = true;

  while(q.length){
    const [x,y] = q.pop();
    const nb = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
    for(const [nx,ny] of nb){
      if(nx<=0||ny<=0||nx>=mapSize-1||ny>=mapSize-1) continue;
      if(vis[ny][nx]) continue;
      if(map[ny][nx] !== 0) continue;
      vis[ny][nx] = true;
      q.push([nx,ny]);
    }
  }
  return vis;
}

function floodFillReachableFromPlayer(){
  const startX = Math.floor(player.x / tileSize);
  const startY = Math.floor(player.y / tileSize);
  if(!map[startY] || map[startY][startX] !== 0) return 0;

  const vis = Array.from({length: mapSize}, ()=>Array(mapSize).fill(false));
  const q = [[startX,startY]];
  vis[startY][startX] = true;
  let count = 0;

  while(q.length){
    const [x,y] = q.pop();
    count++;
    const nb = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
    for(const [nx,ny] of nb){
      if(nx<=0||ny<=0||nx>=mapSize-1||ny>=mapSize-1) continue;
      if(vis[ny][nx]) continue;
      if(map[ny][nx] !== 0) continue;
      vis[ny][nx] = true;
      q.push([nx,ny]);
    }
  }
  return count;
}

function generateRandomMapForTier(tier){
  const seed = (Date.now() ^ (tier*987654321)) >>> 0;
  const rng = srand(seed);

  for(let attempt=0; attempt<8; attempt++){
    buildEmptyMap();

    const wallCount = 22 + Math.floor(tier*2.2) + Math.floor(rng()*10);
    placeRandomWalls(rng, wallCount);

    clearSpawnArea(player.x, player.y, 3);

    const reachable = floodFillReachableFromPlayer();
    const totalFloor = (mapSize-2)*(mapSize-2);
    if(reachable / totalFloor >= 0.55){
      return seed;
    }
  }
  buildEmptyMap();
  clearSpawnArea(player.x, player.y, 4);
  return seed;
}

function startNewMap(nextTier){
  mapTier = nextTier;
  mapRun.tier = nextTier;
  mapRun.clearedPacks = 0;
  mapRun.bossSpawned = false;
  mapRun.bossDefeated = false;

  mapRun.packsToClear = 8 + Math.floor(nextTier * 1.5);

  portal.active = false;
  portal.hold = 0;

  enemies = [];
  packs = [];
  particles = [];
  bloodPools = [];
  bloodParticles = [];
  arrows = [];
  levelParticles = [];
  fireZones = [];

  spawnTimer = 0;
  spawnInterval = 999999;
  bossTimer = 0;

  player.x = mapSize * tileSize / 2;
  player.y = mapSize * tileSize / 2;

  mapRun.seed = generateRandomMapForTier(nextTier);
  carveBossRoomAndCorridor();
  reachableMask = buildReachableMaskFromPlayer();

  spawnMapPacks(nextTier);
  spawnRandomBoss();

  resize();
}

function spawnMapPacks(tier){
  const rng = srand(mapRun.seed ^ 0xA53C9E1B);

  const packCount = mapRun.packsToClear + 4 + Math.floor(tier*0.6);
  for(let i=0;i<packCount;i++){
    let placed = false;

    for(let tries=0; tries<120; tries++){
      const tx = 1 + Math.floor(rng()*(mapSize-2));
      const ty = 1 + Math.floor(rng()*(mapSize-2));
      if(map[ty][tx] !== 0) continue;
      if(reachableMask && !reachableMask[ty][tx]) continue;

      const px = tx*tileSize + tileSize/2;
      const py = ty*tileSize + tileSize/2;

      const dx = px - player.x, dy = py - player.y;
      if(dx*dx + dy*dy < 260*260) continue;

      let min = 25;
      let max = 32;
      if(tier >= 6){
        min = 28 + Math.floor((tier-5) * 0.4);
        max = 36 + Math.floor((tier-5) * 0.6);
      }
      if(tier >= 12){
        min = 30 + Math.floor((tier-10) * 0.5);
        max = 40 + Math.floor((tier-10) * 0.7);
      }
      max = Math.min(max, 45);

      const count = min + Math.floor(rng() * (max - min + 1));
      createPack(px, py, count);

      placed = true;
      break;
    }
    if(!placed){
      // skip
    }
  }

  for(const p of packs){
    p.cleared = false;
  }
  linkNearbyPacks();
}

function linkNearbyPacks(){
  const linkDist = 360;
  const link2 = linkDist * linkDist;

  const n = packs.length;
  const parent = Array.from({length:n}, (_,i)=>i);
  const find = (a)=>{ while(parent[a]!==a){ parent[a]=parent[parent[a]]; a=parent[a]; } return a; };
  const union = (a,b)=>{ a=find(a); b=find(b); if(a!==b) parent[b]=a; };

  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      const dx = packs[i].x - packs[j].x;
      const dy = packs[i].y - packs[j].y;
      if(dx*dx + dy*dy <= link2) union(i,j);
    }
  }

  const rootToG = new Map();
  let gid = 0;

  for(let i=0;i<n;i++){
    const r = find(i);
    if(!rootToG.has(r)) rootToG.set(r, gid++);
    packs[i].groupId = rootToG.get(r);
    packs[i].groupCleared = false;
  }
}

function activatePackGroup(groupId){
  for(const p of packs){
    if(p.groupId === groupId){
      p.activated = true;
      if(p.enemies.length === 0 && !p.cleared){
        p.cleared = true;
      }
    }
  }
}

function spawnPortal(x, y){
  portal.active = true;
  portal.x = x;
  portal.y = y;
  portal.hold = 0;

  for(let i=0;i<90;i++){
    const a = Math.random()*Math.PI*2;
    const sp = 1 + Math.random()*5;
    particles.push({
      x: x + (Math.random()-0.5)*10,
      y: y + (Math.random()-0.5)*10,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp,
      life: 30 + Math.floor(Math.random()*25)
    });
  }
}

function updatePortal(){
  if(!portal.active) return;

  const dx = player.x - portal.x;
  const dy = player.y - portal.y;
  const rr = (portal.r + player.radius + 8);
  if(dx*dx + dy*dy < rr*rr){
    portal.hold++;
    if(portal.hold >= portal.holdNeed){
      startNewMap(mapTier + 1);
      return;
    }
  }else{
    portal.hold = 0;
  }
}

function drawPortal(){
  if(!portal.active) return;

  const pulse = 0.6 + 0.4*Math.sin(frameCount*0.15);
  const r = portal.r + pulse*6;

  ctx.save();
  ctx.globalAlpha = 0.9;

  ctx.strokeStyle = "rgba(120,180,255,0.85)";
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(portal.x, portal.y, r, 0, Math.PI*2);
  ctx.stroke();

  ctx.fillStyle = "rgba(80,140,255,0.18)";
  ctx.beginPath();
  ctx.arc(portal.x, portal.y, r-6, 0, Math.PI*2);
  ctx.fill();

  if(portal.hold > 0){
    const t = clamp(portal.hold / portal.holdNeed, 0, 1);
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(portal.x, portal.y, r+8, -Math.PI/2, -Math.PI/2 + Math.PI*2*t);
    ctx.stroke();
  }

  ctx.restore();
}

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function spawnHitBlood(x, y, amount=10){
  if(bloodParticles.length > 320) return;

  for(let i=0;i<amount;i++){
    bloodParticles.push({
      x: x + (Math.random()-0.5)*6,
      y: y + (Math.random()-0.5)*6,
      vx: (Math.random()-0.5) * 6,
      vy: (Math.random()-0.5) * 6,
      size: Math.random()*3 + 1.5,
      life: 22
    });
  }

  if(bloodPools.length < 140){
    bloodPools.push({
      x: x + (Math.random()-0.5)*8,
      y: y + (Math.random()-0.5)*8,
      size: 5 + Math.random()*4,
      life: 280
    });
  }
}

function startBossDeath(boss){
  if(boss.dead) return;
  if(!boss.xpGiven){
    boss.xpGiven = true;
    giveXP(boss);
  }
  boss.dead = true;
  boss.deathTimer = 60;
  boss.deathMax = 60;

  shake = Math.max(shake, 60);
  slowMotion = Math.max(slowMotion, 10);

  spawnHitBlood(boss.x, boss.y, 40);

  for(let i=0;i<140;i++){
    const a = Math.random()*Math.PI*2;
    const sp = 2 + Math.random()*8;
    particles.push({
      x: boss.x + (Math.random()-0.5)*10,
      y: boss.y + (Math.random()-0.5)*10,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp - (Math.random()*2),
      life: 45 + Math.floor(Math.random()*25)
    });
  }

  if(bloodPools.length < 140){
    bloodPools.push({
      x: boss.x,
      y: boss.y,
      size: 26,
      life: 900
    });
  }

  spawnLoot(boss.x, boss.y, "boss");
  chaosOrbs++;
  bossDeathSound();
}

function canMoveTo(x,y){
  let left = Math.floor((x - player.radius) / tileSize);
  let right = Math.floor((x + player.radius) / tileSize);
  let top = Math.floor((y - player.radius) / tileSize);
  let bottom = Math.floor((y + player.radius) / tileSize);

  return (
    map[top] && map[top][left] === 0 &&
    map[top] && map[top][right] === 0 &&
    map[bottom] && map[bottom][left] === 0 &&
    map[bottom] && map[bottom][right] === 0
  );
}
function canEnemyMoveTo(enemy, x, y){
  let left = Math.floor((x - enemy.radius) / tileSize);
  let right = Math.floor((x + enemy.radius) / tileSize);
  let top = Math.floor((y - enemy.radius) / tileSize);
  let bottom = Math.floor((y + enemy.radius) / tileSize);

  return (
    map[top] && map[top][left] === 0 &&
    map[top] && map[top][right] === 0 &&
    map[bottom] && map[bottom][left] === 0 &&
    map[bottom] && map[bottom][right] === 0
  );
}
function isFloorTile(tx, ty){ return !!(map[ty] && map[ty][tx] === 0); }
function canSpawnEnemyAt(enemy, x, y){ return canEnemyMoveTo(enemy, x, y); }

function resolvePlayerEnemyOverlap(){
  const pad = 2;
  for(const e of enemies){
    if(e.type === "boss" && e.dead) continue;
    if(e.hp <= 0) continue;
    if(e.pack && !e.pack.activated) continue;

    let dx = e.x - player.x;
    let dy = e.y - player.y;
    let dist = Math.hypot(dx, dy);

    const minDist = player.radius + e.radius + pad;

    if(dist === 0){
      dx = (Math.random() - 0.5) * 0.01;
      dy = (Math.random() - 0.5) * 0.01;
      dist = Math.hypot(dx, dy);
    }

    if(dist < minDist){
      const nx = dx / dist;
      const ny = dy / dist;
      const push = (minDist - dist);

      const ex = e.x + nx * push;
      const ey = e.y + ny * push;

      if(canEnemyMoveTo(e, ex, ey)){
        e.x = ex; e.y = ey;
      }else{
        const px = player.x - nx * push;
        const py = player.y - ny * push;
        if(canMoveTo(px, player.y)) player.x = px;
        if(canMoveTo(player.x, py)) player.y = py;
      }
    }
  }
}

function damagePlayer(dmg, knockX, knockY, src){
  if(player.invul > 0 || gameOver) return;

  // âœ… STEP5: í”Œë ˆì´ì–´ê°€ ë°›ëŠ” í”¼í•´ë„ íƒœê·¸ ê¸°ë°˜ìœ¼ë¡œ ì¡°ì ˆ ê°€ëŠ¥
  let incoming = dmg;
  if(USE_TAG_CONTEXTS){
    const srcTags = src ? (src.tags ? src.tags : tagsFromEnemy(src)) : [];
    const ctxIn = { scope:'player', tags: mergeTags(['incoming'], getPlayerTags(), getMapTags(), srcTags) };
    incoming = applyPlayerTakenDamageMods(incoming, ctxIn);
  }

  const armor = (player.armor ?? 0);
  const reduced = incoming * (50 / (50 + Math.max(0, armor)));
  const finalDmg = Math.max(1, Math.floor(reduced));

  player.hp -= finalDmg;
  emitEvent("takeDamage", { dmg: finalDmg });
  player.invul = 25;
  shake = Math.max(shake, 10);

  let nx = player.x + knockX;
  let ny = player.y + knockY;

  if(canMoveTo(nx, player.y)) player.x = nx;
  if(canMoveTo(player.x, ny)) player.y = ny;

  if(player.hp <= 0) handleGameOver();
}

function enemyTryMeleeAttack(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);
  const reach = e.type === "boss" ? 70 : 42;

  if(dist > reach){
    e.attackFrame = 0;
    return;
  }

  if(e.attackFrame === 0){
    e.swingDir = dx < 0 ? -1 : 1;
  }

  const atkMul = (e.buffs?.atkSpdMul ?? 1);
  e.attackFrame += atkMul;

  if(e.attackFrame >= 12 && !e.hitDone){
    e.hitDone = true;
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;
    const kb = e.type === "boss" ? 30 : 18;
    damagePlayer(e.damage, nx*kb, ny*kb, e);
    hitSound();
  }

  if(e.attackFrame >= 25){
    e.attackFrame = 0;
    e.hitDone = false;
  }
}

function spawnArrow(fromX, fromY, toX, toY, damage){
  const dx = toX - fromX;
  const dy = toY - fromY;
  const dist = Math.hypot(dx, dy) || 1;
  const speed = 7.5;

  arrows.push({
    x: fromX,
    y: fromY,
    dx: dx/dist * speed,
    dy: dy/dist * speed,
    damage,
    life: 240,
    tags: mergeTags(['projectile','arrow'], SKILL_TAGS.arrow || ['attack','projectile'])
  });
}

function spawnFireZone(x, y, damage){
  fireZones.push({ x, y, radius:55, life:180, tick:0, damage, tags: mergeTags(['aoe','fire'], SKILL_TAGS.firezone || ['spell','fire','aoe']) });
}

function spawnEnemyAt(ex, ey, pack){
  let tileX = Math.floor(ex / tileSize);
  let tileY = Math.floor(ey / tileSize);

  if(!isFloorTile(tileX, tileY)) return;
  if(!isFloorTile(tileX-1, tileY) || !isFloorTile(tileX+1, tileY) || !isFloorTile(tileX, tileY-1) || !isFloorTile(tileX, tileY+1)) return;
  if(enemies.length >= 320) return;

  let rand = Math.random();
  let type = rand < 0.2 ? "mage" : rand < 0.5 ? "archer" : "melee";

  const st = makeEnemyStatsByTier(type, mapTier);

  let enemy = {
    x: ex, y: ey,
    radius: 14,
    stun: 0,
    invul: 0,
    attackFrame: 0,
    swingDir: 1,
    type,
    hp: st.hp,
    speed: st.spd,
    damage: st.dmg,
    shootCooldown: 0,
    castCooldown: 120,
    pack
  };

  if(!canSpawnEnemyAt(enemy, ex, ey)) return;

  if(Math.random() < st.eliteChance * 0.85){
    enemy.isElite = true;
    enemy.eliteColor = Math.random() < 0.5 ? "yellow" : "blue";
    enemy.speed *= 1.5;
    enemy.damage *= st.eliteDmgMul;
    enemy.radius *= 1.2;
    enemy.hp *= st.eliteHpMul;
  }

    // âœ… STEP5: ì  íƒœê·¸ ë¶€ì—¬(ì—˜ë¦¬íŠ¸ ì—¬ë¶€ í¬í•¨)
  enemy.tags = mergeTags(tagsFromEnemy(enemy));

enemies.push(enemy);
  pack.enemies.push(enemy);
}

function spawnPackLeaderAt(ex, ey, pack){
  const st = makeEnemyStatsByTier("melee", mapTier);

  let leader = {
    x: ex, y: ey,
    radius: 18,
    stun: 0,
    invul: 0,
    attackFrame: 0,
    swingDir: 1,
    type: "melee",
    hp: st.hp * 3.2,
    speed: st.spd * 1.08,
    damage: st.dmg * 1.6,
    shootCooldown: 0,
    castCooldown: 120,
    pack,
    isLeader: true
  };

  if(!canSpawnEnemyAt(leader, ex, ey)) return;

  enemies.push(leader);
  pack.enemies.push(leader);
}

function spawnRandomBoss(){
  if(enemies.some(e => e.type === "boss")) return;

  const bx = bossRoom.cx * tileSize + tileSize/2;
  const by = bossRoom.cy * tileSize + tileSize/2;

  const tempBoss = { radius: 30 };
  if(!canEnemyMoveTo(tempBoss, bx, by)) return;

  const bst = makeBossStatsByTier(mapTier);

  enemies.push({
    x: bx, y: by,
    radius: 30,
    type: "boss",
    maxHp: bst.bossHp,
    hp: bst.bossHp,
    speed: bst.bossSpd,
    damage: bst.bossDmg,
    stun: 0,
    attackFrame: 0,
    swordPulled: false,
    phase2Used: false,
    dashCooldown: 120,
    cleaveCooldown: 160,
    invul: 0,
    phaseLock: 0
  });
}

function createPack(cx, cy, count){
  let pack = {
    x: cx, y: cy,
    enemies: [],
    activated: false,
    cleared: false,
    groupId: -1,
    groupCleared: false
  };

  spawnPackLeaderAt(cx, cy, pack);

  const normalCount = Math.max(0, count - 1);
  let tries = 0;

  while(pack.enemies.length < (normalCount + 1) && tries < count * 8){
    tries++;
    let angle = Math.random()*Math.PI*2;
    let radius = Math.random()*140;
    let ex = cx + Math.cos(angle)*radius;
    let ey = cy + Math.sin(angle)*radius;
    spawnEnemyAt(ex, ey, pack);
  }

  packs.push(pack);
}

/* ===== ê¶ê·¹ê¸° ===== */
function teleportTo(target){
  spawnHitBlood(player.x, player.y, 18);
  if(particles.length < 220){
    for(let i=0;i<10;i++){
      particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 22 });
    }
  }

  if(canMoveTo(target.x, target.y)){
    player.x = target.x;
    player.y = target.y;
  }

  spawnHitBlood(player.x, player.y, 22);
  if(particles.length < 220){
    for(let i=0;i<12;i++){
      particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 26 });
    }
  }

  shake = Math.max(shake, 10);
}

/* ===== ë³´ìŠ¤ ìŠ¤í‚¬ ===== */
function bossEnterPhase2(boss){
  boss.swordPulled = true;
  boss.phase2Used = true;
  boss.speed *= 1.25;
  boss.damage *= 1.2;

  boss.invul = 120;
  boss.phaseLock = 36;

  shake = 30;
  bossUnsheatheSound();

  for(let i=0;i<80;i++){
    particles.push({ x: boss.x, y: boss.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 50 });
  }
}

function bossDash(boss){
  const dx = player.x - boss.x;
  const dy = player.y - boss.y;
  const dist = Math.hypot(dx, dy) || 1;
  const nx = dx / dist;
  const ny = dy / dist;

  const dashDist = 220;
  const steps = 18;
  let hit = false;

  for(let i=0;i<steps;i++){
    let px = boss.x + nx * (dashDist/steps);
    let py = boss.y + ny * (dashDist/steps);

    if(canEnemyMoveTo(boss, px, py)){
      boss.x = px; boss.y = py;
    }else break;

    if(!hit){
      const d = Math.hypot(player.x - boss.x, player.y - boss.y);
      if(d < boss.radius + player.radius + 10){
        damagePlayer(boss.damage*1.2, nx*34, ny*34, boss);
        hit = true;
      }
    }
  }
  shake = Math.max(shake, 16);
}

function bossCleave(boss){
  const radius = 140;

  for(let i=0;i<70;i++){
    const a = Math.random()*Math.PI*2;
    const r = Math.random()*radius;
    particles.push({
      x: boss.x + Math.cos(a)*r,
      y: boss.y + Math.sin(a)*r,
      vx: Math.cos(a)*2 + (Math.random()-0.5)*2,
      vy: Math.sin(a)*2 + (Math.random()-0.5)*2,
      life: 35
    });
  }

  const dist = Math.hypot(player.x - boss.x, player.y - boss.y);
  if(dist < radius){
    const dx = player.x - boss.x;
    const dy = player.y - boss.y;
    const len = Math.hypot(dx, dy) || 1;
    damagePlayer(boss.damage*1.6, (dx/len)*42, (dy/len)*42, boss);
  }
  shake = Math.max(shake, 22);
}

function isEnemyOnScreen(e){
  const camX = player.x - canvas.width/2;
  const camY = player.y - canvas.height/2;

  const screenLeft   = camX - 50;
  const screenRight  = camX + canvas.width + 50;
  const screenTop    = camY - 50;
  const screenBottom = camY + canvas.height + 50;

  return (
    e.x > screenLeft &&
    e.x < screenRight &&
    e.y > screenTop &&
    e.y < screenBottom
  );
}

/* ===== ì—…ë°ì´íŠ¸ ===== */

/* ===== GAME LOOP: UPDATE ===== */

function update(){
  frameCount++;

  if(lootOverlayOpen) return;
  if(gameOver) return;

  if(slowMotion > 0){
    slowMotion--;
    updateEnemySystem();
    resolvePlayerEnemyOverlap();
    updateEffectSystem();
    return;
  }

  updateBuffs(player);
  updatePlayerState();
  updateUltimateSystem();
  updateEnemySystem();
  resolvePlayerEnemyOverlap();
  updateCombatSystem();
  updateProjectileSystem();
  updateEffectSystem();
  updateEnvironmentSystem();

  updatePortal();
}

function updatePlayerState(){
  if(player.hp <= 0){ handleGameOver(); return; }
  updateMovement();
  updateInvulnerability();
  updateLevelGlow();

  const regen = (player.buffs?.hpRegen ?? 0) / 60;
  if(regen > 0) player.hp = Math.min(player.maxHp, player.hp + regen);
}
function handleGameOver(){
  gameOver = true;
  document.getElementById("ui").style.display = "none";
}
function updateLevelGlow(){
  if(player.levelGlow > 0) player.levelGlow--;
}

function updateUltimateSystem(){
  if(!player.ultiActive) return;

  player.ultiTimer++;
  if(player.ultiTimer % 10 === 0) performUltimateStrike();
  if(player.ultiCount >= 5) endUltimate();
}
function endUltimate(){
  player.ultiActive = false;
  player.ultiTimer = 0;
  player.ultiCount = 0;
  explosionActive = false;
}
function performUltimateStrike(){
  const target = getRandomVisibleAliveEnemy();
  if(!target) { endUltimate(); return; }

  teleportTo(target);
  dealUltimateDamage();

  pruneDeadEnemies();
  player.ultiCount++;
}

function dealUltimateDamage(){
  const radius = getUltiAoeRadius();
  const r2 = radius * radius;
  let killedAny = false;

  for(let i=0; i<enemies.length; i++){
    const e = enemies[i];
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    if(dx*dx + dy*dy > r2) continue;

    if(e.type === "boss" && e.dead) continue;

    const wasAlive = (e.hp > 0);
    if(!wasAlive) continue;

    const weaponBase = rollWeaponDamage();
const base =
  weaponBase * 2.8 *
  (player.buffs?.dmgMul ?? 1);

// âœ… POEì‹ ë²„ì¼“: outgoing(add/inc/more) â†’ crit â†’ enemy_taken
const ctxUlti = buildCombatCtx("ultimate", e);
const ultiRes = computeFinalDamage(base, ctxUlti, { canCrit:true });
const dealt = ultiRes.dealt;
const crit = ultiRes.crit;

    if(e.type === "boss"){
      if(e.invul <= 0){
        e.hp -= dealt;
        e.stun = 25;
        spawnHitBlood(e.x, e.y, crit.isCrit ? 26 : 14);
        shake = Math.max(shake, 20);
        if(e.hp <= 0){
          startBossDeath(e);
        }
      }
      continue;
    }

    e.hp -= dealt;
    e.stun = 30;

    spawnHitBlood(e.x, e.y, crit.isCrit ? 22 : 12);

    if(particles.length < 240){
      for(let k=0;k<10;k++){
        particles.push({ x: e.x, y: e.y, vx: (Math.random()-0.5)*9, vy: (Math.random()-0.5)*9, life: 34 });
      }
    }

    if(e.hp <= 0){
      emitEvent("kill", { enemy:e, x:e.x, y:e.y, type:e.type });
      spawnLoot(e.x, e.y, "ulti");
      giveXP(e);

      player.hp = Math.min(player.maxHp, player.hp + 1);
      slowMotion = 6;
      if(player.kiOrbs < player.maxOrbs) player.kiOrbs++;
      killedAny = true;
    }
  }

  if(killedAny) hitSound();
  shake = Math.max(shake, 30);
  pruneDeadEnemies();
}

function updateEnemySystem(){
  packs.forEach(pack=>{
    if(pack.activated) return;
    const dx = pack.x - player.x;
    const dy = pack.y - player.y;
    if(dx*dx + dy*dy < 520*520){
      activatePackGroup(pack.groupId);
      shake = Math.max(shake, 8);
      slowMotion = Math.max(slowMotion, 1);
    }
  });

  enemies.forEach(e=>{
    if(e.pack && !e.pack.activated) return;
    updateSingleEnemy(e);
  });
  for(const e of enemies){
    updateBuffs(e);
  }
  pruneDeadEnemies();
}

function updateLevelParticles(){
  for(let i = levelParticles.length - 1; i >= 0; i--){
    const p = levelParticles[i];
    p.ox += p.vx;
    p.oy -= p.vy;
    p.vy *= 0.97;
    p.life--;
    if(p.life <= 0) levelParticles.splice(i,1);
  }
  if(levelParticles.length > 200){
    levelParticles.splice(0, levelParticles.length - 200);
  }
}

function updateParticles(){
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }
  if(particles.length > 260){
    particles.splice(0, particles.length - 260);
  }
}

function updateMelee(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  if(dist > 0){
    let moveX = dx / dist * e.speed;
    let moveY = dy / dist * e.speed;

    let newX = e.x + moveX;
    let newY = e.y + moveY;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }

  enemyTryMeleeAttack(e);
}

function updateArcher(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  const desired = 240;
  if(dist < desired - 40){
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;

    const newX = e.x - nx * e.speed * 1.2;
    const newY = e.y - ny * e.speed * 1.2;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }else if(dist > desired + 80){
    updateMelee(e);
  }

  e.shootCooldown--;
  if(e.shootCooldown <= 0 && dist < 520){
    spawnArrow(e.x, e.y, player.x, player.y, e.damage);
    e.shootCooldown = 80 + Math.floor(Math.random()*40);
  }
}

function updateMage(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  if(dist < 180){
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;

    const newX = e.x - nx * e.speed * 1.4;
    const newY = e.y - ny * e.speed * 1.4;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }else{
    updateMelee(e);
  }

  e.castCooldown--;
  if(e.castCooldown <= 0 && dist < 520){
    spawnFireZone(player.x, player.y, e.damage);
    e.castCooldown = 140 + Math.floor(Math.random()*50);
  }
}

function updateBoss(e){
  if(!e.phase2Used && e.hp <= e.maxHp * 0.5) bossEnterPhase2(e);
  updateMelee(e);

  if(e.swordPulled){
    e.dashCooldown--;
    e.cleaveCooldown--;

    const dist = Math.hypot(player.x - e.x, player.y - e.y);

    if(e.dashCooldown <= 0 && dist > 160 && dist < 520){
      bossDash(e);
      e.dashCooldown = 160 + Math.floor(Math.random()*70);
    }
    if(e.cleaveCooldown <= 0 && dist < 220){
      bossCleave(e);
      e.cleaveCooldown = 200 + Math.floor(Math.random()*80);
    }
  }
}

function updateSingleEnemy(e){
  if(e.isLeader){
    const radius = 50;
    const r2 = radius * radius;

    for(const other of enemies){
      if(other === e) continue;
      const dx = other.x - e.x;
      const dy = other.y - e.y;
      if(dx*dx + dy*dy <= r2){
        applyBuff(other, "damage",   1.25, 15, "leader");
        applyBuff(other, "atkSpeed", 1.2,  15, "leader");
      }
    }
  }

  if(e.type === "boss" && e.dead){
    e.deathTimer--;

    if(e.deathTimer % 10 === 0){
      shake = Math.max(shake, 10);
      spawnHitBlood(
        e.x + (Math.random()-0.5)*12,
        e.y + (Math.random()-0.5)*12,
        10
      );
    }

    if(e.deathTimer === 1 && !mapRun.bossDefeated){
      mapRun.bossDefeated = true;
      spawnPortal(e.x, e.y);
    }

    return;
  }

  if(e.invul > 0) e.invul--;

  if(e.phaseLock > 0){
    e.phaseLock--;
    return;
  }

  if(e.stun > 0){
    e.stun--;
    return;
  }

  switch(e.type){
    case "archer": updateArcher(e); break;
    case "mage": updateMage(e); break;
    case "boss": updateBoss(e); break;
    default: updateMelee(e);
  }
}

function updateProjectileSystem(){
  updateArrows();
  updateFireZones();
}

function updateFireZones(){
  for(let i = fireZones.length - 1; i >= 0; i--){
    const f = fireZones[i];
    f.life--;
    f.tick++;

    if(f.tick % 10 === 0){

      if(f.isBleed){
        let hitCount = 0;

        for(const e of enemies){
          if(e.hp <= 0) continue;
          if(e.type === "boss" && e.dead) continue;

          const dx = e.x - f.x;
          const dy = e.y - f.y;
          if(dx*dx + dy*dy > f.radius*f.radius) continue;

          const ctxFz = buildCombatCtx("firezone", e);
          const fzRes = computeFinalDamage(f.damage, ctxFz, { canCrit:false });
          const dealt = fzRes.dealt;

          if(e.type === "boss"){
            if(e.invul <= 0 && !e.dead){
              e.hp -= dealt;
              if(e.hp <= 0) startBossDeath(e);
            }
          }else{
            e.hp -= dealt;
            if(e.hp <= 0){
              emitEvent("kill", { enemy:e, x:e.x, y:e.y, type:e.type });
              spawnLoot(e.x, e.y, "bleed");
              giveXP(e);
            }
          }

          player.hp = Math.min(player.maxHp, player.hp + dealt * 0.12);
          spawnHitBlood(e.x, e.y, 3);

          hitCount++;
          if(hitCount >= 10) break;
        }

        pruneDeadEnemies();

      }else{
        const dx = player.x - f.x;
        const dy = player.y - f.y;
        if(dx*dx + dy*dy < f.radius*f.radius){
          damagePlayer(f.damage, 0, 0, f);
        }
      }
    }

    if(f.life <= 0){
      fireZones.splice(i,1);
    }
  }
}

function updateEffectSystem(){
  updateParticles();
  updateBlood();
  updateLevelParticles();

  for(let i=bloodPools.length-1;i>=0;i--){
    bloodPools[i].life--;
    if(bloodPools[i].life <= 0) bloodPools.splice(i,1);
  }
  if(bloodPools.length > 120) bloodPools.splice(0, bloodPools.length-120);

  updateLoots();
}

function updateCombatSystem(){
  if(attacking){
    attackFrame++;
    if(attackFrame === 3) checkHit();
    if(attackFrame > 8){
      attacking = false;
      attackFrame = 0;
    }
  }
}

function updateMovement(){
  const moveSpeed = player.speed * (player.buffs?.spdMul ?? 1);
  let dx = 0;
  let dy = 0;

  if(keys["ArrowLeft"] || keys["a"]) dx -= moveSpeed;
  if(keys["ArrowRight"] || keys["d"]) dx += moveSpeed;
  if(keys["ArrowUp"] || keys["w"]) dy -= moveSpeed;
  if(keys["ArrowDown"] || keys["s"]) dy += moveSpeed;

  dx += joyDX * moveSpeed;
  dy += joyDY * moveSpeed;

  if(Math.abs(dx) > Math.abs(dy)){
    if(dx > 0) player.dir = "right";
    else if(dx < 0) player.dir = "left";
  }else{
    if(dy > 0) player.dir = "down";
    else if(dy < 0) player.dir = "up";
  }

  let newX = player.x + dx;
  let newY = player.y + dy;

  if(canMoveTo(newX, player.y)) player.x = newX;
  if(canMoveTo(player.x, newY)) player.y = newY;
}

function updateInvulnerability(){
  if(player.invul > 0) player.invul--;
}

function updateEnvironmentSystem(){ updateShake(); }
function updateShake(){ if(shake > 0) shake--; }

function updateArrows(){
  for(let i = arrows.length - 1; i >= 0; i--){
    const a = arrows[i];
    a.x += a.dx;
    a.y += a.dy;
    a.life--;

    const tx = Math.floor(a.x / tileSize);
    const ty = Math.floor(a.y / tileSize);
    if(!map[ty] || map[ty][tx] === 1){
      arrows.splice(i,1);
      continue;
    }

    const px = player.x, py = player.y;
    const dxp = a.x - px;
    const dyp = a.y - py;
    const rr = (player.radius + 4);
    if(dxp*dxp + dyp*dyp < rr*rr){
      const dx = px - a.x;
      const dy = py - a.y;
      const len = Math.hypot(dx, dy) || 1;
      damagePlayer(a.damage, (dx/len)*14, (dy/len)*14, a);
      arrows.splice(i,1);
      continue;
    }

    if(a.life <= 0){
      arrows.splice(i,1);
      continue;
    }
  }
}

/* ===== ë ˆë²¨ì—… ===== */
function levelUpSound(){
  let o = audioCtx.createOscillator();
  let g = audioCtx.createGain();

  o.type = "triangle";
  o.frequency.setValueAtTime(400, audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.3);

  g.gain.setValueAtTime(0.3, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

  o.connect(g);
  g.connect(audioCtx.destination);

  o.start();
  o.stop(audioCtx.currentTime + 0.3);
}

function checkLevelUp(){
  if(xp >= xpToNext){
    xp -= xpToNext;
    level++;

    xpToNext = Math.floor(100 + level * level * 20);

    player.baseMaxHp += 12;
    updateBuffs(player);
    player.hp = player.maxHp;

    baseDamageBase *= 1.08;
    ultiDamageBase *= 1.1;
    recalcFromGear();

    player.levelGlow = 60;

    for(let i=0;i<60;i++){
      levelParticles.push({
        ox:(Math.random()-0.5)*40,
        oy:-40+(Math.random()-0.5)*10,
        vx:(Math.random()-0.5)*2,
        vy:Math.random()*3+2,
        life:60
      });
    }

    levelUpSound();
  }
}

/* ===== ê³µê²© ë²”ìœ„ ===== */
const BASE_MELEE_RANGE = 40;
const BASE_ULTI_AOE    = 40;

function getMeleeRange(){
  const b = player.buffs || defaultBuffStats();
  return BASE_MELEE_RANGE * (b.rangeMul ?? 1);
}
function getUltiAoeRadius(){
  const b = player.buffs || defaultBuffStats();
  return BASE_ULTI_AOE * (b.rangeMul ?? 1);
}

/* ===== ê³µê²© ===== */
function checkHit(){
  const range = getMeleeRange();
  const hitLimit = 12;
  let hitDone = 0;

  for(let i=0;i<enemies.length;i++){
    const e = enemies[i];

    const dx = e.x - player.x;
    const dy = e.y - player.y;

    const r = range + e.radius;
    if(dx*dx + dy*dy > r*r) continue;

    if(player.dir === "up" && dy >= 0) continue;
    if(player.dir === "down" && dy <= 0) continue;
    if(player.dir === "right" && dx <= 0) continue;
    if(player.dir === "left" && dx >= 0) continue;

    hitDone++;
    if(hitDone > hitLimit) break;

    const len = Math.hypot(dx, dy) || 1;
    const nx = dx / len;
    const ny = dy / len;

    const weaponBase = rollWeaponDamage();
const base =
  weaponBase
  * (player.gear?.dmgMul ?? 1)
  * (player.buffs?.dmgMul ?? 1);

// âœ… POEì‹ ë²„ì¼“: outgoing(add/inc/more) â†’ crit â†’ enemy_taken
const ctxHit = buildCombatCtx("attack", e);
const hitRes = computeFinalDamage(base, ctxHit, { canCrit:true });
const dealt = hitRes.dealt;

    const bossInvul = (e.type === "boss" && e.invul > 0);

    if(e.invul <= 0){
      e.hp -= dealt;
    }
    emitEvent("hit", { enemy: e, dealt });

    const heal = dealt * 0.05;
    player.hp = Math.min(player.maxHp, player.hp + heal);

    if(Math.random() < 0.2 && player.kiOrbs < player.maxOrbs){
      player.kiOrbs++;
    }

    if(bossInvul){
      spawnHitBlood(e.x, e.y, 14);
    }else{
      e.stun = 15;
      let ex = e.x + nx*18;
      let ey = e.y + ny*18;
      if(canEnemyMoveTo(e, ex, e.y)) e.x = ex;
      if(canEnemyMoveTo(e, e.x, ey)) e.y = ey;
    }

    if(bossInvul) thudSound();
    else hitSound();

    shake = 12;

    if(particles.length < 220){
      particles.push({
        x: e.x, y: e.y,
        vx: nx*4 + (Math.random()-0.5)*4,
        vy: ny*4 + (Math.random()-0.5)*4,
        life: 30
      });
    }

    if(e.hp <= 0){
      if(e.type === "boss"){
        startBossDeath(e);
        continue;
      }
      emitEvent("kill", { enemy: e, x: e.x, y: e.y, type: e.type });
      spawnLoot(e.x, e.y, "normal");
      giveXP(e);
      killCount++;

      player.hp = Math.min(player.maxHp, player.hp + 1);

      if(bloodPools.length < 140){
        bloodPools.push({
          x: e.x, y: e.y,
          size: 10 + Math.random()*6,
          life: 600
        });
      }

      slowMotion = 6;

      if(player.kiOrbs < player.maxOrbs){
        player.kiOrbs++;
      }
    }
  }

  enemies = enemies.filter(e => (e.hp > 0) || (e.type === "boss" && e.dead && e.deathTimer > 0));
  packs.forEach(pack=>{
    pack.enemies = pack.enemies.filter(e=>e.hp>0);
  });
}

function updateBlood(){
  for(let i = bloodParticles.length - 1; i >= 0; i--){
    const p = bloodParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.25;
    p.life--;
    if(p.life <= 0) bloodParticles.splice(i,1);
  }
  if(bloodParticles.length > 260){
    bloodParticles.splice(0, bloodParticles.length - 260);
  }
}

function drawBlood(){
  if(bloodParticles.length === 0) return;

  ctx.save();
  ctx.fillStyle = "#8b0000";
  ctx.beginPath();

  for(let i=0;i<bloodParticles.length;i++){
    const p = bloodParticles[i];
    const a = p.life / 30;
    if(a > 0.66) ctx.globalAlpha = 0.9;
    else if(a > 0.33) ctx.globalAlpha = 0.6;
    else ctx.globalAlpha = 0.35;

    ctx.fillRect(p.x - p.size*0.5, p.y - p.size*0.5, p.size, p.size);
  }
  ctx.restore();
}

/* ===== ë Œë” ===== */
function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";
  ctx.filter = "none";

  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  let camX = player.x - canvas.width/2;
  let camY = player.y - canvas.height/2;

  let amp = shake ? (6 + shake * 0.45) : 0;
  let sx = shake ? (Math.random()-0.5) * amp : 0;
  let sy = shake ? (Math.random()-0.5) * amp : 0;

  ctx.save();
  ctx.translate(-camX+sx, -camY+sy);

  for(let y = 0; y < map.length; y++){
    for(let x = 0; x < map[y].length; x++){
      let tile = map[y][x];
      if(tile === 0) ctx.fillStyle = "#222";
      if(tile === 1) ctx.fillStyle = "#555";
      ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
    }
  }

  ctx.fillStyle = "#550000";
  for(let i=0;i<bloodPools.length;i++){
    const b = bloodPools[i];
    const a = b.life / 600;
    if(a <= 0.05) continue;
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  fireZones.forEach(f=>{
    ctx.save();
    for(let i=0;i<6;i++){
      let flameHeight = 10 + Math.sin(frameCount*0.2 + i)*6;
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "orange";
      ctx.beginPath();
      ctx.moveTo(f.x - 6 + i*2, f.y);
      ctx.lineTo(f.x - 3 + i*2, f.y - flameHeight);
      ctx.lineTo(f.x + i*2, f.y);
      ctx.fill();
    }
    ctx.restore();
  });

  ctx.fillStyle = "red";
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    ctx.fillRect(p.x, p.y, 3, 3);
  }

  drawPortal();
  drawLoots();
  drawBlood();
  enemies.forEach(e=>drawEnemy(e));

  levelParticles.forEach(p=>{
    ctx.fillStyle = "gold";
    ctx.fillRect(player.x + p.ox, player.y + p.oy, 4, 4);
  });

  arrows.forEach(a=>{
    ctx.fillStyle = "white";
    ctx.fillRect(a.x-2, a.y-2, 4, 4);
  });

  ctx.restore();

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  drawPlayer(canvas.width/2, canvas.height/2);
  drawUI();
}

function drawPlayer(x,y){
  if(player.levelGlow > 0){
    ctx.shadowColor = "gold";
    ctx.shadowBlur = player.levelGlow * 0.5;
  }

  ctx.fillStyle="#880000";
  ctx.fillRect(x-10,y-12,20,22);

  ctx.fillStyle="#aa0000";
  ctx.fillRect(x-7,y-20,14,8);

  ctx.fillStyle="#ffffcc";
  ctx.fillRect(x-8,y-26,4,8);
  ctx.fillRect(x+4,y-26,4,8);

  ctx.fillStyle = "#fff";
  ctx.fillRect(x-3,y-14,2,2);
  ctx.fillRect(x+1,y-14,2,2);

  ctx.shadowBlur = 0;

  if(player.ultiActive){
    ctx.save();
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 25;
    ctx.fillStyle = "#ffaa00";
    ctx.fillRect(x-3,y-14,2,2);
    ctx.fillRect(x+1,y-14,2,2);
    ctx.restore();
  }

  drawSword(x,y);
}

function drawSword(x, y){
  ctx.save();
  ctx.translate(x, y);

  var offsetX = 0;
  var offsetY = 0;
  var angle = 0;
  var t = attackFrame / 8;

  if (player.dir === "right") { offsetX = 18; if (attacking) angle = 1.5 * t; }
  else if (player.dir === "left") { offsetX = -18; if (attacking) angle = -1.5 * t; }
  else if (player.dir === "up") { offsetY = -18; if (attacking) offsetY -= 25 * t; }
  else if (player.dir === "down") { offsetY = 6; angle = Math.PI; if (attacking) offsetY += 25 * t; }

  ctx.translate(offsetX, offsetY);
  ctx.rotate(angle);
  drawSwordShape(ctx);
  ctx.restore();
}

function drawSwordShape(c){
  c.fillStyle = "#552200";
  c.fillRect(-2, 6, 4, 8);

  c.fillStyle = "#bbbbbb";
  c.fillRect(-8, 6, 16, 3);

  c.fillStyle = "#dddddd";
  c.fillRect(-2, -20, 4, 26);

  c.beginPath();
  c.moveTo(-2, -20);
  c.lineTo(0, -32);
  c.lineTo(2, -20);
  c.fill();
}

function drawEnemy(e){
  if(e.type === "boss"){
    if(e.dead){
      const t = (e.deathTimer / e.deathMax);
      ctx.save();
      ctx.globalAlpha = Math.max(0, t);

      ctx.fillStyle = "rgba(255,60,60,0.25)";
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius + (1-t)*35, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#777777";
      ctx.fillRect(e.x-20, e.y-25, 40, 50);

      if(Math.floor(frameCount/3)%2===0){
        ctx.fillStyle = "rgba(255,0,0,0.8)";
        ctx.fillRect(e.x-6, e.y-15, 4,4);
        ctx.fillRect(e.x+2, e.y-15, 4,4);
      }

      ctx.restore();
      return;
    }

    if(e.invul > 0){
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius + 10, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    ctx.fillStyle = "#777777";
    ctx.fillRect(e.x-20, e.y-25, 40, 50);

    ctx.fillStyle = "#999999";
    ctx.fillRect(e.x-15, e.y-35, 30, 15);

    ctx.fillStyle = "red";
    ctx.fillRect(e.x-6, e.y-15, 4,4);
    ctx.fillRect(e.x+2, e.y-15, 4,4);

    ctx.save();
    ctx.translate(e.x+28, e.y);
    ctx.rotate(0.2);
    drawSwordShape(ctx);
    ctx.restore();
    return;
  }

  if(e.isLeader){
    ctx.fillStyle = "#ffd000";
    ctx.fillRect(e.x-6, e.y-24, 12, 3);
    ctx.fillRect(e.x-4, e.y-28, 3, 4);
    ctx.fillRect(e.x+1, e.y-28, 3, 4);
  }
  if(e.isElite){
    ctx.fillStyle = (e.eliteColor === "yellow") ? "#ffcc00" : "#00aaff";
  }else if(e.type === "archer"){
    ctx.fillStyle = "#cccccc";
  }else if(e.type === "mage"){
    ctx.fillStyle = "#550088";
  }else{
    ctx.fillStyle = "#006600";
  }

  if(e.activeBuffs && e.activeBuffs.some(b => b.key === "damage|leader|mul" || b.key === "atkSpeed|leader|mul")){
    const pulse = 0.45 + 0.25*Math.sin(frameCount*0.2);
    ctx.save();
    ctx.globalAlpha = 0.25 + pulse;
    ctx.fillStyle = "rgba(255,0,0,0.35)";
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius + 12 + pulse*6, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  ctx.fillRect(e.x-10,e.y-12,20,22);

  if(e.type === "archer") ctx.fillStyle = "#dddddd";
  else if(e.type === "mage") ctx.fillStyle = "#550088";
  else ctx.fillStyle = "#00aa00";
  ctx.fillRect(e.x-7,e.y-20,14,8);

  ctx.fillStyle="red";
  ctx.fillRect(e.x-4,e.y-14,3,3);
  ctx.fillRect(e.x+1,e.y-14,3,3);
}

/* ===== UI ===== */
function drawUI(){
  drawTextUI();
  drawXPBar();
  drawOrbUI();
  drawHpOrb();
  drawBossHpBar();
  drawMiniMap();

  // (ë””ë²„ê·¸) ì¸ë²¤ ì¼ë¶€ í‘œì‹œ
  ctx.font = "12px Arial";
  ctx.fillStyle = "#ccc";
  let startY = 140;
  for(let i=0;i<inventory.length && i<8;i++){
    ctx.fillText("â€¢ " + inventory[i].name, 20, startY + i*16);
  }
}

function drawXPBar(){
  const barW = canvas.width * 0.6;
  const barH = 10;
  const x = canvas.width/2 - barW/2;
  const y = canvas.height - 20;
  const percent = xp / xpToNext;

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(x, y, barW, barH);
  ctx.fillStyle = "#33ccff";
  ctx.fillRect(x, y, barW * percent, barH);
  ctx.strokeStyle = "rgba(255,255,255,0.3)";
  ctx.strokeRect(x, y, barW, barH);
  ctx.restore();
}

function drawMiniMap(){
  const w = 60;
  const h = 60;
  const margin = 12;
  const x0 = canvas.width - w - margin;
  const y0 = margin;

  const radarRange = 700;
  const scale = w / (radarRange * 2);

  const cx = x0 + w/2;
  const cy = y0 + h/2;

  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = "#000";
  ctx.fillRect(x0, y0, w, h);

  ctx.beginPath();
  ctx.rect(x0+1, y0+1, w-2, h-2);
  ctx.clip();

  ctx.globalAlpha = 0.7;
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 1;

  const minTX = Math.max(0, Math.floor((player.x - radarRange) / tileSize));
  const maxTX = Math.min(mapSize-1, Math.floor((player.x + radarRange) / tileSize));
  const minTY = Math.max(0, Math.floor((player.y - radarRange) / tileSize));
  const maxTY = Math.min(mapSize-1, Math.floor((player.y + radarRange) / tileSize));

  for(let ty=minTY; ty<=maxTY; ty++){
    for(let tx=minTX; tx<=maxTX; tx++){
      if(map[ty][tx] !== 1) continue;
      const wx = tx * tileSize;
      const wy = ty * tileSize;
      const dx = wx - player.x;
      const dy = wy - player.y;
      const mx = cx + dx * scale;
      const my = cy + dy * scale;
      const size = tileSize * scale;
      ctx.strokeRect(mx, my, size, size);
    }
  }

  const boss = enemies.find(e => e.type === "boss");
  if(boss){
    const dx = boss.x - player.x;
    const dy = boss.y - player.y;
    if(dx*dx + dy*dy <= radarRange*radarRange){
      const mx = cx + dx * scale;
      const my = cy + dy * scale;
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.fillRect(mx-3, my-3, 6, 6);
    }
  }

  ctx.globalAlpha = 0.95;
  for(const e of enemies){
    if(e.hp <= 0) continue;
    if(e.type === "boss") continue;
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    if(dx*dx + dy*dy > radarRange*radarRange) continue;
    const mx = cx + dx * scale;
    const my = cy + dy * scale;
    if(e.type === "mage") ctx.fillStyle = "#aa55ff";
    else if(e.type === "archer") ctx.fillStyle = "#dddddd";
    else ctx.fillStyle = "#00ff66";
    ctx.fillRect(mx-1.5, my-1.5, 3, 3);
  }

  ctx.globalAlpha = 1;
  ctx.fillStyle = "#ff4444";
  ctx.fillRect(cx-2, cy-2, 4, 4);

  ctx.restore();

  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "#444";
  ctx.lineWidth = 2;
  ctx.strokeRect(x0+1, y0+1, w-2, h-2);
  ctx.restore();
}

function drawTextUI(){
  ctx.save();
  ctx.textAlign = "left";
  ctx.font = "bold 18px Arial";
  ctx.fillStyle = "white";
  ctx.strokeStyle = "black";
  ctx.lineWidth = 4;

  ctx.strokeText("Level: " + level, 20, 55);
  ctx.fillText("Level: " + level, 20, 55);

  ctx.strokeText("TIER: " + mapTier, 20, 105);
  ctx.fillText("TIER: " + mapTier, 20, 105);

  if(portal.active){
    ctx.strokeText("PORTAL OPEN!", 20, 155);
    ctx.fillText("PORTAL OPEN!", 20, 155);
  }

  ctx.restore();
}

function drawOrbUI(){
  const btnRect = document.getElementById("attackBtn").getBoundingClientRect();
  const centerScreenX = btnRect.left + btnRect.width * 0.5;
  const centerScreenY = btnRect.top  + btnRect.height * 0.5;

  let cx = centerScreenX;
  let cy = centerScreenY - uiHeight;

  cx = Math.max(60, Math.min(canvas.width - 60, cx));
  cy = Math.max(60, Math.min(canvas.height - 60, cy));

  const orbR = 10;
  const ringR = 34;
  const startAngle = -Math.PI/2;

  const centerR = 24;
  const ready = (player.kiOrbs >= 1 && enemies.length > 0 && !player.ultiActive);

  orbUIState.cx = cx;
  orbUIState.cy = cy;
  orbUIState.centerR = centerR;
  orbUIState.ready = ready;

  ctx.save();

  for(let i=0;i<player.maxOrbs;i++){
    const a = startAngle + (i * (Math.PI * 2 / player.maxOrbs));
    const x = cx + Math.cos(a) * ringR;
    const y = cy + Math.sin(a) * ringR;

    ctx.beginPath();
    ctx.arc(x, y, orbR, 0, Math.PI*2);

    if(orbFlash > 0){
      ctx.fillStyle = "#00ff88";
      ctx.shadowColor = "#00ff88";
      ctx.shadowBlur = 35;
    }
    else if(i < player.kiOrbs){
      ctx.fillStyle = "#00ff55";
      ctx.shadowColor = "#00ff55";
      ctx.shadowBlur = 15;
    }
    else{
      ctx.fillStyle = "#002211";
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
    }

    ctx.fill();
  }

  ctx.shadowBlur = ready ? 25 : 10;
  ctx.shadowColor = ready ? "rgba(120,180,255,0.95)" : "rgba(120,180,255,0.4)";
  ctx.fillStyle = ready ? "rgba(40,120,255,0.95)" : "rgba(40,120,255,0.45)";
  ctx.beginPath();
  ctx.arc(cx, cy, centerR, 0, Math.PI*2);
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(170,210,255,0.75)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(cx, cy, centerR+1, 0, Math.PI*2);
  ctx.stroke();

  ctx.globalAlpha = 0.95;
  ctx.fillStyle = "white";
  ctx.font = "bold 18px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("U", cx, cy+1);

  ctx.restore();
}

function drawHpOrb(){
  const uiH = ui.getBoundingClientRect().height || 120;
  const padRect = document.getElementById("movePad").getBoundingClientRect();
  let x = padRect.left + padRect.width * 0.5;

  const btnRect = document.getElementById("attackBtn").getBoundingClientRect();
  let y = (btnRect.top + btnRect.height * 0.5) - uiH;

  x = Math.max(40, Math.min(canvas.width - 40, x));
  y = Math.max(40, Math.min(canvas.height - 40, y));

  ctx.save();

  let radius = 25;
  hpWaveOffset += 0.07;

  let hpPercent = player.hp / player.maxHp;
  let liquidHeight = radius * 2 * hpPercent;
  let topY = y + radius - liquidHeight;

  let metal = ctx.createRadialGradient(x, y, radius-10, x, y, radius+12);
  metal.addColorStop(0, "#2a0000");
  metal.addColorStop(0.5, "#550000");
  metal.addColorStop(1, "#110000");

  ctx.beginPath();
  ctx.arc(x, y, radius+10, 0, Math.PI*2);
  ctx.fillStyle = metal;
  ctx.fill();

  ctx.lineWidth = 4;
  ctx.strokeStyle = "#000";
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(x, y, radius+6, 0, Math.PI*2);
  ctx.strokeStyle = "#aa0000";
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.save();
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI*2);
  ctx.clip();

  let innerShadow = ctx.createRadialGradient(x, y+15, 10, x, y, radius);
  innerShadow.addColorStop(0, "#330000");
  innerShadow.addColorStop(1, "#000000");
  ctx.fillStyle = innerShadow;
  ctx.fillRect(x-radius, y-radius, radius*2, radius*2);

  ctx.beginPath();
  ctx.moveTo(x-radius, y+radius);
  for(let i=0;i<=radius*2;i++){
    let wave = Math.sin(i*0.12 + hpWaveOffset) * 4;
    ctx.lineTo(x-radius+i, topY + wave);
  }
  ctx.lineTo(x+radius, y+radius);
  ctx.closePath();

  let blood = ctx.createLinearGradient(0, topY, 0, y+radius);
  blood.addColorStop(0, "#ff2a2a");
  blood.addColorStop(1, "#8b0000");
  ctx.fillStyle = blood;
  ctx.fill();

  ctx.beginPath();
  ctx.arc(x-15, y-20, 18, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.25)";
  ctx.fill();

  let glass = ctx.createRadialGradient(x-10, y-15, 5, x, y, radius);
  glass.addColorStop(0, "rgba(255,255,255,0.25)");
  glass.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = glass;
  ctx.fillRect(x-radius, y-radius, radius*2, radius*2);

  if(hpPercent < 0.3){
    if(Math.floor(Date.now()/200)%2===0){
      ctx.beginPath();
      ctx.arc(x, y, radius+14, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,0,0,0.25)";
      ctx.fill();
    }
  }

  ctx.fillStyle = "white";
  ctx.font = "bold 16px Arial";
  ctx.textAlign = "center";
  ctx.fillText(Math.floor(player.hp), x, y+6);

  ctx.restore();
  ctx.restore();
}

function drawBossHpBar(){
  const boss = enemies.find(e => e.type === "boss");
  if(!boss) return;

  let camX = player.x - canvas.width/2;
  let camY = player.y - canvas.height/2;

  const screenX = boss.x - camX;
  const screenY = boss.y - camY;

  if(screenX < -100 || screenX > canvas.width + 100 || screenY < -100 || screenY > canvas.height + 100) return;

  const barW = 70;
  const barH = 7;
  const x = screenX - barW/2;
  const y = screenY - boss.radius - 18;

  let percent = boss.hp / boss.maxHp;
  percent = Math.max(0, Math.min(1, percent));

  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x, y, barW, barH);
  ctx.fillStyle = "#ff4444";
  ctx.fillRect(x, y, barW * percent, barH);
  ctx.globalAlpha = 0.85;
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, barW - 1, barH - 1);
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "10px Arial";
  ctx.textAlign = "center";
  ctx.fillText(Math.ceil(boss.hp), screenX, y - 2);
  ctx.restore();
}

function drawGameOver(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle="rgba(0,0,0,0.6)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="white";
  ctx.font="bold 40px Arial";
  ctx.textAlign="center";
  ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);

  ctx.font="bold 18px Arial";
  ctx.fillText("Tap to Restart", canvas.width/2, canvas.height/2 + 40);
}

function tryUltimate(){
  if(player.ultiActive) return;
  if(player.kiOrbs >= 1 && enemies.length > 0){
    player.kiOrbs -= 1;
    player.ultiActive = true;
    player.ultiTimer = 0;
    player.ultiCount = 0;
    performUltimateStrike();
    endUltimate();
  }
}

function handleUltimateOrbPress(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const tx = clientX - rect.left;
  const ty = clientY - rect.top;

  const dx = tx - orbUIState.cx;
  const dy = ty - orbUIState.cy;
  const r = orbUIState.centerR;

  if(dx*dx + dy*dy <= r*r){
    tryUltimate();
    return true;
  }
  return false;
}


/* ============================= */
/* âœ… ì¥ë¹„/ê°€ë°©/ì¹´ì˜¤ìŠ¤ ë¶„ë¦¬ UI ë¡œì§ */
/* ============================= */
// (ì´ë¯¸ ìœ„ì—ì„œ EQUIP_SLOTS/equipment/inventory/chaosOrbs ì„ ì–¸ë¨)

// UI refs
const equipOverlay = document.getElementById("equipOverlay");
const bagOverlay   = document.getElementById("bagOverlay");
const craftOverlay = document.getElementById("craftOverlay");

const equipSlotsEl = document.getElementById("equipSlots");
const specTextEl   = document.getElementById("specText");
const equipInfoEl  = document.getElementById("equipInfo");

const bagGridEl    = document.getElementById("bagGrid");
const bagInfoEl    = document.getElementById("bagInfo");

const orbCountsEl = document.getElementById("orbCounts");
const craftItemTextEl = document.getElementById("craftItemText");
const craftItemIconCv = document.getElementById("craftItemIcon");
const orbDescEl = document.getElementById("orbDesc");

const btnTransmute = document.getElementById("orbTransmute");
const btnAlter     = document.getElementById("orbAlter");
const btnAug       = document.getElementById("orbAug");
const btnRegal     = document.getElementById("orbRegal");
const btnAlchemy   = document.getElementById("orbAlchemy");
const btnChaos     = document.getElementById("chaosBtn");
const btnScour     = document.getElementById("orbScour");
const btnExalt     = document.getElementById("orbExalt");
const btnAnnul     = document.getElementById("orbAnnul");
const btnDivine    = document.getElementById("orbDivine");
const btnCorrupt = document.getElementById("orbCorrupt");

const ORB_DESC = {
  transmute: "ì§„í™”(Transmute): ë…¸ë§ â†’ ë§¤ì§ (ì˜µì…˜ 1~2ê°œ)",
  alteration: "ë³€í™”(Alteration): ë§¤ì§ ì¬êµ´ë¦¼ (ì˜µì…˜ 1~2ê°œ)",
  augmentation: "í™•ì¥(Augmentation): ë§¤ì§ì´ 1ê°œì¼ ë•Œë§Œ 1ê°œ ì¶”ê°€ (2ê°œë©´ ë¶ˆê°€)",
  regal: "ì œì™•(Regal): ë§¤ì§ â†’ ë ˆì–´ + 1ê°œ ì¶”ê°€",
  alchemy: "ì—°ê¸ˆ(Alchemy): ë…¸ë§ â†’ ë ˆì–´ (ì˜µì…˜ 4~6ê°œ)",
  chaos: "ì¹´ì˜¤ìŠ¤(Chaos): ë ˆì–´ ì¬êµ´ë¦¼ (ì˜µì…˜ 4~6ê°œ)",
  scour: "ì •ì œ(Scour): ë§¤ì§/ë ˆì–´ â†’ ë…¸ë§ (ì˜µì…˜ 0ê°œ)",
  exalt: "ì—‘ì˜(Exalt): ë ˆì–´ì— 1ê°œ ì¶”ê°€ (ë¹ˆ ì ‘ë‘/ì ‘ë¯¸ ìŠ¬ë¡¯ ìˆì„ ë•Œë§Œ)",
  annul: "ì†Œë©¸(Annul): ëœë¤ 1ê°œ ì œê±° (í¬ê·€ë„ ìœ ì§€)",
  divine: "ì‹ ì„±(Divine): ê°’ë§Œ ì¬êµ´ë¦¼ (ì˜µì…˜ ì¢…ë¥˜/ê°œìˆ˜ ìœ ì§€)",
  corrupt: "+íƒ€ë½: ê¸°ì¡´ ì„í”Œë¦¿ ì œê±° í›„ (1) ì„í”Œë¦¿ 1ê°œ ì¶”ê°€ / (2) ë³€í™” ì—†ìŒ / (3) ì•„ì´í…œ íŒŒê´´"
};
// ì˜¤ë¸Œ ì„¤ëª… ë°”ì¸ë”©
function bindOrbDesc(btn, key){
  if(!btn) return;
  btn.addEventListener("mouseenter", ()=>{ if(orbDescEl) orbDescEl.textContent = ORB_DESC[key]||""; });
  btn.addEventListener("click", ()=>{ if(orbDescEl) orbDescEl.textContent = ORB_DESC[key]||""; });
}
bindOrbDesc(btnTransmute,"transmute");
bindOrbDesc(btnAlter,"alteration");
bindOrbDesc(btnAug,"augmentation");
bindOrbDesc(btnRegal,"regal");
bindOrbDesc(btnAlchemy,"alchemy");
bindOrbDesc(btnChaos,"chaos");
bindOrbDesc(btnScour,"scour");
bindOrbDesc(btnExalt,"exalt");
bindOrbDesc(btnAnnul,"annul");
bindOrbDesc(btnDivine,"divine");
bindOrbDesc(btnCorrupt,"corrupt");
let panelOpen = null; // "equip" | "bag" | "craft" | null

// ì„ íƒ: ê°€ë°©/ì¥ë¹„ ê³µìš©
let selectedItem = null; // {from:"bag", idx} | {from:"equip", slot}

function stopEvt(e){
  if(!e) return;
  if(e.preventDefault) e.preventDefault();
  if(e.stopPropagation) e.stopPropagation();
}

function slotLabel(slot){
  if(slot==="weapon") return "ë¬´ê¸°";
  if(slot==="helm")   return "íˆ¬êµ¬";
  if(slot==="chest")  return "ê°‘ì˜·";
  if(slot==="ring")   return "ë°˜ì§€";
  return slot;
}
function rarityKey(it){
  if(!it) return "normal";
  const r = normalizeRarity(it.rarity);
  if(it.isUnique || r === "unique") return "unique";
  return r;
}

function rarityClass(it){
  return "r-" + rarityKey(it);
}
function escHtml(s){
  return String(s ?? "")
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#39;");
}
/* ===== í‘œì‹œìš© í¼ì„¼íŠ¸ ìœ í‹¸ ===== */
function fmtPct1(n){
  // 1ìë¦¬ê¹Œì§€ ë°˜ì˜¬ë¦¼, ë .0 ì œê±°
  const v = Math.round(n*10)/10;
  return String(v).replace(/\.0$/, "");
}
function fmtIncPctFromMul(m){
  const pct = (Number(m)||0) * 100 - 100; // mul(1.10) -> 10
  const abs = Math.abs(pct);
  const s = fmtPct1(abs);
  if(abs < 0.05) return "0% ì¦ê°€";
  return (pct >= 0) ? `${s}% ì¦ê°€` : `${s}% ê°ì†Œ`;
}
function fmtCritBonusFromMul(m){
  const pct = (Number(m)||0) * 100 - 100;
  const s = fmtPct1(pct);
  // ì¹˜í”¼ëŠ” POE ëŠë‚Œìœ¼ë¡œ +50% í‘œê¸°
  return (pct >= 0) ? `+${s}%` : `${s}%`;
}


function rarityKey(it){
  if(!it) return "normal";
  const r = normalizeRarity(it.rarity);
  if(it.isUnique || r === "unique") return "unique";
  return r;
}
function rarityClass(it){
  return "r-" + rarityKey(it);
}
function fmtPct(x, digits=1){
  // xê°€ 0.123ì´ë©´ 12.3%
  const p = x * 100;
  const v = Math.round(p * Math.pow(10, digits)) / Math.pow(10, digits);
  // 0.0 ê°™ì€ ê°’ì´ë©´ ì†Œìˆ˜ ì—†ì• ê¸°
  return (Math.abs(v - Math.round(v)) < 1e-9) ? String(Math.round(v)) : String(v);
}

function fmtNum(x, digits=2){
  const v = Math.round(x * Math.pow(10, digits)) / Math.pow(10, digits);
  return (Math.abs(v - Math.round(v)) < 1e-9) ? String(Math.round(v)) : String(v);
}


function formatAffixReadable(mod){
  if(!mod) return "";

  // modëŠ” (1) roll object {kind, affix, tier, value} ë˜ëŠ” (2) affix object ìì²´ì¼ ìˆ˜ ìˆìŒ
  const a = mod.affix || mod;
  const v = (typeof mod.value === "number") ? mod.value : a.value;

  const g = String(a.group || a.stat || a.id || "").toLowerCase();
  const name = a.name || a.id || "ì˜µì…˜";

  const num = (x)=> (typeof x==="number" && isFinite(x)) ? x : 0;
  const pct = (x)=>`${Math.round(num(x))}%`;
  const pct1 = (x)=>`${num(x).toFixed(1)}%`;

  // ===== í¼ì„¼íŠ¸/ìˆ˜ì¹˜ í‘œê¸° ê·œì¹™ =====
  // - í”¼í•´/ê³µì†/ë²”ìœ„/ì €í•­/ì¹˜í™•/ì¹˜í”¼ ë“±: %ë¡œ í‘œê¸°
  // - ìµœëŒ€ì²´ë ¥/ì¶”ê°€ë¬¼ë¦¬: ìˆ«ì
  // - ì¬ìƒ: /s

  // í”¼í•´(%) 
  if(g.includes("spell_damage")) return `ì£¼ë¬¸ í”¼í•´ +${pct(v)}`;
  if(g.includes("fire_damage")) return `í™”ì—¼ í”¼í•´ +${pct(v)}`;
  if(g.includes("cold_damage")) return `ëƒ‰ê¸° í”¼í•´ +${pct(v)}`;
  if(g.includes("light_damage")) return `ë²ˆê°œ í”¼í•´ +${pct(v)}`;
  if(g.includes("phys") && !g.includes("flat")) return `ë¬¼ë¦¬ í”¼í•´ +${pct(v)}`;

  // flat phys
  if(g.includes("phys_flat")) return `ì¶”ê°€ ë¬¼ë¦¬ í”¼í•´ +${Math.round(num(v))}`;

  // ì†ë„/ë²”ìœ„
  if(g.includes("attackspeed")) return `ê³µê²© ì†ë„ +${pct(v)}`;
  if(g === "range" || g.includes("melee_range")) return `ë²”ìœ„ +${pct(v)}`;

  // ì¹˜ëª…
  if(g.includes("critchance")) return `ì¹˜ëª…íƒ€ í™•ë¥  +${pct1(v)}`;
  if(g.includes("critmulti")) return `ì¹˜ëª…íƒ€ í”¼í•´ +${pct(v)}`;

  // ìƒì¡´
  if(g.includes("life_leech")) return `ìƒëª…ë ¥ í¡ìˆ˜ ${pct(v)}`;
  if(g.includes("life") || g.includes("maxhp")) return `ìµœëŒ€ ì²´ë ¥ +${Math.round(num(v))}`;
  if(g.includes("hpregen")) return `ì¬ìƒ +${num(v).toFixed(2)}/s`;

  // ë°©ì–´/ì´ì†
  if(g.includes("armor_pct")) return `ë°©ì–´ë„ +${pct(v)}`;
  if(g.includes("movespeed")) return `ì´ë™ ì†ë„ +${pct(v)}`;

  // ì €í•­
  if(g.includes("resist_all")) return `ëª¨ë“  ì €í•­ +${Math.round(num(v))}`;
  if(g.includes("resist_fire")) return `í™”ì—¼ ì €í•­ +${Math.round(num(v))}`;
  if(g.includes("resist_cold")) return `ëƒ‰ê¸° ì €í•­ +${Math.round(num(v))}`;
  if(g.includes("resist_light")) return `ë²ˆê°œ ì €í•­ +${Math.round(num(v))}`;

  // fallback: name + value
  if(typeof v === "number"){
    // ê°’ì´ 0~1 ì†Œìˆ˜ë©´ %ë¡œ í‘œì‹œí•´ë³´ê¸°(êµ¬í˜• ë°ì´í„° í˜¸í™˜)
    if(v > 0 && v < 1) return `${name} +${pct(v*100)}`;
    return `${name} +${Math.round(num(v))}`;
  }
  return `${name}`;
}


function rarityLabel(it){
  const r = normalizeRarity(it?.isUnique ? "unique" : (it?.rarity || "normal"));
  if(r==="unique") return "ìœ ë‹ˆí¬";
  if(r==="rare") return "ë ˆì–´";
  if(r==="magic") return "ë§¤ì§";
  return "ë…¸ë©€";
}

function prettyItemHTML(it){
  if(!it) return "";

  const rCls = rarityClass(it);
  let html = `<div class="itemInfoWrap">`;

  // 1) ì•„ì´í…œ ì´ë¦„(ë“±ê¸‰ ìƒ‰)
  html += `<div class="itemInfoName ${rCls}">${escHtml(it.name || "")}</div>`;

  // ìœ ë‹ˆí¬(ì „ì„¤)ëŠ” ì˜ˆì™¸ ì²˜ë¦¬: ì„¤ëª…ë§Œ ê¹”ë”íˆ
  if(it.isUnique){
    const desc = it.uniqueRef?.desc || it.desc || "";
    if(desc){
      html += `<div class="itemInfoLine itemInfoDim">${escHtml(desc)}</div>`;
    }
    html += `</div>`;
    return html;
  }

  // 2) ë² ì´ìŠ¤ + ilvl + ë² ì´ìŠ¤ í‹°ì–´
  const baseName = it.baseName || it.baseId || it.id || "";
  if(baseName){
    const bt = (typeof it.baseTier === "number") ? ` (í‹°ì–´ ${it.baseTier})` : "";
    html += `<div class="itemInfoLine itemInfoDim">ë² ì´ìŠ¤: ${escHtml(baseName)}${escHtml(bt)}</div>`;
  }
  if(typeof it.ilvl === "number"){
    html += `<div class="itemInfoLine itemInfoDim">ì•„ì´í…œ ë ˆë²¨: ${it.ilvl}</div>`;
  }

  // ë“±ê¸‰ í‘œê¸°
  html += `<div class="itemInfoLine itemInfoDim">ë“±ê¸‰: ${rarityLabel(it)}</div>`;

  // 3) ì•”ë¬µ ì˜µì…˜(Implicit) â€” ì ‘ë‘/ì ‘ë¯¸ì™€ ì™„ì „ ë¶„ë¦¬
  const imps = Array.isArray(it.implicits) ? it.implicits : [];
  if(imps.length){
    html += `<div class="itemInfoGap"></div>`;
    html += `<div class="itemInfoLine itemInfoDim">ì•”ë¬µ ì˜µì…˜</div>`;
    for(const imp of imps){
      if(!imp) continue;
      // textê°€ ìˆëŠ” ì•”ë¬µë§Œ ì¶œë ¥ (í—¬í¼ìš© Min/Max ì¡°ê° ë“±ì€ ìˆ¨ê¹€)
      if(!imp.text) continue;
      const line = imp.text;
      html += `<div class="itemInfoLine">- ${escHtml(line)}</div>`;
    }
  }

  // 4) ë² ì´ìŠ¤ ì˜µì…˜
  html += `<div class="itemInfoGap"></div>`;
  html += `<div class="itemInfoLine itemInfoDim">ë² ì´ìŠ¤ ì˜µì…˜</div>`;

  if(it.slot === "weapon" && typeof it.baseDamage === "number"){
    html += `<div class="itemInfoLine">- ê¸°ë³¸ ë¬´ê¸° í”¼í•´ +${Math.floor(it.baseDamage)}</div>`;
  }

  if(it.baseData){
    const d = it.baseData;
    if(d.maxHpAdd) html += `<div class="itemInfoLine">- ìµœëŒ€ ì²´ë ¥ +${Math.floor(d.maxHpAdd)}</div>`;
    if(d.armorAdd) html += `<div class="itemInfoLine">- ë°©ì–´ë ¥ +${Math.floor(d.armorAdd)}</div>`;
    if(d.hpRegen)  html += `<div class="itemInfoLine">- ì¬ìƒ +${d.hpRegen.toFixed(2)}/s</div>`;
  }

  // 4) ì ‘ë‘ / ì ‘ë¯¸ ì˜µì…˜ë§Œ í‘œì‹œ
  const aff = Array.isArray(it.affixes) ? it.affixes : [];
  const prefixes = aff.filter(a => a && a.affix && a.kind === "prefix");
  const suffixes = aff.filter(a => a && a.affix && a.kind === "suffix");

  if(prefixes.length){
    html += `<div class="itemInfoGap"></div>`;
    html += `<div class="itemInfoLine itemInfoDim">ì ‘ë‘</div>`;
    for(const a of prefixes){
      const tier = a.tier ? ` <span class="itemInfoTier">T${a.tier}</span>` : "";
      const line = formatAffixReadable(a);
      html += `<div class="itemInfoLine">- ${escHtml(line)}${tier}</div>`;
    }
  }

  if(suffixes.length){
    html += `<div class="itemInfoGap"></div>`;
    html += `<div class="itemInfoLine itemInfoDim">ì ‘ë¯¸</div>`;
    for(const a of suffixes){
      const tier = a.tier ? ` <span class="itemInfoTier">T${a.tier}</span>` : "";
      const line = formatAffixReadable(a);
      html += `<div class="itemInfoLine">- ${escHtml(line)}${tier}</div>`;
    }
  }

  html += `</div>`;
  return html;
}

function rebuildGearFromEquipment(){
  player.gear = {
    armorAdd: 0, maxHpAdd: 0, hpRegen: 0,
    critChanceAdd: 0, critChanceMul: 1, critMultiAdd: 0,
  };

  for(const slot of EQUIP_SLOTS){
    const it = equipment[slot];
    if(!it) continue;
    if(it.isUnique) continue;
    const d = it.totalData || it.data;
    if(!d) continue;
    for(const k in d){
      const v = d[k];
      if(typeof v !== "number") continue;
      if(k.endsWith("Mul")) player.gear[k] *= v;
      else player.gear[k] += v;
    }
  }
  recalcFromGear();
  player.hp = Math.min(player.hp, player.maxHp);
}

/* ===== ì•„ì´í…œ ì•„ì´ì½˜: ì´ëª¨ì§€ ëŒ€ì‹  ìº”ë²„ìŠ¤ì— ê°„ë‹¨ ë„í˜• ===== */
function drawItemIcon(c, it){
  const g = c.getContext("2d");
  const W = c.width, H = c.height;
  g.clearRect(0,0,W,H);

  // ë°”íƒ•(ì–´ë‘ìš´ ì¹¸ì—ì„œë„ ì•„ì´ì½˜ì´ "ë³´ì´ê²Œ" í•˜ì´ë¼ì´íŠ¸)
  g.save();
  g.globalAlpha = 1;
  g.fillStyle = "rgba(0,0,0,0.15)";
  g.fillRect(0,0,W,H);

  // í…Œë‘ë¦¬(í¬ê·€ë„) â€” PoEì‹: normal(í°) / magic(íŒŒ) / rare(ë…¸) / unique(ì£¼í™©)
  const rr = normalizeRarity(it?.isUnique ? "unique" : (it?.rarity || "normal"));
  g.lineWidth = 3;

  if(rr==="unique") g.strokeStyle = "#ffb86b";
  else if(rr==="rare") g.strokeStyle = "#ffd166";
  else if(rr==="magic") g.strokeStyle = "#2f7bff";
  else g.strokeStyle = "#ffffff";

  // âœ… ë™ê·¸ë¼ë¯¸ ë§ â†’ ì‚¬ê°í˜• ë§(ìš”ì²­ ë°˜ì˜)
  const pad = 4;
  g.strokeRect(pad, pad, W - pad*2, H - pad*2);

  // ìŠ¬ë¡¯ì´ ì—†ìœ¼ë©´ ë¹ˆì¹¸
  if(!it){ g.restore(); return; }

  // ê³µí†µ: ì•„ì´ì½˜ ì¤‘ì•™ ì •ë ¬
  g.translate(W/2, H/2);
  g.globalAlpha = 0.98;

  // ===== ë¬´ê¸°: ë² ì´ìŠ¤ íƒ€ì…ë³„ ì•„ì´ì½˜ =====
  if(it.slot==="weapon"){
    const baseId = it.baseId || it.id;
    const tmpl = getItemTemplateById(baseId);
    const wt = tmpl?.weaponType || tmpl?.type || (() => {
      const tags = tmpl?.tags || [];
      if(tags.includes("2h_axe") || tags.includes("axe")) return "2h_axe";
      if(tags.includes("2h_mace") || tags.includes("mace")) return "2h_mace";
      if(tags.includes("warstaff")) return "warstaff";
      if(tags.includes("staff")) return "staff";
      return "2h_sword";
    })();

    // ê³µí†µ ìŠ¤ì¼€ì¼
    g.save();
    g.scale(1.0, 1.0);
    g.lineWidth = 4;
    g.strokeStyle = "rgba(255,255,255,0.85)";
    g.fillStyle = "rgba(255,255,255,0.75)";

    // 2H Sword: ê¸°ì¡´ ëŠë‚Œ(ê¸¸ì­‰í•œ ê²€)
    if(wt==="2h_sword"){
      g.beginPath();
      g.moveTo(-2, -16); g.lineTo(2, -16); g.lineTo(3, 10); g.lineTo(-3, 10);
      g.closePath(); g.fill();
      g.fillRect(-10, 6, 20, 3);   // ê°€ë“œ
      g.fillRect(-2, 10, 4, 8);    // ì†ì¡ì´
    }
    // 2H Axe: í° ë„ë¼ë‚ 
    else if(wt==="2h_axe"){
      g.fillRect(-2, -16, 4, 30);  // ìë£¨
      g.beginPath();               // ë„ë¼ë‚ 
      g.moveTo(-2, -6);
      g.lineTo(-14, -12);
      g.lineTo(-14, 0);
      g.lineTo(-2, 2);
      g.closePath(); g.fill();
      g.beginPath();
      g.moveTo(2, -6);
      g.lineTo(8, -10);
      g.lineTo(8, 0);
      g.lineTo(2, 2);
      g.closePath(); g.fill();
      g.fillRect(-6, 8, 12, 3);    // ê°€ë“œ ëŠë‚Œ
    }
    // 2H Mace: í° ì² í‡´ë¨¸ë¦¬
    else if(wt==="2h_mace"){
      g.fillRect(-2, -16, 4, 30);  // ìë£¨
      g.fillRect(-8, -18, 16, 10); // ë¨¸ë¦¬
      // ìŠ¤íŒŒì´í¬
      g.fillRect(-10, -16, 4, 2);
      g.fillRect(6, -16, 4, 2);
      g.fillRect(-2, -22, 4, 4);
      g.fillRect(-2, -8, 4, 3);
    }
    // Staff: ë§ˆë²• ì§€íŒ¡ì´(ë êµ¬ìŠ¬)
    else if(wt==="staff"){
      g.fillRect(-2, -16, 4, 30);
      g.beginPath();
      g.arc(0, -18, 6, 0, Math.PI*2);
      g.fill();
      g.fillRect(-4, 8, 8, 3);
    }
    // Warstaff: ì „ìŸì§€íŒ¡ì´(ì–‘ë ê¸ˆì†)
    else if(wt==="warstaff"){
      g.fillRect(-2, -16, 4, 30);
      g.fillRect(-8, -20, 16, 5);
      g.fillRect(-8, 12, 16, 5);
      g.fillRect(-5, -24, 10, 4);
      g.fillRect(-5, 17, 10, 4);
    }
    else{
      // fallback
      g.fillRect(-2, -16, 4, 30);
      g.fillRect(-10, 6, 20, 3);
    }

    g.restore();
  }


  // ===== íˆ¬êµ¬: "ê²€íˆ¬ì‚¬ íˆ¬êµ¬" =====
  else if(it.slot==="helm"){
    g.save();
    // ë‘¥ê·¼ ë”
    g.fillStyle = "#c7c7c7";
    g.beginPath();
    g.arc(0, -2, 13, Math.PI, 0);
    g.closePath();
    g.fill();

    // ë³¼ê°€ë“œ/í„±ë¶€ë¶„
    g.fillStyle = "#9b9b9b";
    g.beginPath();
    g.moveTo(-13, -2);
    g.lineTo(-13, 8);
    g.quadraticCurveTo(-6, 14, 0, 14);
    g.quadraticCurveTo(6, 14, 13, 8);
    g.lineTo(13, -2);
    g.closePath();
    g.fill();

    // ëˆˆêµ¬ë©(ìŠ¬ë¦¿)
    g.fillStyle = "#1a1a1a";
    g.fillRect(-9, 1, 7, 3);
    g.fillRect(2, 1, 7, 3);

    // ì¤‘ì•™ ëŠ¥ì„ (ê²€íˆ¬ì‚¬ ëŠë‚Œ)
    g.fillStyle = "#eaeaea";
    g.fillRect(-1, -14, 2, 26);

    // í•˜ì´ë¼ì´íŠ¸
    g.globalAlpha = 0.25;
    g.fillStyle="#fff";
    g.beginPath();
    g.arc(-5, -6, 10, Math.PI*1.05, Math.PI*1.55);
    g.strokeStyle="rgba(255,255,255,0.4)";
    g.lineWidth=2;
    g.stroke();

    g.restore();
  }

  // ===== ê°‘ì˜·: "ì¤‘ì„¸ ê¸°ì‚¬ í’€í”Œë ˆì´íŠ¸" =====
  else if(it.slot==="chest"){
    g.save();
    // í‰ê°‘ ë³¸ì²´
    g.fillStyle="#bdbdbd";
    g.beginPath();
    g.moveTo(-12, -12);
    g.lineTo(-8, 14);
    g.quadraticCurveTo(0, 18, 8, 14);
    g.lineTo(12, -12);
    g.closePath();
    g.fill();

    // ì–´ê¹¨ í”Œë ˆì´íŠ¸
    g.fillStyle="#9e9e9e";
    g.beginPath();
    g.moveTo(-14, -10);
    g.lineTo(-8, -14);
    g.lineTo(-4, -2);
    g.lineTo(-12, 0);
    g.closePath();
    g.fill();

    g.beginPath();
    g.moveTo(14, -10);
    g.lineTo(8, -14);
    g.lineTo(4, -2);
    g.lineTo(12, 0);
    g.closePath();
    g.fill();

    // ë³µë¶€ íŒê¸ˆ ë¼ì¸
    g.strokeStyle="rgba(0,0,0,0.35)";
    g.lineWidth=2;
    g.beginPath();
    g.moveTo(-8, 0); g.lineTo(8, 0);
    g.moveTo(-7, 5); g.lineTo(7, 5);
    g.moveTo(-6, 10); g.lineTo(6, 10);
    g.stroke();

    // ì¤‘ì•™ í•˜ì´ë¼ì´íŠ¸
    g.globalAlpha = 0.28;
    g.fillStyle="#fff";
    g.fillRect(-2, -10, 2, 22);

    g.restore();
  }

  // ===== ë°˜ì§€: "íŒŒë€ ë³´ì„ ë°•íŒ ë°˜ì§€" =====
  else if(it.slot==="ring"){
    g.save();
    // ë§ ë°”ë””
    g.strokeStyle="#e5e5e5";
    g.lineWidth=4;
    g.beginPath();
    g.arc(0, 2, 10, 0, Math.PI*2);
    g.stroke();

    // ë³´ì„(íŒŒë€ìƒ‰)
    g.fillStyle="#3aa0ff";
    g.beginPath();
    g.arc(0, -8, 4, 0, Math.PI*2);
    g.fill();

    // ë³´ì„ í•˜ì´ë¼ì´íŠ¸
    g.globalAlpha = 0.35;
    g.fillStyle="#ffffff";
    g.beginPath();
    g.arc(-1, -9, 2, 0, Math.PI*2);
    g.fill();

    // ë³´ì„ ë°›ì¹¨(ì„¸íŒ…)
    g.globalAlpha = 1;
    g.fillStyle="#cfcfcf";
    g.fillRect(-3, -6, 6, 2);

    g.restore();
  }

  // ê·¸ ì™¸
  else{
    g.save();
    g.fillStyle="#999";
    g.fillRect(-10,-10,20,20);
    g.restore();
  }

  g.restore();
}

function getSelectedItem(){
  if(!selectedItem) return null;
  if(selectedItem.from==="bag") return inventory[selectedItem.idx] || null;
  if(selectedItem.from==="equip") return equipment[selectedItem.slot] || null;
  return null;
}

/* ===== ë Œë”: ì¥ë¹„/ìŠ¤í™ ===== */

/* ===== UI: EQUIP PANEL ===== */

function renderEquipPanel(){
  equipSlotsEl.innerHTML = "";

  // âœ… ìŠ¤í™ì°½ ì¥ì°© ìŠ¬ë¡¯ ìˆœì„œ ê³ ì •: ë¬´ê¸°, íˆ¬êµ¬, ê°‘ì˜·, ë°˜ì§€
  const SLOT_ORDER = ["weapon","helm","chest","ring"];

  for(const slot of SLOT_ORDER){
    const it = equipment[slot];

    const d = document.createElement("div");
    d.className = "eSlotSmall";
    if(it) d.classList.add(rarityClass(it));
    if(selectedItem && selectedItem.from==="equip" && selectedItem.slot===slot) d.classList.add("selected");

    const c = document.createElement("canvas");
    c.width = 44; c.height = 44;
    d.appendChild(c);
    drawItemIcon(c, it);

    d.addEventListener("click", ()=>{
      // 1) ê°€ë°©ì—ì„œ ì„ íƒí•œ ì•„ì´í…œì´ ìˆìœ¼ë©´ -> í•´ë‹¹ ìŠ¬ë¡¯ì— ì¥ì°©
      if(selectedItem && selectedItem.from==="bag"){
        equipFromBagToSlot(selectedItem.idx, slot);
        selectedItem = {from:"equip", slot};
        renderAllPanels();
        return;
      }

      // 2) ìŠ¤í™ì°½ì—ì„œ ìŠ¬ë¡¯ ì„ íƒ/í•´ì œ(í† ê¸€)
      if(!selectedItem || selectedItem.from!=="equip" || selectedItem.slot!==slot){
        selectedItem = {from:"equip", slot};
      }else{
        // ë‹¤ì‹œ ëˆ„ë¥´ë©´: ì•„ì´í…œ ìˆìœ¼ë©´ í•´ì œ(ê°€ë°©ìœ¼ë¡œ), ì—†ìœ¼ë©´ ì„ íƒ í•´ì œ
        if(equipment[slot]) unequipSlotToBag(slot);
        else selectedItem = null;
      }
      renderAllPanels();
    });

    equipSlotsEl.appendChild(d);
  }

  const g = player.gear || {};
  specTextEl.textContent =
`ìƒëª…ë ¥: ${player.hp.toFixed(0)} / ${player.maxHp.toFixed(0)}
ë°©ì–´ë„: ${(player.armor ?? 0).toFixed(0)}
ì´ˆë‹¹ ìƒëª…ë ¥ ì¬ìƒ: ${(g.hpRegen ?? 0).toFixed(2)}

ê³µê²© í”¼í•´: ${fmtIncPctFromMul(g.dmgMul ?? 1)}
ê³µê²© ì†ë„: ${fmtIncPctFromMul(g.atkSpdMul ?? 1)}
ì‚¬ê±°ë¦¬: ${fmtIncPctFromMul(g.rangeMul ?? 1)}

ì¹˜ëª…íƒ€ í™•ë¥ : ${(getCritChance()*100).toFixed(1)}%
ì¹˜ëª…íƒ€ í”¼í•´ ë°°ìœ¨: +${((getCritMulti()-1)*100).toFixed(0)}%

ì´ë™ ì†ë„: ${fmtIncPctFromMul(g.spdMul ?? 1)}`;
// âœ… ìŠ¤í™ì°½ì˜ ì•„ì´í…œ ìƒì„¸ì •ë³´ëŠ” 'ìŠ¤í™ì°½ì—ì„œ ì„ íƒí•œ ìŠ¬ë¡¯'ë§Œ ë³´ì—¬ì¤€ë‹¤
  const itSel = (selectedItem && selectedItem.from==="equip") ? getSelectedItem() : null;
  equipInfoEl.innerHTML = itSel ? prettyItemHTML(itSel) : "";
}

/* ===== ë Œë”: ê°€ë°© ===== */

/* ===== UI: BAG PANEL ===== */

function renderBagPanel(){
  bagGridEl.innerHTML = "";
  const minSlots = 24;
  const fillTo = Math.max(minSlots, Math.ceil((inventory.length)/6)*6);

  for(let i=0;i<fillTo;i++){
    const it = inventory[i] || null;

    const cell = document.createElement("div");
    cell.className = "bItem";
    if(it) cell.classList.add(rarityClass(it));
    if(it && it.isUnique) cell.classList.add("unique");
    if(selectedItem && selectedItem.from==="bag" && selectedItem.idx===i) cell.classList.add("selected");
    if(!it) cell.style.opacity = "0.35";

    const c = document.createElement("canvas");
    c.width = 40; c.height = 40;
    c.className = "iconCanvas";
    cell.appendChild(c);
    drawItemIcon(c, it);
    c.style.display = "block";
c.style.background = "rgba(255,255,255,0.06)";

  cell.addEventListener("pointerup", (e)=>{
  e.preventDefault();

  if(!it){
    selectedItem = null;
  }else{
    selectedItem = {from:"bag", idx:i};
  }

  renderAllPanels();
}, {passive:false});

    bagGridEl.appendChild(cell);
  }

  const it = getSelectedItem();
  if(it && selectedItem?.from==="bag") bagInfoEl.innerHTML = prettyItemHTML(it);
else if(!bagInfoEl.innerHTML) bagInfoEl.innerHTML = "";
bagInfoEl.style.minHeight = "140px";
bagInfoEl.style.overflowY = "auto";
bagInfoEl.style.boxSizing = "border-box";
}

/* ===== ë Œë”: ì¹´ì˜¤ìŠ¤ ===== */

/* ===== UI: CHAOS PANEL ===== */

function renderCraftPanel(){
  // ê¸°ë³¸ ì•ˆë‚´
  if(orbDescEl) orbDescEl.textContent = "ì˜¤ë¸Œë¥¼ ì„ íƒí•˜ë©´ ì„¤ëª…ì´ í‘œì‹œë©ë‹ˆë‹¤.";
  const it = getSelectedItem();

  // ì˜¤ë¸Œ ì¹´ìš´íŠ¸ í‘œì‹œ
  if(orbCountsEl){
    orbCountsEl.textContent =
      `ë³€í™˜ ${transmuteOrbs}  ë³€í™” ${alterationOrbs}
` +
      `ì¦ê°• ${augmentationOrbs}  ì œì™• ${regalOrbs}
` +
      `ì—°ê¸ˆ ${alchemyOrbs}  ì¹´ì˜¤ìŠ¤ ${chaosOrbs}
` +
      `ì„¸ê³µ ${scouringOrbs}  ìŠ¹ê²© ${exaltedOrbs}
` +
      `ì†Œë©¸ ${annulOrbs}  ì‹ ì„± ${divineOrbs}`;
  }

  // ê¸°ë³¸ ë¹„í™œì„±
  const btns = [btnTransmute,btnAlter,btnAug,btnRegal,btnAlchemy,btnChaos,btnScour,btnExalt,btnAnnul,btnDivine,btnCorrupt];
  for(const b of btns){ if(b) b.disabled = true; }

  if(!it){
    craftItemTextEl.innerHTML = "<div style='color:#bbb'>ì•„ì´í…œì„ ë¨¼ì € ì„ íƒí•˜ì„¸ìš”.</div>";
    return;
  }
  if(it.isUnique){
    craftItemTextEl.innerHTML = "<div style='color:#bbb'>ì „ì„¤(ìœ ë‹ˆí¬)ì€ ì œì‘ ë¶ˆê°€.</div>" + prettyItemHTML(it);
    return;
  }

  const r = it.rarity || "normal";
  const affCnt = Array.isArray(it.affixes) ? it.affixes.length : 0;

  // ì¡°ê±´ë³„ ë²„íŠ¼ í™œì„±
  if(btnTransmute) btnTransmute.disabled = !(transmuteOrbs>0 && r==="normal");
  if(btnAlter)     btnAlter.disabled     = !(alterationOrbs>0 && r==="magic");
  if(btnAug)       btnAug.disabled       = !(augmentationOrbs>0 && r==="magic" && affCnt < 2);
  if(btnRegal)     btnRegal.disabled     = !(regalOrbs>0 && r==="magic" && affCnt>=1);
  if(btnAlchemy)   btnAlchemy.disabled   = !(alchemyOrbs>0 && r==="normal");
  if(btnChaos)     btnChaos.disabled     = !(chaosOrbs>0 && (r==="rare" || r==="rare"));
  if(btnScour)     btnScour.disabled     = !(scouringOrbs>0 && r!=="normal");
  if(btnExalt)     btnExalt.disabled     = !(exaltedOrbs>0 && (r==="rare"||r==="rare") && affCnt < maxAffixesForRarity(r));
  if(btnAnnul)     btnAnnul.disabled     = !(annulOrbs>0 && affCnt > 0);
  if(btnDivine)    btnDivine.disabled    = !(divineOrbs>0 && affCnt > 0);

  craftItemTextEl.innerHTML = prettyItemHTML(it);

  try{ drawItemIcon(craftItemIconCv, it); }catch(e){}
}


/* ===== UI: RENDER ALL PANELS ===== */


function renderAllPanels(){
  safeCall(renderEquipPanel, "renderEquipPanel");
  safeCall(renderBagPanel,  "renderBagPanel");
  safeCall(renderCraftPanel, "renderCraftPanel");

  _callHook('afterRenderPanels');
}

/* ===== ì¥ì°©/í•´ì œ ===== */
function equipFromBagToSlot(invIndex, slot){
  const it = inventory[invIndex];
  if(!it) return;
  if(it.isUnique) return;
  if(it.slot !== slot) return;

  if(equipment[slot]) inventory.push(equipment[slot]);
  inventory.splice(invIndex, 1);
  equipment[slot] = it;

  selectedItem = {from:"equip", slot};
  rebuildGearFromEquipment();
  renderAllPanels();

  _callHook('afterEquip', slot, equipment[slot]);
}

function unequipSlotToBag(slot){
  const it = equipment[slot];
  if(!it) return;
  equipment[slot] = null;
  inventory.push(it);
  selectedItem = null;
  rebuildGearFromEquipment();
  renderAllPanels();

  _callHook('afterUnequip', slot);
}

/* ===== íŒ¨ë„ ì—´ê³  ë‹«ê¸° ===== */
function openPanel(which){
  pauseGame({ dim: 0.60, blur: 2 });
  panelOpen = which;

  equipOverlay.style.display = (which==="equip") ? "flex" : "none";
  bagOverlay.style.display   = (which==="bag")   ? "flex" : "none";
  craftOverlay.style.display = (which==="craft") ? "flex" : "none";

  renderAllPanels();
}
function closePanels(){
  panelOpen = null;
  equipOverlay.style.display = "none";
  bagOverlay.style.display   = "none";
  craftOverlay.style.display = "none";
  resumeGame();
}

// HUD buttons
document.getElementById("btnEquip").addEventListener("click", (e)=>{ stopEvt(e); openPanel("equip"); });
document.getElementById("btnBag").addEventListener("click", (e)=>{ stopEvt(e); openPanel("bag"); });
// ì¥ë¹„ -> ê°€ë°©
document.getElementById("btnEquipToBag").addEventListener("click", (e)=>{
  stopEvt(e);
  renderAllPanels();
});
// ì¥ë¹„ -> ì œì‘
document.getElementById("btnEquipCraft").addEventListener("click", (e)=>{
  stopEvt(e);
  // ì¥ë¹„ì°½ì—ì„œ ì„ íƒëœ ì•„ì´í…œì´ ìˆì–´ì•¼ í•¨
  if(!selectedItem || selectedItem.from !== "equip") return;
  openPanel("craft");
});


// ê°€ë°© -> ì¥ë¹„
document.getElementById("btnBagToEquip").addEventListener("click", (e)=>{
  stopEvt(e);
  openPanel("equip");
});
const equipToBagBtn = document.getElementById("btnEquipToBag");

function goBag(e){
  stopEvt(e);
  openPanel("bag");
}

// âœ… iOS í¬í•¨ ì „ë¶€ í™•ì‹¤í•˜ê²Œ ë¨¹ëŠ” ë°©ì‹
equipToBagBtn.addEventListener("pointerdown", goBag);
equipToBagBtn.addEventListener("click", goBag);
equipToBagBtn.style.touchAction = "manipulation";
document.getElementById("btnBagEquip").addEventListener("click", (e)=>{
  stopEvt(e);

  if(!selectedItem || selectedItem.from !== "bag") return;
  const it = inventory[selectedItem.idx];
  if(!it || it.isUnique) return;

  equipFromBagToSlot(selectedItem.idx, it.slot);
  renderAllPanels(); // âœ… í™”ë©´ë§Œ ê°±ì‹ , íŒ¨ë„ ì´ë™ ì—†ìŒ
});

// âœ… ì¥ë¹„: ì„ íƒëœ ìŠ¬ë¡¯ í•´ì œ
document.getElementById("btnEquipUnequip").addEventListener("click", (e)=>{
  stopEvt(e);

  if(!selectedItem || selectedItem.from !== "equip") return;
  const slot = selectedItem.slot;
  if(!slot || !equipment[slot]) return;

  unequipSlotToBag(slot);
  renderAllPanels(); // âœ… í™”ë©´ë§Œ ê°±ì‹ , íŒ¨ë„ ì´ë™ ì—†ìŒ
});
// Close buttons
document.getElementById("btnEquipClose").addEventListener("click", closePanels);
document.getElementById("btnBagClose").addEventListener("click", closePanels);
document.getElementById("btnCraftClose").addEventListener("click", closePanels);
const btnBagEquip = document.getElementById("btnBagEquip");
if(btnBagEquip){
  btnBagEquip.addEventListener("click", (e)=>{
    stopEvt(e);

    if(!selectedItem || selectedItem.from !== "bag") return;

    const it = inventory[selectedItem.idx];
    if(!it) return;
    if(it.isUnique) return;

    const slot = it.slot;
    if(!slot) return;

    equipFromBagToSlot(selectedItem.idx, slot);

    selectedItem = { from:"equip", slot };
    openPanel("equip");
  });
}
// ESC closes
window.addEventListener("keydown", (e)=>{
  if(e.key === "Escape" && panelOpen) closePanels();
});

/* ============================= */
/* âœ… POE ì „ìš© ì œì‘(ì˜¤ë¸Œ) ì‹œìŠ¤í…œ  */
/* ============================= */

function rebuildItemInstanceFromAffixes(it, baseId, tmpl, rarity, ilvl, tags, affixes){
  const baseData = buildBaseDataFromItemId(baseId);
  const safeAff = Array.isArray(affixes) ? clampAffixLimits(affixes, rarity) : [];

  const mods = buildItemMods(baseId, baseData, safeAff, tags);
  const affixData = buildAffixDataFromMods(mods);
  const totalData = mergeItemData(baseData, affixData);

  const preNames = safeAff.filter(x=>x.kind==="prefix").map(x=>x.affix.name);
  const sufNames = safeAff.filter(x=>x.kind==="suffix").map(x=>x.affix.name);

  // ì´ë¦„ ê·œì¹™(PoE):
  // - normal: ë² ì´ìŠ¤ëª…
  // - magic : (ì ‘ë‘) ë² ì´ìŠ¤ (ì ‘ë¯¸)  â€» ì ‘ë‘/ì ‘ë¯¸ ê°ê° ìµœëŒ€ 1ê°œë§Œ í‘œì‹œ
  // - rare  : ë ˆì–´ ì „ìš© 2ë‹¨ì–´ ì´ë¦„(ë² ì´ìŠ¤ëª… ëŒ€ì‹ )
  // - unique: (ìœ ë‹ˆí¬ëŠ” í…œí”Œë¦¿/ì•„ì´í…œì— ì´ë¯¸ ì´ë¦„ì´ ìˆìœ¼ë©´ ê·¸ê±¸ ìœ ì§€)
  let nm = tmpl.name;

  if(rarity === "magic"){
    const pre = preNames[0] || "";
    const suf = sufNames[0] || "";
    if(pre && suf) nm = pre + " " + nm + " " + suf;
    else if(pre) nm = pre + " " + nm;
    else if(suf) nm = nm + " " + suf;
  }else if(rarity === "rare"){
    nm = rollRareName();
  }else if(rarity === "unique"){
    nm = (it.uniqueName || tmpl.uniqueName || it.name || tmpl.name);
  }

  it.baseId = baseId;
  it.baseName = tmpl.name;
  it.name = nm;
  it.rarity = rarity;
  it.ilvl = ilvl;

  it.baseData = baseData;
  it.tags = tags;
  it.affixes = safeAff;
  it.mods = mods;

  it.affixData = affixData;
  it.totalData = totalData;
  it.data = totalData;

  it.shownDesc = (tmpl.descGen ? tmpl.descGen(totalData) : (it.shownDesc || ""));
}

function craftOnSelected(type){
  const sel = selectedItem;
  if(!sel) return;

  const it = getSelectedItem();
  if(!it) return;
  if(it.isUnique) return;

  const baseId = it.baseId || it.id;
  const tmpl = getItemTemplateById(baseId);
  if(!tmpl) return;

  const ilvl = it.ilvl || getItemLevel();
  const tags = inferItemTagsFromTemplate(tmpl, baseId);

  const curR = it.rarity || "normal";
  const curAff = Array.isArray(it.affixes) ? it.affixes.slice() : [];

  function spend(refName){
    // refName: string variable name
    if(refName === "transmuteOrbs"){ if(transmuteOrbs<=0) return false; transmuteOrbs--; return true; }
    if(refName === "alterationOrbs"){ if(alterationOrbs<=0) return false; alterationOrbs--; return true; }
    if(refName === "augmentationOrbs"){ if(augmentationOrbs<=0) return false; augmentationOrbs--; return true; }
    if(refName === "regalOrbs"){ if(regalOrbs<=0) return false; regalOrbs--; return true; }
    if(refName === "alchemyOrbs"){ if(alchemyOrbs<=0) return false; alchemyOrbs--; return true; }
    if(refName === "chaosOrbs"){ if(chaosOrbs<=0) return false; chaosOrbs--; return true; }
    if(refName === "scouringOrbs"){ if(scouringOrbs<=0) return false; scouringOrbs--; return true; }
    if(refName === "exaltedOrbs"){ if(exaltedOrbs<=0) return false; exaltedOrbs--; return true; }
    if(refName === "annulOrbs"){ if(annulOrbs<=0) return false; annulOrbs--; return true; }
    if(refName === "divineOrbs"){ if(divineOrbs<=0) return false; divineOrbs--; return true; }
    if(refName === "corruptOrbs"){ if(typeof corruptOrbs!=="number"||corruptOrbs<=0) return false; corruptOrbs--; return true; }
    return false;
  }

  let nextR = curR;
  let nextAff = curAff;

  // ì œì‘ ê·œì¹™(ê°„ì†Œí™” PoE):
  if(type === "transmute"){
    if(curR !== "normal") return;
    if(!spend("transmuteOrbs")) return;
    nextR = "common";
    nextAff = rollAffixesPOE("common", ilvl, tags);
  }
  else if(type === "alter"){
    if(curR !== "common") return;
    if(!spend("alterationOrbs")) return;
    nextR = "common";
    nextAff = rollAffixesPOE("common", ilvl, tags);
  }
  else if(type === "aug"){
    if(curR !== "common") return;
    if(curAff.length >= 2) return;
    if(!spend("augmentationOrbs")) return;
    nextR = "common";
    nextAff = rollAffixesPOE("common", ilvl, tags, { existingAffixes:curAff, keepExisting:true, total: curAff.length+1, add:true });
  }
  else if(type === "regal"){
    if(curR !== "common") return;
    if(curAff.length < 1) return;
    if(!spend("regalOrbs")) return;
    nextR = "rare";
    nextAff = rollAffixesPOE("rare", ilvl, tags, { existingAffixes:curAff, keepExisting:true, total: curAff.length+1, add:true });
  }
  else if(type === "alchemy"){
    if(curR !== "normal") return;
    if(!spend("alchemyOrbs")) return;
    nextR = "rare";
    nextAff = rollAffixesPOE("rare", ilvl, tags);
  }
  else if(type === "chaos"){
    if(!(curR === "rare" || curR === "rare")) return;
    if(!spend("chaosOrbs")) return;
    nextR = curR;
    nextAff = rollAffixesPOE(nextR, ilvl, tags);
  }
  else if(type === "scour"){
    if(curR === "normal") return;
    if(!spend("scouringOrbs")) return;
    nextR = "normal";
    nextAff = [];
  }
  else if(type === "exalt"){
    if(!(curR === "rare" || curR === "rare")) return;
    if(curAff.length >= maxAffixesForRarity(curR)) return;
    if(!spend("exaltedOrbs")) return;
    nextR = curR;
    nextAff = rollAffixesPOE(nextR, ilvl, tags, { existingAffixes:curAff, keepExisting:true, total: curAff.length+1, add:true });
  }
  else if(type === "annul"){
    if(curAff.length <= 0) return;
    if(!spend("annulOrbs")) return;
    nextR = curR;
    const k = (Math.random()*curAff.length)|0;
    nextAff = curAff.slice();
    nextAff.splice(k, 1);
    // affixê°€ 0ì´ë©´ normalë¡œ ë–¨ì–´ëœ¨ë¦¬ì§€ëŠ” ì•ŠìŒ(ì›í•˜ë©´ ë°”ê¿€ ìˆ˜ ìˆìŒ)
    if(nextR === "magic" && nextAff.length === 0) nextR = "normal";
  }
  else if(type === "divine"){
    if(curAff.length <= 0) return;
    if(!spend("divineOrbs")) return;
    nextR = curR;
    nextAff = rerollValuesPOE(curAff, ilvl);
  }
  else if(type === "corrupt"){
    // íƒ€ë½: ê¸°ì¡´ ì„í”Œë¦¿ ì œê±° í›„ (ìƒˆ ì„í”Œë¦¿ 1ê°œ ì¶”ê°€) / (ë³€í™” ì—†ìŒ) / (ì•„ì´í…œ íŒŒê´´)
    if(!spend("corruptOrbs")) return;

    const roll = Math.random();
    if(roll < 0.15){
      // 15%: ì•„ì´í…œ íŒŒê´´
      destroySelectedItem();
      updateCraftSelectedFromEquipOrBag();
      renderAllPanels();
      return;
    }
    else if(roll < 0.45){
      // 30%: ë³€í™” ì—†ìŒ
      // nothing
    }
    else{
      // 55%: ì„í”Œë¦¿ êµì²´(ìƒˆ ì„í”Œë¦¿ 1ê°œ ë¶€ì—¬)
      it.implicits = [];
      const pool = getCorruptImplicitPool(tags);
      if(pool.length){
        const picked = pool[Math.floor(Math.random()*pool.length)];
        // makeImplicitModsFromTemplateê°€ ê¸°ëŒ€í•˜ëŠ” í˜•íƒœë¡œ ë³µì‚¬
        it.implicits = [ JSON.parse(JSON.stringify(picked)) ];
      }
    }
  }


  rebuildItemInstanceFromAffixes(it, baseId, tmpl, nextR, ilvl, tags, nextAff);

  // ì¥ë¹„/ê°€ë°© ìœ„ì¹˜ì— ë”°ë¼ ë°˜ì˜ + ìŠ¤íƒ¯ ì¬ê³„ì‚°
  if(sel.from === "equip"){
    equipment[sel.slot] = it;
    rebuildGearFromEquipment();
  }

  renderAllPanels();
}

// ë²„íŠ¼ ì—°ê²°
if(btnTransmute) btnTransmute.addEventListener("click", ()=> craftOnSelected("transmute"));
if(btnAlter)     btnAlter.addEventListener("click", ()=> craftOnSelected("alter"));
if(btnAug)       btnAug.addEventListener("click", ()=> craftOnSelected("aug"));
if(btnRegal)     btnRegal.addEventListener("click", ()=> craftOnSelected("regal"));
if(btnAlchemy)   btnAlchemy.addEventListener("click", ()=> craftOnSelected("alchemy"));
if(btnChaos)     btnChaos.addEventListener("click", ()=> craftOnSelected("chaos"));
if(btnScour)     btnScour.addEventListener("click", ()=> craftOnSelected("scour"));
if(btnExalt)     btnExalt.addEventListener("click", ()=> craftOnSelected("exalt"));
if(btnAnnul)     btnAnnul.addEventListener("click", ()=> craftOnSelected("annul"));
if(btnDivine)    btnDivine.addEventListener("click", ()=> craftOnSelected("divine"));

/* ==== ìº”ë²„ìŠ¤ í„°ì¹˜ ===== */
canvas.addEventListener("touchstart", (e)=>{
  if(gameOver){ resetGame(); return; }

  if(!e.touches || !e.touches[0]) return;

  const near = getNearbyLoot();
  if(near){
    openLootChoice(near);
    e.preventDefault();
    return;
  }

  if(handleUltimateOrbPress(e.touches[0].clientX, e.touches[0].clientY)){
    e.preventDefault();
  }
},{passive:false});

canvas.addEventListener("mousedown", (e)=>{
  if(gameOver){ resetGame(); return; }

  const near = getNearbyLoot();
  if(near){ openLootChoice(near); return; }

  handleUltimateOrbPress(e.clientX, e.clientY);
});

let lastErr = null;

function drawRuntimeError(e){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle="rgba(0,0,0,0.75)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#fff";
  ctx.font="bold 16px Arial";
  ctx.textAlign="center";
  ctx.fillText("RUNTIME ERROR (F12 Console í™•ì¸)", canvas.width/2, canvas.height/2 - 10);
  ctx.font="14px Arial";
  ctx.fillText(String(e && e.message ? e.message : e), canvas.width/2, canvas.height/2 + 18);
}

function loop(){
  try{
    if(gameOver){
      drawGameOver();
    }else if(gamePaused){
      // âœ… ì •ì§€ í™”ë©´(ë”¤/ë¸”ëŸ¬ ìº¡ì³)ì„ ê³„ì† ë³´ì—¬ì£¼ê¸°ë§Œ
      ctx.setTransform(1,0,0,1,0,0);
      ctx.globalAlpha = 1;
      ctx.filter = "none";
      ctx.drawImage(pauseCanvas, 0, 0);
        }else{
      update();
      draw();

      if(resumeFade > 0){
        const a = resumeFade / resumeFadeMax;
        ctx.setTransform(1,0,0,1,0,0);
        ctx.globalAlpha = a;
        ctx.filter = "none";
        ctx.drawImage(pauseCanvas, 0, 0);
        ctx.globalAlpha = 1;
        resumeFade--;
      }
    }
    lastErr = null;
  }catch(e){
    console.error(e);
    lastErr = e;
    drawRuntimeError(e);
  }finally{
    requestAnimationFrame(loop);
  }
}

/* ===== ê³µê²© ì•„ì´ì½˜ ===== */
const iconCanvas = document.getElementById("attackIcon");
const iconCtx = iconCanvas.getContext("2d");
iconCtx.clearRect(0, 0, 60, 60);
iconCtx.save();
iconCtx.translate(30, 34);
iconCtx.scale(1.4, 1.4);
drawSwordShape(iconCtx);
iconCtx.restore();

function resetGame(){
  mapTier = 1;


  // âœ… ì¸ë²¤/ì¥ë¹„/ìœ ë‹ˆí¬ ì´ˆê¸°í™”
  inventory = [];
  equipment = { weapon:null, helm:null, chest:null, ring:null };
  selectedItem = null;
  panelOpen = null;
  chaosOrbs = 2;
  ownedUniques = [];
  uniqueState = {};
  if(audioUnlocked && !bgmOsc){
    bgmOsc = startBGM();
  }

  player.baseMaxHp = 100;
  player.maxHp = 100;
  player.hp = 100;

  player.baseArmor = 0;
  player.armor = 0;
  player.invul = 0;
  player.kiOrbs = 0;
  player.ultiActive = false;
  player.ultiCount = 0;
  player.ultiTimer = 0;
  player.levelGlow = 0;

  killCount = 0;
  level = 1;
  killsAtLevelStart = 0;
  killsForNextLevel = 20;
  baseDamageBase = 20;
  ultiDamageBase = 40;

  player.gear = {
    armorAdd: 0, maxHpAdd: 0, hpRegen: 0,
    critChanceAdd: 0, critChanceMul: 1, critMultiAdd: 0
  };

  recalcFromGear();

  shake = 0;
  slowMotion = 0;
  gameOver = false;
  document.getElementById("ui").style.display = "flex";

  startNewMap(1);


  // âœ… ìŠ¤íƒ€í„° ì•„ì´í…œ ì§€ê¸‰(ì•„ì´í…œì´ ì•ˆ ë³´ì´ëŠ” ëŠë‚Œ ë°©ì§€)
  giveStarterItems();
  closePanels();
  resize();

  // ë£¨íŠ¸/UI ë¦¬ì…‹
  loots = [];
  lootOverlayOpen = false;
  pendingLoot = null;
  lootOverlay.style.display = "none";
}
// ===============================
// âœ… FAILSAFE: pickItemsForChoice ì ˆëŒ€ í¬ë˜ì‹œ ë°©ì§€ ë˜í¼
// ===============================
(function(){
  if(typeof pickItemsForChoice !== "function") return;
  const __origPick = pickItemsForChoice;

  window.pickItemsForChoice = function(count){
    try{
      const out = __origPick(count);
      return Array.isArray(out) ? out.filter(Boolean) : [];
    }catch(e){
      console.warn("pickItemsForChoice CRASH BLOCKED:", e);
      return [];
    }
  };
})();
// ===============================
// âœ… DROP FIX: slot/tier/ilvl ê¸°ë³¸ êµ¬í˜„ (ì—†ìœ¼ë©´ ìë™ ì œê³µ)
// ===============================

function __randPickWeighted(pairs){
  // pairs: [{v, w}]
  let sum = 0;
  for(const p of pairs){ sum += Math.max(0, p.w||0); }
  if(sum <= 0) return pairs[0]?.v;
  let r = Math.random() * sum;
  for(const p of pairs){
    r -= Math.max(0, p.w||0);
    if(r <= 0) return p.v;
  }
  return pairs[pairs.length-1]?.v;
}

// 1) ìŠ¬ë¡¯ ë¶„í¬ (PoE ëŠë‚Œ: ì´ˆë°˜ ë¬´ê¸°/ê°‘ì˜· ìœ„ì£¼, í›„ë°˜ ë°˜ì§€/ê¸°íƒ€ë„ ì„ì„)
if(typeof pickSlotForMapTier !== "function"){
  window.pickSlotForMapTier = function(mapTier){
    const t = Math.max(1, mapTier||1);
    // weapon, chest, helm, boots, ring
    if(t <= 2){
      return __randPickWeighted([
        {v:"weapon", w:45},
        {v:"chest",  w:25},
        {v:"helm",   w:15},
        {v:"boots",  w:10},
        {v:"ring",   w:5},
      ]);
    }
    if(t <= 6){
      return __randPickWeighted([
        {v:"weapon", w:35},
        {v:"chest",  w:25},
        {v:"helm",   w:15},
        {v:"boots",  w:12},
        {v:"ring",   w:13},
      ]);
    }
    return __randPickWeighted([
      {v:"weapon", w:28},
      {v:"chest",  w:22},
      {v:"helm",   w:15},
      {v:"boots",  w:13},
      {v:"ring",   w:22},
    ]);
  };
}

// 2) ë² ì´ìŠ¤ í‹°ì–´ ë¶„í¬ (mapTierê°€ ì˜¤ë¥¼ìˆ˜ë¡ ìƒìœ„ tier ë¹„ì¤‘ ì¦ê°€)
if(typeof pickBaseTierForMap !== "function"){
  window.pickBaseTierForMap = function(mapTier){
    const t = Math.max(1, mapTier||1);
    // baseTier: 1~5 ê¸°ì¤€
    if(t <= 2)  return __randPickWeighted([{v:1,w:80},{v:2,w:20}]);
    if(t <= 4)  return __randPickWeighted([{v:1,w:45},{v:2,w:35},{v:3,w:20}]);
    if(t <= 6)  return __randPickWeighted([{v:1,w:20},{v:2,w:30},{v:3,w:30},{v:4,w:20}]);
    if(t <= 8)  return __randPickWeighted([{v:2,w:20},{v:3,w:35},{v:4,w:30},{v:5,w:15}]);
    return __randPickWeighted([{v:3,w:25},{v:4,w:35},{v:5,w:40}]);
  };
}

// 3) ilvl ìŠ¤ì¼€ì¼ (ë§µí‹°ì–´ ìƒìŠ¹ â†’ ilvl ìƒìŠ¹)
if(typeof rollItemLevelFromMapTier !== "function"){
  window.rollItemLevelFromMapTier = function(mapTier){
    const t = Math.max(1, mapTier||1);
    // ì˜ˆ: t=1 â†’ 1~8, t=5 â†’ 21~28, t=10 â†’ 46~55
    const base = (t-1)*5 + 1;
    const jitter = Math.floor(Math.random()*8); // 0~7
    return base + jitter;
  };
}

/* =========================
   PoEì‹ íƒœê·¸ ê¸°ë°˜ AFFIX POOL
   (ê¶ê·¹ê¸° í”¼í•´ ì˜µì…˜ ì œê±°ë¨)
   ========================= */

const AFFIX_POOL = {
  weapon: {
    prefix: [
      { id:"p_brutal", name:"ì”í˜¹í•œ", stat:"damage", op:"inc", value:0.20, requiresAll:["melee"] },
      { id:"p_rage", name:"ê²©ë…¸ì˜", stat:"damage", op:"more", value:0.15, requiresAll:["elite"] },
      { id:"p_slayer", name:"í•™ì‚´ì˜", stat:"damage", op:"inc", value:0.25, requiresAll:["boss"] },
      { id:"p_piercing", name:"ê´€í†µì˜", stat:"damage", op:"inc", value:0.20, requiresAll:["projectile"] },
      { id:"p_flame", name:"ì—°ì†Œì˜", stat:"damage", op:"inc", value:0.18, requiresAll:["fire"] },
      { id:"p_frost", name:"ë¹™ê²°ì˜", stat:"damage", op:"inc", value:0.18, requiresAll:["cold"] },
      { id:"p_lightning", name:"ë²ˆê°œì˜", stat:"damage", op:"inc", value:0.18, requiresAll:["lightning"] },
      { id:"p_swift", name:"ì§ˆí’ì˜", stat:"damage", op:"inc", value:0.15, requiresAll:["attack"] },
      { id:"p_vicious", name:"ë§¹ë…ì˜", stat:"damage", op:"inc", value:0.22, requiresAll:["enemy"] },
      { id:"p_destroyer", name:"íŒŒê´´ì˜", stat:"damage", op:"more", value:0.20, requiresAll:["high_tier"] }
    ],
    suffix: [
      { id:"s_assassin", name:"ì•”ì‚´ìì˜", stat:"damage", op:"more", value:0.25, requiresAll:["crit"] },
      { id:"s_hunter", name:"ì‚¬ëƒ¥ê¾¼ì˜", stat:"damage", op:"inc", value:0.20, requiresAll:["elite"] },
      { id:"s_conqueror", name:"ì •ë³µìì˜", stat:"damage", op:"inc", value:0.25, requiresAll:["boss"] },
      { id:"s_flare", name:"â€¦ì˜ í™”ì—¼", stat:"damage", op:"inc", value:0.15, requiresAll:["fire"] },
      { id:"s_storm", name:"â€¦ì˜ í­í’", stat:"damage", op:"inc", value:0.15, requiresAll:["lightning"] },
      { id:"s_wave", name:"â€¦ì˜ íŒŒë™", stat:"damage", op:"inc", value:0.15, requiresAll:["aoe"] },
      { id:"s_precision", name:"ì •ë°€ì˜", stat:"damage", op:"inc", value:0.10, requiresAll:["projectile"] },
      { id:"s_slayer2", name:"â€¦ì˜ í•™ì‚´", stat:"damage", op:"more", value:0.15, requiresAll:["melee"] },
      { id:"s_void", name:"â€¦ì˜ ì‹¬ì—°", stat:"damage", op:"more", value:0.20, requiresAll:["high_tier"] },
      { id:"s_ruin", name:"â€¦ì˜ íŒŒë©¸", stat:"damage", op:"more", value:0.18, requiresAll:["enemy"] }
    ]
  },

  armor: {
    prefix: [
      { id:"ap_giant", name:"ê±°ì¸ì˜", stat:"max_hp", op:"add", value:150 },
      { id:"ap_steel", name:"ê°•ì² ì˜", stat:"armor", op:"add", value:80 },
      { id:"ap_guardian", name:"ìˆ˜í˜¸ì˜", stat:"player_damage_taken", op:"inc", value:-0.10, requiresAll:["projectile"] },
      { id:"ap_fortress", name:"ìš”ìƒˆì˜", stat:"player_damage_taken", op:"inc", value:-0.15, requiresAll:["boss"] },
      { id:"ap_resist", name:"ì •í™”ì˜", stat:"player_damage_taken", op:"inc", value:-0.10, requiresAll:["fire"] },
      { id:"ap_regen", name:"ì¬ìƒì˜", stat:"hp_regen", op:"add", value:5 },
      { id:"ap_endurance", name:"ì¸ë‚´ì˜", stat:"player_damage_taken", op:"inc", value:-0.08 },
      { id:"ap_barrier", name:"ê²°ê³„ì˜", stat:"player_damage_taken", op:"inc", value:-0.12, requiresAll:["spell"] },
      { id:"ap_titan", name:"ê±°ëŒ€í™”ì˜", stat:"max_hp", op:"more", value:0.10 },
      { id:"ap_hardened", name:"ê°•ì¸í•œ", stat:"armor", op:"more", value:0.15 }
    ],
    suffix: [
      { id:"as_vitality", name:"â€¦ì˜ í™œë ¥", stat:"max_hp", op:"add", value:100 },
      { id:"as_wall", name:"â€¦ì˜ ì¥ë²½", stat:"armor", op:"add", value:60 },
      { id:"as_survivor", name:"â€¦ì˜ ìƒì¡´ì", stat:"player_damage_taken", op:"inc", value:-0.10 },
      { id:"as_guard", name:"â€¦ì˜ ìˆ˜í˜¸ì", stat:"player_damage_taken", op:"inc", value:-0.12, requiresAll:["boss"] },
      { id:"as_swift", name:"â€¦ì˜ ë¯¼ì²©", stat:"move_speed", op:"inc", value:0.10 },
      { id:"as_reflect", name:"â€¦ì˜ ë°˜ê²©", stat:"damage_taken", op:"inc", value:-0.05 },
      { id:"as_focus", name:"â€¦ì˜ ì§‘ì¤‘", stat:"hp_regen", op:"add", value:3 },
      { id:"as_absorb", name:"â€¦ì˜ í¡ìˆ˜", stat:"player_damage_taken", op:"inc", value:-0.07 },
      { id:"as_stone", name:"â€¦ì˜ ì•”ì„", stat:"armor", op:"more", value:0.10 },
      { id:"as_eternal", name:"â€¦ì˜ ì˜ì›", stat:"max_hp", op:"more", value:0.08 }
    ]
  }
};
  
function getCorruptImplicitPool(tags){
  // ê°„ë‹¨ íƒ€ë½ ì„í”Œë¦¿ í’€ (PoE ëŠë‚Œ)
  // tagsëŠ” inferItemTagsFromTemplate ê²°ê³¼(weapon/melee/spell/armor/ring ë“±)
  const pool = [];
  const isWeapon = tags.includes("weapon");
  const isArmor  = tags.includes("armor");
  const isRing   = tags.includes("ring");

  // ê³µí†µ
  pool.push({ text:"+%d%% ìµœëŒ€ ìƒëª…ë ¥", stat:"max_hp", op:"inc", value:0.06 });
  pool.push({ text:"+%d%% ì¹˜ëª…íƒ€ í™•ë¥ ", stat:"crit", op:"inc", value:0.05 });
  pool.push({ text:"+%d%% ì¹˜ëª…íƒ€ í”¼í•´", stat:"critDmg", op:"inc", value:0.12 });

  if(isWeapon){
    pool.push({ text:"+%d%% ê³µê²© ì†ë„", stat:"atkSpd", op:"inc", value:0.06 });
    pool.push({ text:"+%d%% ë²”ìœ„", stat:"range", op:"inc", value:0.08 });
    pool.push({ text:"ì¶”ê°€ ë¬¼ë¦¬ í”¼í•´ +%d", stat:"physAddedMin", op:"add", value:2, pairStat:"physAddedMax", pairValue:3 });
  }
  if(isArmor){
    pool.push({ text:"+%d%% ë°©ì–´ë„", stat:"armor", op:"inc", value:0.10 });
    pool.push({ text:"+%d ëª¨ë“  ì €í•­", stat:"resAll", op:"add", value:6 });
    pool.push({ text:"+%d%% ì´ë™ ì†ë„", stat:"moveSpd", op:"inc", value:0.06 });
  }
  if(isRing){
    pool.push({ text:"+%d í™”ì—¼ ì €í•­", stat:"resFire", op:"add", value:8 });
    pool.push({ text:"+%d ëƒ‰ê¸° ì €í•­", stat:"resCold", op:"add", value:8 });
    pool.push({ text:"+%d ë²ˆê°œ ì €í•­", stat:"resLightning", op:"add", value:8 });
  }
  return pool;
}

function destroySelectedItem(){
  const ref = getSelectedItemRef();
  if(!ref) return;
  // equip ìŠ¬ë¡¯ì´ë©´ ë¹„ì›€, bag ìŠ¬ë¡¯ì´ë©´ ì œê±°
  if(ref.kind==="equip"){
    equips[ref.slot] = null;
  }else if(ref.kind==="bag"){
    bag[ref.index] = null;
  }
  selectedItem = null;
}





resetGame();
loop();

/* =========================================
   POE ë©”íƒ€ í¬ë˜í”„íŒ… ì‹œìŠ¤í…œ (FULL INTEGRATED)
   - ì ‘ë‘ ê³ ì • / ì ‘ë¯¸ ê³ ì • í† ê¸€
   - ë©”íƒ€ ì œê±°(ì—‘ì˜ 3)
   - íŒ¨ë„ ë Œë” í›…(ì•ˆì „ ì˜¤ë²„ë¼ì´ë“œ)
   - ì•„ì´í…œ ì„¤ëª…ì°½ì— í•œê¸€ í‘œì‹œ(í•˜ëŠ˜ìƒ‰)
========================================= */
(function(){

function ensureMetaCraftUI(){
  const orbDescEl = document.getElementById("orbDesc");
  if(!orbDescEl) return;
  if(document.getElementById("metaCraftBox")) return;

  const box = document.createElement("div");
  box.id = "metaCraftBox";
  box.style.marginBottom = "10px";
  box.style.padding = "10px";
  box.style.border = "1px solid rgba(255,255,255,0.12)";
  box.style.borderRadius = "12px";
  box.style.background = "rgba(0,0,0,0.25)";
  box.style.display = "grid";
  box.style.gridTemplateColumns = "1fr 1fr";
  box.style.gap = "8px";

  // ë²„íŠ¼ ê¸°ë³¸ ìŠ¤íƒ€ì¼(ê¸°ì¡´ CSS ì•ˆ ê±´ë“œë¦¬ê³  ì¸ë¼ì¸ë¡œë§Œ)
  const btnStyle = "padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,0.14);background:#202020;color:#f2f2f2;font-weight:900;";
  const btnDanger = "padding:10px;border-radius:12px;border:1px solid rgba(255,255,255,0.14);background:#2a1010;color:#ffd166;font-weight:900;";

  box.innerHTML = `
    <button id="btnLockPrefix" style="${btnStyle}">ì ‘ë‘ ê³ ì • (OFF)</button>
    <button id="btnLockSuffix" style="${btnStyle}">ì ‘ë¯¸ ê³ ì • (OFF)</button>
    <button id="btnRemoveMeta" style="grid-column:1 / span 2;${btnDanger}">ë©”íƒ€ ì œê±° (ì—‘ì˜ 3)</button>
    <div style="grid-column:1 / span 2; font-size:12px; opacity:.85; line-height:1.3;">
      â€¢ ê³ ì •ì€ ë³€ê²½ê³„ì—´(ë³€í™”/ì¹´ì˜¤ìŠ¤/ì •ì œ/ì†Œë©¸)ì—ë§Œ ì˜ë¯¸ê°€ ìˆì–´ìš”<br>
      â€¢ ë©”íƒ€ ì œê±°ëŠ” ê³ ì • 1ê°œ ì´ìƒ ì¼œì ¸ ìˆì„ ë•Œë§Œ ê°€ëŠ¥
    </div>
  `;

  orbDescEl.parentNode.insertBefore(box, orbDescEl);

  document.getElementById("btnLockPrefix").onclick = ()=>{
    const it = (typeof getSelectedItem === "function") ? getSelectedItem() : null;
    if(!it || it.isUnique) return;
    it.metaCraft = it.metaCraft || {lockPrefix:false,lockSuffix:false};
    it.metaCraft.lockPrefix = !it.metaCraft.lockPrefix;
    if(typeof renderAllPanels === "function") renderAllPanels();
  };

  document.getElementById("btnLockSuffix").onclick = ()=>{
    const it = (typeof getSelectedItem === "function") ? getSelectedItem() : null;
    if(!it || it.isUnique) return;
    it.metaCraft = it.metaCraft || {lockPrefix:false,lockSuffix:false};
    it.metaCraft.lockSuffix = !it.metaCraft.lockSuffix;
    if(typeof renderAllPanels === "function") renderAllPanels();
  };

  document.getElementById("btnRemoveMeta").onclick = ()=>{
    const it = (typeof getSelectedItem === "function") ? getSelectedItem() : null;
    if(!it || it.isUnique) return;
    it.metaCraft = it.metaCraft || {lockPrefix:false,lockSuffix:false};
    if(!it.metaCraft.lockPrefix && !it.metaCraft.lockSuffix) return;

    if(typeof exaltedOrbs !== "number" || exaltedOrbs < 3) return;
    exaltedOrbs -= 3;

    it.metaCraft.lockPrefix = false;
    it.metaCraft.lockSuffix = false;

    if(typeof renderAllPanels === "function") renderAllPanels();
  };
}

function renderMetaCraftUI(){
  ensureMetaCraftUI();

  const it = (typeof getSelectedItem === "function") ? getSelectedItem() : null;
  const p = document.getElementById("btnLockPrefix");
  const s = document.getElementById("btnLockSuffix");
  const r = document.getElementById("btnRemoveMeta");

  if(!it || it.isUnique){
    if(p) p.disabled = true;
    if(s) s.disabled = true;
    if(r) r.disabled = true;
    return;
  }

  it.metaCraft = it.metaCraft || {lockPrefix:false,lockSuffix:false};

  if(p) p.textContent = `ì ‘ë‘ ê³ ì • (${it.metaCraft.lockPrefix ? "ON" : "OFF"})`;
  if(s) s.textContent = `ì ‘ë¯¸ ê³ ì • (${it.metaCraft.lockSuffix ? "ON" : "OFF"})`;

  if(r){
    const metaOn = it.metaCraft.lockPrefix || it.metaCraft.lockSuffix;
    const enough = (typeof exaltedOrbs === "number" && exaltedOrbs >= 3);
    r.disabled = !(metaOn && enough);
    r.style.opacity = r.disabled ? "0.55" : "1";
  }
}

// renderAllPanels í›…(ê¸°ì¡´ í•¨ìˆ˜ëŠ” ìœ ì§€)
if(typeof renderAllPanels === "function"){
  const _origRenderAllPanels = renderAllPanels;
  renderAllPanels = function(){
    _origRenderAllPanels();
    try{ renderMetaCraftUI(); }catch(e){}
  };
}

// prettyItemHTML í›…(ê¸°ì¡´ í•¨ìˆ˜ëŠ” ìœ ì§€)
// - ì›ë³¸ í•¨ìˆ˜ê°€ ë§Œë“œëŠ” HTML ë¸”ë¡ ì•ˆì— "ë©”íƒ€" ë¼ì¸ì„ ë¼ì›Œ ë„£ìŒ
if(typeof prettyItemHTML === "function"){
  const _origPretty = prettyItemHTML;
  prettyItemHTML = function(it){
    let html = _origPretty(it);

    if(it && it.metaCraft && (it.metaCraft.lockPrefix || it.metaCraft.lockSuffix)){
      const insert = `
        <div class="itemInfoGap"></div>
        <div class="itemInfoLine itemInfoDim">ë©”íƒ€</div>
        ${it.metaCraft.lockPrefix ? '<div class="itemInfoLine itemInfoMeta">- ì ‘ë‘ ê³ ì •</div>' : ''}
        ${it.metaCraft.lockSuffix ? '<div class="itemInfoLine itemInfoMeta">- ì ‘ë¯¸ ê³ ì •</div>' : ''}
      `;
      // ê°€ì¥ ë§ˆì§€ë§‰ </div> ì•ì— ë„£ê¸° (ì›ë³¸ì´ itemInfoWrapì„ divë¡œ ë‹«ëŠ” êµ¬ì¡°ë¼ê³  ê°€ì •)
      const idx = html.lastIndexOf("</div>");
      if(idx !== -1){
        html = html.slice(0, idx) + insert + html.slice(idx);
      }else{
        html += insert;
      }
    }

    return html;
  };
}

})(); 

</script>
</body>
</html>



