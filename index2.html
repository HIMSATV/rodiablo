<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>Oni Samurai</title>

  <style>
    :root{
      --uiScale: 1.2;
      --uiH: clamp(calc(84px * var(--uiScale)),  calc(16vh * var(--uiScale)),  calc(120px * var(--uiScale)));
      --pad: clamp(calc(66px * var(--uiScale)),  calc(12.5vw * var(--uiScale)), calc(90px  * var(--uiScale)));
      --stick:clamp(calc(28px * var(--uiScale)),  calc(5.6vw * var(--uiScale)),  calc(40px  * var(--uiScale)));
      --btn: clamp(calc(70px * var(--uiScale)),  calc(13vw * var(--uiScale)),   calc(90px  * var(--uiScale)));
    }

    body{ margin:0; background:black; overflow:hidden; touch-action:none; }
    canvas{ position:fixed; top:0; left:0; image-rendering:pixelated; }

    /* ============================= */
    /* ‚úÖ ÌïòÎã® UI Î∞î */
    /* ============================= */
    #ui{
      position:fixed;bottom:0;width:100%;height:var(--uiH);
      background:#111;border-top:3px solid #550000;
      display:flex;align-items:center;justify-content:space-between;
      padding:0 clamp(10px, 4vw, 25px);box-sizing:border-box;
      z-index:50;
    }

    #movePad{
      position:relative;
      width:var(--pad);height:var(--pad);
      border-radius:50%;
      background:#222;
    }
    #stick{
      position:absolute;
      width:var(--stick);
      height:var(--stick);
      border-radius:50%;
      background:#666;
      left: calc(50% - (var(--stick) / 2));
      top:  calc(50% - (var(--stick) / 2));
    }

    /* Ïò§Î•∏Ï™Ω Î≤ÑÌäº ÏòÅÏó≠ */
    #rightBtns{
      position:relative;
      width:var(--btn);
      height:var(--btn);
      display:block;
      overflow:visible;
    }

    #attackBtn{
      position:absolute;
      right:0;
      bottom:0;
      width:var(--btn);height:var(--btn);
      border-radius:50%;
      background:#990000;border:3px solid #ff4444;
      display:flex;align-items:center;justify-content:center;
      font-size:26px;color:white;
      user-select:none;
      -webkit-user-select:none;
    }
    #attackBtn.active{background:red;transform:scale(.85);}

    #attackIcon{
      position:absolute;
      top:50%;
      left:50%;
      transform:translate(-50%,-50%);
      pointer-events:none;
    }

    /* ============================= */
    /* ‚úÖ ÏïÑÏù¥ÌÖú ÏÑ†ÌÉù Ïò§Î≤ÑÎ†àÏù¥ UI     */
    /* ============================= */
    #lootOverlay{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.75);
      z-index:9999;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
    }

    #lootPanel{
      width:min(92vw, 520px);
      background:#111;
      border:2px solid #444;
      border-radius:14px;
      padding:14px;
      box-shadow:0 0 30px rgba(0,0,0,0.6);
    }
    #lootTitle{
      color:#fff;
      font-weight:800;
      font-size:18px;
      margin:4px 2px 10px;
      text-align:center;
    }
    .lootCards{
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .lootCard{
      background:#1a1a1a;
      border:2px solid #333;
      border-radius:12px;
      padding:12px;
      color:#eee;
      line-height:1.25;
    }
    .lootCard .name{
      font-weight:900;
      margin-bottom:6px;
    }
    .lootCard .desc{
      color:#cfcfcf;
      font-size:14px;
    }
    .lootCard button{
      margin-top:10px;
      width:100%;
      padding:10px 12px;
      border:0;
      border-radius:10px;
      background:#2d6cff;
      color:#fff;
      font-weight:800;
      font-size:15px;
    }
    .lootCard.common{
      border-color:#3a3a3a;
      box-shadow:0 0 8px rgba(255,255,255,0.1);
    }
    .lootCard.rare{
      border-color:#2f7bff;
      box-shadow:0 0 14px rgba(0,140,255,0.6);
    }
    .lootCard.epic{
      border-color:#b44dff;
      box-shadow:0 0 18px rgba(180,80,255,0.9);
      animation:epicGlow 1.5s infinite alternate;
    }
    @keyframes epicGlow{
      from{ box-shadow:0 0 10px rgba(180,80,255,0.6); }
      to{ box-shadow:0 0 25px rgba(255,120,255,1); }
    }

    /* ============================= */
    /* ‚úÖ Ïû•ÎπÑ/Í∞ÄÎ∞©/Ïπ¥Ïò§Ïä§: Î∂ÑÎ¶¨ Ï∞Ω UI */
    /* ============================= */
    #hudBtns{
      position:fixed;
      top:10px; left:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      z-index:80;
    }
    .hudBtn{
      width:44px;height:44px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(20,20,20,0.86);
      color:#fff;
      font-size:20px;
      box-shadow:0 0 14px rgba(0,0,0,0.45);
      user-select:none;
      -webkit-user-select:none;
      touch-action:manipulation;
    }
    .hudBtn:active{ transform:scale(0.96); }

    /* Í≥µÌÜµ Ïò§Î≤ÑÎ†àÏù¥ */
    .panelOverlay{
      position:fixed;
      inset:0;
      display:none;
      background:rgba(0,0,0,0.55);
      z-index:9999;
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
      align-items:center;
      justify-content:center;
    }

    /* Í≥µÌÜµ Ìå®ÎÑê */
    .panel{
      width:min(96vw, 980px);
      height:min(90vh, 760px);
      background:#141414;
      border:2px solid #3a3a3a;
      border-radius:14px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .panelTop{
      display:flex;
      align-items:center;
      justify-content:flex-end;
      gap:10px;
    }
    .panelClose{
      padding:8px 12px;
      border-radius:12px;
      border:1px solid #3a3a3a;
      background:#202020;
      color:#f0f0f0;
      cursor:pointer;
      font-size:13px;
    }
    .panelClose:hover{ border-color:#888; }

    /* ===== Ïû•ÎπÑ/Ïä§Ìéô Ìå®ÎÑê ===== */
    #equipPanelBody{
      flex:1 1 auto;
      display:flex;
      gap:12px;
      min-height:0;
    }
    #equipSlots{
      flex:0 0 44%;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
      align-content:start;
    }
    .eSlot{
      border:1px solid #444;
      border-radius:12px;
      background:#1a1a1a;
      padding:10px;
      min-height:84px;
      cursor:pointer;
      display:flex;
      flex-direction:column;
      justify-content:center;
      gap:6px;
    }
    .eSlot:hover{ border-color:#888; }
    .eSlot.selected{ outline:2px solid #ffd166; }
    .eSlot .label{ font-size:12px; color:#aaa; text-transform:uppercase; letter-spacing:0.06em; }
    .eSlot .item{ font-size:14px; color:#f2f2f2; line-height:1.2; word-break:break-word; }

    #specBox{
      flex:1 1 auto;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
      min-height:0;
    }
    #specText{
      flex:0 0 auto;
      white-space:pre-line;
      font-size:13px;
      color:#eee;
      background:#0f0f0f;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:10px;
    }
    #equipInfo{
      flex:1 1 auto;
      overflow:auto;
      white-space:pre-line;
      font-size:13px;
      color:#ddd;
      background:#0f0f0f;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:10px;
    }

 /* ===== Í∞ÄÎ∞© Ìå®ÎÑê ===== */
#bagBody{
  flex:1 1 auto;
  display:flex;
  flex-direction:column;   /* ‚úÖ ÏúÑ-ÏïÑÎûò Î∞∞ÏπòÎ°ú Í≥†Ï†ï */
  gap:12px;
  min-height:0;
}

/* ‚úÖ ÏïÑÏù¥ÌÖú ÏÑ§Î™Ö: ÏúÑ */
#bagInfo{
  flex:0 0 auto;
  max-height:38vh;         /* ‚úÖ ÎÑàÎ¨¥ Ïª§ÏßÄÏßÄ ÏïäÍ≤å */
  overflow:auto;
  white-space:pre-line;
  font-size:13px;
  color:#ddd;
  background:#101010;
  border:1px solid #2b2b2b;
  border-radius:12px;
  padding:12px;
  box-sizing:border-box;
}

/* ‚úÖ Ïù∏Î≤§ Í∑∏Î¶¨Îìú: ÏïÑÎûò + Ïä§ÌÅ¨Î°§ */
#bagGrid{
  flex:1 1 auto;
  overflow:auto;           /* ‚úÖ Ïä§ÌÅ¨Î°§ */
  display:grid;
  grid-template-columns: repeat(6, 1fr);
  gap:8px;
  background:#101010;
  border:1px solid #2b2b2b;
  border-radius:12px;
  padding:10px;
  box-sizing:border-box;
  align-content:start;
  min-height:0;
}
    .bItem{
      border:1px solid #555;
      border-radius:12px;
      background:#171717;
      min-height:56px;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      position:relative;
    }
    .bItem:hover{ border-color:#888; }
    .bItem.selected{ outline:2px solid #6bf178; }
    .bItem.unique{ border-color:#b89b00; }

    .iconCanvas{
      width:40px;height:40px;
      image-rendering:pixelated;
    }

    #bagInfo{
      flex:1 1 auto;
      overflow:auto;
      white-space:pre-line;
      font-size:13px;
      color:#ddd;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
    }

    /* ===== Ïπ¥Ïò§Ïä§ Ìå®ÎÑê ===== */
    #chaosBody{
      flex:1 1 auto;
      display:flex;
      gap:12px;
      min-height:0;
    }
    #chaosLeft{
      flex:1 1 auto;
      background:#101010;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
      box-sizing:border-box;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    #chaosCount{
      font-size:18px;
      font-weight:900;
      color:#fff;
    }
    #chaosBtn{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid #3a3a3a;
      background:#2d6cff;
      color:#fff;
      font-weight:900;
      cursor:pointer;
    }
    #chaosBtn:active{ transform:scale(0.98); }

    #chaosInfo{
      flex:1 1 auto;
      overflow:auto;
      white-space:pre-line;
      font-size:13px;
      color:#ddd;
      background:#0f0f0f;
      border:1px solid #2b2b2b;
      border-radius:12px;
      padding:12px;
    }

    /* Î™®Î∞îÏùº */
    @media (max-width: 600px){
      #bagGrid{ grid-template-columns: repeat(4, 1fr); }
      #equipPanelBody{ flex-direction:column; }
      #equipSlots{ grid-template-columns:1fr 1fr; flex:0 0 auto; }
      #bagBody{ flex-direction:column; }
      #bagGrid{ flex:0 0 auto; }
    }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<!-- ‚úÖ ÏÉÅÎã® ÌÄµ Î≤ÑÌäº(Ïû•ÎπÑ/Í∞ÄÎ∞©/Ïπ¥Ïò§Ïä§) -->
<div id="hudBtns">
  <button class="hudBtn" id="btnEquip" title="Ïû•ÎπÑ/Ïä§Ìéô">‚öîÔ∏è</button>
  <button class="hudBtn" id="btnBag"   title="Í∞ÄÎ∞©">üéí</button>
  <button class="hudBtn" id="btnChaosWnd" title="Ïπ¥Ïò§Ïä§">üåÄ</button>
</div>

<!-- ‚úÖ ÏïÑÏù¥ÌÖú ÏÑ†ÌÉù UI -->
<div id="lootOverlay">
  <div id="lootPanel">
    <div id="lootTitle">ÏïÑÏù¥ÌÖú ÏÑ†ÌÉù (1Í∞úÎßå)</div>
    <div class="lootCards" id="lootCards"></div>
    <div class="lootHint" style="color:#aaa;font-size:12px;margin-top:10px;text-align:center;">ÏÑ†ÌÉùÌïòÎ©¥ Ï¶âÏãú Ï†ÅÏö©Îê©ÎãàÎã§.</div>
  </div>
</div>

<!-- ‚úÖ Ïû•ÎπÑ/Ïä§Ìéô Ìå®ÎÑê -->
<div class="panelOverlay" id="equipOverlay">
  <div class="panel">
    <div class="panelTop">
      <button class="panelClose" id="btnEquipClose" type="button">Îã´Í∏∞</button>
    </div>
    <div id="equipPanelBody">
      <div id="equipSlots"></div>
      <div id="specBox">
        <div id="specText"></div>
        <div id="equipInfo"></div>
      </div>
    </div>
  </div>
</div>

<!-- ‚úÖ Í∞ÄÎ∞© Ìå®ÎÑê -->
<div class="panelOverlay" id="bagOverlay">
  <div class="panel">
    <div class="panelTop">
      <!-- ‚úÖ Ï∂îÍ∞Ä: Ïû•Ï∞© Î≤ÑÌäº -->
      <button class="panelClose" id="btnBagEquip" type="button">Ïû•Ï∞©</button>

      <button class="panelClose" id="btnBagClose" type="button">Îã´Í∏∞</button>
    </div>

    <div id="bagBody">
      <div id="bagGrid"></div>
      <div id="bagInfo"></div>
    </div>
  </div>
</div>

<!-- ‚úÖ Ïπ¥Ïò§Ïä§ Ìå®ÎÑê -->
<div class="panelOverlay" id="chaosOverlay">
  <div class="panel">
    <div class="panelTop">
      <button class="panelClose" id="btnChaosClose" type="button">Îã´Í∏∞</button>
    </div>
    <div id="chaosBody">
      <div id="chaosLeft">
        <div id="chaosCount"></div>
        <button id="chaosBtn" type="button">Ïπ¥Ïò§Ïä§</button>
      </div>
      <div id="chaosInfo"></div>
    </div>
  </div>
</div>

<div id="ui">
  <div id="movePad"><div id="stick"></div></div>
  <div id="rightBtns">
    <div id="attackBtn">
      <canvas id="attackIcon" width="60" height="60"></canvas>
    </div>
  </div>
</div>

<script>
let gamePaused = false;
let pauseOpts = { dim: 0.60, blur: 2 };
let resumeFade = 0;
let resumeFadeMax = 10;

const pauseCanvas = document.createElement("canvas");
const pauseCtx = pauseCanvas.getContext("2d");

function capturePausedFrame(opts = pauseOpts){
  pauseOpts = opts || pauseOpts;
  draw();
  pauseCanvas.width = canvas.width;
  pauseCanvas.height = canvas.height;

  pauseCtx.setTransform(1,0,0,1,0,0);
  pauseCtx.globalAlpha = 1;
  pauseCtx.filter = (pauseOpts.blur > 0) ? `blur(${pauseOpts.blur}px)` : "none";
  pauseCtx.drawImage(canvas, 0, 0);
  pauseCtx.filter = "none";

  if(pauseOpts.dim > 0){
    pauseCtx.globalAlpha = pauseOpts.dim;
    pauseCtx.fillStyle = "#000";
    pauseCtx.fillRect(0,0,pauseCanvas.width,pauseCanvas.height);
    pauseCtx.globalAlpha = 1;
  }
}

function pauseGame(opts){
  if(gamePaused) return;
  resumeFade = 0;
  capturePausedFrame(opts);
  gamePaused = true;
}

function resumeGame(){
  if(resumeFade > 0) return;
  resumeFade = resumeFadeMax;
  gamePaused = false;
}

const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const ui = document.getElementById("ui");

let uiHeight = 120;

function resize(){
  uiHeight = ui.getBoundingClientRect().height || 120;
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - uiHeight;
  if(gamePaused) capturePausedFrame(pauseOpts);
}
resize();
window.addEventListener("resize", ()=>requestAnimationFrame(resize));
requestAnimationFrame(resize);

/* ===== ÏÇ¨Ïö¥Îìú ===== */
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let audioUnlocked = false;

function unlockAudio(){
  if(audioUnlocked) return;
  audioUnlocked = true;
  audioCtx.resume().then(()=>{
    if(!bgmOsc) bgmOsc = startBGM();
  });
}
window.addEventListener("touchstart", unlockAudio, { once:true });
window.addEventListener("mousedown", unlockAudio, { once:true });
window.addEventListener("keydown", unlockAudio, { once:true });

function startBGM(){
  let isPlaying = true;
  function getTempo(){
    if(killCount >= 100) return 150;
    if(killCount >= 50) return 130;
    return 110;
  }
  function playBeat(){
    if(!isPlaying) return;

    let tempo = getTempo();
    let beatTime = 60 / tempo;
    let now = audioCtx.currentTime;

    let kick = audioCtx.createOscillator();
    let kickGain = audioCtx.createGain();
    kick.type = "triangle";
    kick.frequency.setValueAtTime(90, now);
    kick.frequency.exponentialRampToValueAtTime(50, now + 0.12);
    kickGain.gain.setValueAtTime(0.18, now);
    kickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    kick.connect(kickGain);
    kickGain.connect(audioCtx.destination);
    kick.start(now);
    kick.stop(now + 0.15);

    let tone = audioCtx.createOscillator();
    let toneGain = audioCtx.createGain();
    tone.type = "square";
    tone.frequency.value = 220;
    toneGain.gain.setValueAtTime(0.06, now + beatTime/2);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + beatTime/2 + 0.1);
    tone.connect(toneGain);
    toneGain.connect(audioCtx.destination);
    tone.start(now + beatTime/2);
    tone.stop(now + beatTime/2 + 0.1);

    setTimeout(playBeat, beatTime * 1000);
  }
  playBeat();
  return { stop: () => isPlaying = false };
}
let bgmOsc;

function swingSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="sawtooth";
  o.frequency.setValueAtTime(700,audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(200,audioCtx.currentTime+0.12);
  g.gain.value=0.15;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.12);
}
function bossUnsheatheSound(){
  let now = audioCtx.currentTime;

  let o1 = audioCtx.createOscillator();
  let g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(120, now);
  o1.frequency.exponentialRampToValueAtTime(600, now + 0.6);
  g1.gain.setValueAtTime(0.4, now);
  g1.gain.exponentialRampToValueAtTime(0.001, now + 0.6);
  o1.connect(g1);
  g1.connect(audioCtx.destination);
  o1.start(now);
  o1.stop(now + 0.6);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(900, now);
  o2.frequency.exponentialRampToValueAtTime(200, now + 0.4);
  g2.gain.setValueAtTime(0.3, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.4);
}
function thudSound(){
  let now = audioCtx.currentTime;

  let o = audioCtx.createOscillator();
  let g = audioCtx.createGain();
  o.type = "sine";
  o.frequency.setValueAtTime(120, now);
  o.frequency.exponentialRampToValueAtTime(55, now + 0.14);
  g.gain.setValueAtTime(0.32, now);
  g.gain.exponentialRampToValueAtTime(0.001, now + 0.18);
  o.connect(g);
  g.connect(audioCtx.destination);
  o.start(now);
  o.stop(now + 0.18);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "triangle";
  o2.frequency.setValueAtTime(220, now);
  o2.frequency.exponentialRampToValueAtTime(90, now + 0.08);
  g2.gain.setValueAtTime(0.12, now);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.09);
  o2.connect(g2);
  g2.connect(audioCtx.destination);
  o2.start(now);
  o2.stop(now + 0.09);
}
function hitSound(){
  let o=audioCtx.createOscillator();
  let g=audioCtx.createGain();
  o.type="square";
  o.frequency.value=100;
  g.gain.value=0.25;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.08);
}

/* ===== ÌîåÎ†àÏù¥Ïñ¥ ===== */
let player={
  x:0,y:0,
  dir:"left",
  speed:5,
  radius:14,

  hp:100,
  maxHp:100,
  baseMaxHp:100,

  baseArmor:0,
  invul:0,
  knockbackX:0,
  knockbackY:0,

  kiOrbs:0,
  maxOrbs:5,
  levelGlow:0,
  ultiActive:false,
  ultiCount:0,
  ultiTimer:0,

  buffs: { dmgMul:1, spdMul:1, atkSpdMul:1 },
  activeBuffs: []
};

player.weapon = {
  name: "Rusty Katana",
  min: 14,
  max: 20,
  critChance: 0.06,
  critMulti: 1.50
};

let map = [];
let mapSize = 30;
let tileSize = 48;

for(let y=0; y<mapSize; y++){
  let row = [];
  for(let x=0; x<mapSize; x++){
    if(x===0 || y===0 || x===mapSize-1 || y===mapSize-1) row.push(1);
    else row.push(0);
  }
  map.push(row);
}

player.x = mapSize * tileSize / 2;
player.y = mapSize * tileSize / 2;

let reachableMask = null;
let hpWaveOffset = 0;
let slowMotion = 0;
let spawnTimer = 0;
let spawnInterval = 90;
let enemies=[];
let packs = [];

/* ============================= */
/* ‚úÖ ÏïÑÏù¥ÌÖú ÎìúÎûç/ÏÑ†ÌÉù ÏãúÏä§ÌÖú     */
/* ============================= */
let loots = [];
let lootOverlayOpen = false;
let pendingLoot = null;

const lootOverlay = document.getElementById("lootOverlay");
const lootCardsEl = document.getElementById("lootCards");

/* ============================= */
/* ‚úÖ POEÏãù Affix/Tier/ilvl ÏãúÏä§ÌÖú */
/* ============================= */
function getItemLevel(){
  return Math.floor(mapTier * 10 + level * 1.5);
}
function weightedPick(list, weightKey="weight"){
  let total = 0;
  for(const it of list) total += (it[weightKey] ?? 0);
  let r = Math.random() * total;
  for(const it of list){
    r -= (it[weightKey] ?? 0);
    if(r <= 0) return it;
  }
  return list[list.length - 1];
}

const AFFIX_DB = {
  prefix: [
    {
      id:"p_phys", name:"Brutal", group:"dmgMul", weight:100,
      tiers:[
        { t:1, minIlvl:70, min:0.22, max:0.30, w:20 },
        { t:2, minIlvl:50, min:0.16, max:0.21, w:35 },
        { t:3, minIlvl:30, min:0.10, max:0.15, w:60 },
        { t:4, minIlvl:1,  min:0.05, max:0.09, w:90 }
      ],
      apply:(data, roll)=>{ data.dmgMul *= (1 + roll); }
    },
    {
      id:"p_ulti", name:"Cataclysm", group:"ultiMul", weight:80,
      tiers:[
        { t:1, minIlvl:70, min:0.25, max:0.33, w:20 },
        { t:2, minIlvl:45, min:0.18, max:0.24, w:40 },
        { t:3, minIlvl:20, min:0.10, max:0.17, w:70 },
        { t:4, minIlvl:1,  min:0.06, max:0.09, w:90 }
      ],
      apply:(data, roll)=>{ data.ultiMul *= (1 + roll); }
    },
    {
      id:"p_range", name:"Wide", group:"rangeMul", weight:70,
      tiers:[
        { t:1, minIlvl:60, min:0.18, max:0.24, w:25 },
        { t:2, minIlvl:35, min:0.12, max:0.17, w:45 },
        { t:3, minIlvl:1,  min:0.06, max:0.11, w:80 }
      ],
      apply:(data, roll)=>{ data.rangeMul *= (1 + roll); }
    },
    {
      id:"p_crit", name:"Keen", group:"critChanceAdd", weight:55,
      tiers:[
        { t:1, minIlvl:65, min:0.04, max:0.06, w:20 },
        { t:2, minIlvl:40, min:0.025, max:0.039, w:45 },
        { t:3, minIlvl:1,  min:0.01, max:0.024, w:85 }
      ],
      apply:(data, roll)=>{ data.critChanceAdd += roll; }
    }
  ],
  suffix: [
    {
      id:"s_hp", name:"of Vitality", group:"maxHpAdd", weight:100,
      tiers:[
        { t:1, minIlvl:70, min:45, max:70, w:22 },
        { t:2, minIlvl:45, min:30, max:44, w:40 },
        { t:3, minIlvl:20, min:18, max:29, w:70 },
        { t:4, minIlvl:1,  min:10, max:17, w:95 }
      ],
      apply:(data, roll)=>{ data.maxHpAdd += roll; }
    },
    {
      id:"s_armor", name:"of Fortitude", group:"armorAdd", weight:85,
      tiers:[
        { t:1, minIlvl:70, min:18, max:26, w:22 },
        { t:2, minIlvl:45, min:12, max:17, w:40 },
        { t:3, minIlvl:20, min:7,  max:11, w:70 },
        { t:4, minIlvl:1,  min:3,  max:6,  w:95 }
      ],
      apply:(data, roll)=>{ data.armorAdd += roll; }
    },
    {
      id:"s_regen", name:"of Regeneration", group:"hpRegen", weight:60,
      tiers:[
        { t:1, minIlvl:65, min:2.2, max:3.4, w:22 },
        { t:2, minIlvl:35, min:1.4, max:2.1, w:45 },
        { t:3, minIlvl:1,  min:0.6, max:1.3, w:85 }
      ],
      apply:(data, roll)=>{ data.hpRegen += roll; }
    },
    {
      id:"s_critmulti", name:"of the Assassin", group:"critMultiAdd", weight:55,
      tiers:[
        { t:1, minIlvl:70, min:0.35, max:0.55, w:20 },
        { t:2, minIlvl:40, min:0.20, max:0.34, w:45 },
        { t:3, minIlvl:1,  min:0.10, max:0.19, w:85 }
      ],
      apply:(data, roll)=>{ data.critMultiAdd += roll; }
    }
  ]
};

function rollTierValue(affix, ilvl){
  const avail = affix.tiers.filter(t => ilvl >= t.minIlvl);
  const picked = weightedPick(avail.map(t=>({ ...t, weight:t.w })));
  const isInt = Number.isInteger(picked.min) && Number.isInteger(picked.max);
  let v = picked.min + Math.random() * (picked.max - picked.min);
  if(isInt) v = Math.floor(v);
  else v = Math.round(v * 1000) / 1000;
  return { tier:picked.t, value:v };
}
function affixCountsByRarity(r){
  if(r === "common") return { pre:1, suf:0, total:1 };
  if(r === "rare")   return { pre:1, suf:1, total:2 };
  if(r === "epic")   return { pre:2, suf:1, total:3 };
  return { pre:0, suf:0, total:0 };
}
function rollAffixesPOE(rarity, ilvl){
  const cnt = affixCountsByRarity(rarity);
  const pickedPre = [];
  const pickedSuf = [];
  const usedGroups = new Set();

  function pickFrom(pool, count){
    const out = [];
    let guard = 0;
    while(out.length < count && guard++ < 500){
      const cand = weightedPick(pool);
      if(usedGroups.has(cand.group)) continue;
      usedGroups.add(cand.group);
      out.push(cand);
    }
    return out;
  }

  pickedPre.push(...pickFrom(AFFIX_DB.prefix, cnt.pre));
  pickedSuf.push(...pickFrom(AFFIX_DB.suffix, cnt.suf));

  const rolled = [];
  for(const a of pickedPre){
    const rr = rollTierValue(a, ilvl);
    rolled.push({ kind:"prefix", affix:a, tier:rr.tier, value:rr.value });
  }
  for(const a of pickedSuf){
    const rr = rollTierValue(a, ilvl);
    rolled.push({ kind:"suffix", affix:a, tier:rr.tier, value:rr.value });
  }
  return rolled;
}

function makeEmptyItemData(){
  return {
    dmgMul: 1,
    ultiMul: 1,
    rangeMul: 1,
    spdMul: 1,
    armorAdd: 0,
    maxHpAdd: 0,
    hpRegen: 0,
    critChanceAdd: 0,
    critMultiAdd: 0
  };
}
function mergeItemData(baseData, affixData){
  const out = makeEmptyItemData();
  out.dmgMul   = (baseData.dmgMul   ?? 1) * (affixData.dmgMul   ?? 1);
  out.ultiMul  = (baseData.ultiMul  ?? 1) * (affixData.ultiMul  ?? 1);
  out.rangeMul = (baseData.rangeMul ?? 1) * (affixData.rangeMul ?? 1);
  out.spdMul   = (baseData.spdMul   ?? 1) * (affixData.spdMul   ?? 1);

  out.armorAdd      = (baseData.armorAdd      ?? 0) + (affixData.armorAdd      ?? 0);
  out.maxHpAdd      = (baseData.maxHpAdd      ?? 0) + (affixData.maxHpAdd      ?? 0);
  out.hpRegen       = (baseData.hpRegen       ?? 0) + (affixData.hpRegen       ?? 0);
  out.critChanceAdd = (baseData.critChanceAdd ?? 0) + (affixData.critChanceAdd ?? 0);
  out.critMultiAdd  = (baseData.critMultiAdd  ?? 0) + (affixData.critMultiAdd  ?? 0);
  return out;
}

function buildBaseDataFromItemId(itemId){
  const base = makeEmptyItemData();

  if(itemId === "dmg_up"){
    const v = Math.floor(8 + level * 1.2 + mapTier * 1.5);
    base.dmgMul *= (1 + v/100);
  }else if(itemId === "ulti_up"){
    const v = Math.floor(12 + level * 1.5 + mapTier * 2);
    base.ultiMul *= (1 + v/100);
  }else if(itemId === "hp"){
    const v = Math.floor(15 + level*3 + mapTier*4);
    base.maxHpAdd += v;
  }else if(itemId === "armor"){
    const v = Math.floor(5 + mapTier*2);
    base.armorAdd += v;
  }else if(itemId === "ring_crit"){
    const cc = (0.015 + mapTier*0.002 + level*0.0006);
    const cm = (0.10  + mapTier*0.01  + level*0.002);
    base.critChanceAdd += cc;
    base.critMultiAdd  += cm;
  }else if(itemId === "ring_regen"){
    const r = (0.6 + mapTier*0.08 + level*0.03);
    const hp = Math.floor(6 + mapTier*2 + level*1.2);
    base.hpRegen += r;
    base.maxHpAdd += hp;
  }else if(itemId === "ring_speed"){
    const ms = Math.floor(6 + mapTier*1.2 + level*0.8);
    base.spdMul *= (1 + ms/100);
  }
  return base;
}

const ITEM_POOL = [
  { id:"dmg_up",     slot:"weapon", name:"Í∞ïÌôîÎêú ÏùºÍ≤©", rarity:"common", descGen:(d)=>`ÌèâÌÉÄ ÌîºÌï¥ +${Math.round(((d.dmgMul ?? 1)-1)*100)}%` },
  { id:"ulti_up",    slot:"weapon", name:"Ìè≠Î∞ú Í∞ïÌôî",   rarity:"common", descGen:(d)=>`Í∂ÅÍ∑πÍ∏∞ ÌîºÌï¥ +${Math.round(((d.ultiMul ?? 1)-1)*100)}%` },
  { id:"hp",         slot:"chest",  name:"ÏÉùÎ™ÖÏùò Ï†ïÏàò", rarity:"rare",   descGen:(d)=>`ÏµúÎåÄ Ï≤¥Î†• +${Math.floor(d.maxHpAdd ?? 0)}` },
  { id:"armor",      slot:"helm",   name:"Ï≤†Î≤Ω Í∞ëÏò∑",   rarity:"rare",   descGen:(d)=>`Î∞©Ïñ¥Î†• +${Math.floor(d.armorAdd ?? 0)}` },
  { id:"ring_crit",  slot:"ring",   name:"ÏπòÎ™Ö Î∞òÏßÄ",   rarity:"rare",   descGen:(d)=>`ÏπòÌôï +${Math.round((d.critChanceAdd ?? 0)*100)}% / ÏπòÌîº +${Math.round((d.critMultiAdd ?? 0)*100)}%` },
  { id:"ring_regen", slot:"ring",   name:"ÏÉùÎ™Ö Î∞òÏßÄ",   rarity:"common", descGen:(d)=>`Ïû¨ÏÉù +${(d.hpRegen ?? 0).toFixed(2)}/s / ÏµúÎåÄÏ≤¥Î†• +${Math.floor(d.maxHpAdd ?? 0)}` },
  { id:"ring_speed", slot:"ring",   name:"ÏßàÏ£º Î∞òÏßÄ",   rarity:"common", descGen:(d)=>`Ïù¥ÏÜç +${Math.round(((d.spdMul ?? 1)-1)*100)}%` }
];

function createItemInstance(baseId, rarityOverride=null){
  const tmpl = ITEM_POOL.find(x => x.id === baseId);
  if(!tmpl) return null;

  const rarity = rarityOverride || tmpl.rarity || "common";
  const ilvl = getItemLevel();

  const baseData = buildBaseDataFromItemId(baseId);
  const affixes = rollAffixesPOE(rarity, ilvl);

  const affixData = makeEmptyItemData();
  for(const a of affixes){
    if(a && a.affix && typeof a.affix.apply === "function"){
      a.affix.apply(affixData, a.value);
    }
  }
  const totalData = mergeItemData(baseData, affixData);

  const preNames = affixes.filter(x=>x.kind==="prefix").map(x=>x.affix.name);
  const sufNames = affixes.filter(x=>x.kind==="suffix").map(x=>x.affix.name);

  let nm = tmpl.name;
  if(preNames.length) nm = preNames.join(" ") + " " + nm;
  if(sufNames.length) nm = nm + " " + sufNames.join(" ");

  return {
    id: baseId,
    baseId,
    baseName: tmpl.name,
    name: nm,
    rarity,
    slot: tmpl.slot,
    ilvl,
    isUnique: false,
    data: totalData,
    totalData,
    baseData,
    affixData,
    affixes,
    shownDesc: tmpl.descGen ? tmpl.descGen(totalData) : ""
  };
}

function giveStarterItems(){
  const starters = ["dmg_up", "armor", "hp", "ring_speed"];
  for(const id of starters){
    const it = createItemInstance(id);
    if(it) inventory.push(it);
  }
}

/* ============================= */
/* ‚úÖ Ï†ÑÏÑ§(Unique) ÏãúÏä§ÌÖú         */
/* ============================= */
let ownedUniques = [];
let uniqueState = {};

function emitEvent(type, payload){
  for(const u of ownedUniques){
    if(u.onEvent) u.onEvent(type, payload);
  }
}
function cloneLegendary(template){
  return {
    id: template.id,
    name: template.name,
    rarity: template.rarity ?? "legendary",
    desc: template.desc ?? "",
    applyStat: template.applyStat,
    onEvent: template.onEvent,
  };
}

function acquireLegendary(template, ilvl){
  if(ownedUniques.some(u => u.id === template.id)){
    shake = Math.max(shake, 6);
    return;
  }
  const u = cloneLegendary(template);
  if(u.applyStat) u.applyStat();
  ownedUniques.push(u);

  inventory.push({
    id: u.id,
    slot: "unique",
    name: u.name,
    rarity: "legendary",
    ilvl,
    isUnique: true,
    uniqueRef: u,
    data: null,
    affixes: []
  });

  recalcFromGear();
}

const LEGENDARY_POOL = [
  {
    id:"unique_thunderstep",
    name:"Ï≤úÎë•Í±∏Ïùå (Thunderstep)",
    rarity:"legendary",
    desc:"Ï†Å Ï≤òÏπò Ïãú Î≤àÍ∞úÍ∞Ä Ï£ºÎ≥ÄÏúºÎ°ú Ïó∞ÏáÑ (Ïø® 0.8Ï¥à)",
    applyStat(){ applyGearDelta({ dmgMul: 1.10 }); },
    onEvent(type, p){
      if(type !== "kill") return;

      const now = frameCount;
      const key = this.id + "_cd";
      const cd = uniqueState[key] ?? 0;
      if(now < cd) return;
      uniqueState[key] = now + 48;

      const cx = p.x, cy = p.y;
      let hits = 0;

      for(const e of enemies){
        if(e.hp <= 0) continue;
        if(e.type === "boss" && e.dead) continue;

        const dx = e.x - cx, dy = e.y - cy;
        if(dx*dx + dy*dy > 200*200) continue;

        e.hp -= baseDamage * 0.65;
        spawnHitBlood(e.x, e.y, 8);

        if(particles.length < 260){
          for(let i=0;i<6;i++){
            particles.push({ x:e.x, y:e.y, vx:(Math.random()-0.5)*6, vy:(Math.random()-0.5)*6, life:18 });
          }
        }
        hits++;
        if(hits >= 4) break;
      }
      pruneDeadEnemies();
    }
  },
  {
    id:"unique_oni_aegis",
    name:"Ïò§ÎãàÏùò ÏàòÌò∏ (Oni Aegis)",
    rarity:"legendary",
    desc:"ÌîºÍ≤© Ïãú Î≥¥Ìò∏Îßâ 1Ìöå ÏÉùÏÑ± (ÌîºÌï¥ 35% Í∞êÏÜå ÎäêÎÇå, 2Ï¥à, Ïø® 6Ï¥à)",
    applyStat(){
      player.baseArmor += 4;
      player.baseMaxHp += 20;
      player.hp += 20;
    },
    onEvent(type, p){
      if(type !== "takeDamage") return;
      const now = frameCount;
      const cdKey = this.id + "_cd";
      if((uniqueState[cdKey] ?? 0) > now) return;

      applyBuff(player, "armor", 30, 120, "oni_aegis", "add");
      uniqueState[cdKey] = now + 360;

      shake = Math.max(shake, 12);
      for(let i=0;i<22;i++){
        particles.push({ x:player.x, y:player.y, vx:(Math.random()-0.5)*8, vy:(Math.random()-0.5)*8, life:22 });
      }
    }
  },
  {
    id:"unique_bloodkatana",
    name:"ÌòàÍ∑ÄÏùò ÎèÑ (Blood Katana)",
    rarity:"legendary",
    desc:"ÌÉÄÍ≤© Ïãú 20% ÌôïÎ•†Î°ú Ï∂úÌòà Ïû•Ìåê ÏÉùÏÑ±(3Ï¥à). Ïû•ÌåêÏùÄ Ï¥àÎãπ ÌîºÌï¥ + Ìù°Ìòà",
    applyStat(){
      baseDamageBase *= 1.08;
      recalcFromGear();
    },
    onEvent(type, p){
      if(type !== "hit") return;
      if(Math.random() > 0.20) return;

      const x = p.enemy.x;
      const y = p.enemy.y;

      fireZones.push({
        x, y,
        radius:60,
        life:180,
        tick:0,
        damage: Math.max(2, baseDamage * 0.18),
        isBleed:true
      });
    }
  }
];

function rollRarity(){
  const t = mapTier;
  const legendary = clamp(0.004 + (t-1)*0.0003, 0.004, 0.025);
  const epic = clamp(0.03 + (t-1)*0.002, 0.03, 0.08);
  const rare = clamp(0.18 + (t-1)*0.004, 0.18, 0.32);

  const r = Math.random();
  if(r < legendary) return "legendary";
  if(r < legendary + epic) return "epic";
  if(r < legendary + epic + rare) return "rare";
  return "common";
}

function pickItemsForChoice(count=3){
  const rarity = rollRarity();

  if(rarity === "legendary"){
    const picks = [];
    let guard = 0;
    while(picks.length < count && guard++ < 200){
      const it = LEGENDARY_POOL[(Math.random()*LEGENDARY_POOL.length)|0];
      if(!it) continue;
      if(picks.some(p=>p.id===it.id)) continue;
      picks.push(it);
    }
    return picks;
  }

  const candidates = ITEM_POOL.filter(it => it.rarity === rarity);
  const fallback = ITEM_POOL;

  let picks = [];
  let guard = 0;
  while(picks.length < count && guard++ < 200){
    const src = (Math.random() < 0.85 ? candidates : fallback);
    const it = src[(Math.random()*src.length)|0];
    if(!it) continue;
    if(picks.some(p=>p.id===it.id)) continue;
    picks.push(it);
  }
  while(picks.length < count){
    const it = fallback[(Math.random()*fallback.length)|0];
    if(!picks.some(p=>p.id===it.id)) picks.push(it);
  }
  return picks;
}

function spawnLoot(x, y, source="mob"){
  if(loots.length > 25) loots.splice(0, loots.length-25);
  const choices = pickItemsForChoice(3);
  loots.push({ x, y, r: 14, ttl: 60*45, choices, taken: false, source });
}

function getNearbyLoot(){
  for(const L of loots){
    if(L.taken) continue;
    const dx = L.x - player.x;
    const dy = L.y - player.y;
    const rr = (L.r + player.radius + 18);
    if(dx*dx + dy*dy <= rr*rr) return L;
  }
  return null;
}

function openLootChoice(L){
  if(!L || L.taken) return;
  pauseGame({ dim: 0.60, blur: 2 });
  lootOverlayOpen = true;
  pendingLoot = L;

  lootOverlay.style.display = "flex";
  lootCardsEl.innerHTML = "";

  L.choices.forEach((it)=>{
    const card = document.createElement("div");
    card.className = `lootCard ${it.rarity}`;

    const ilvl = getItemLevel();
    const pick = { it, ilvl };

    if(it.rarity === "legendary"){
      pick.kind = "legendary";
      pick.shownName = it.name;
      pick.shownDesc = it.desc;
    }else{
      pick.kind = "normal";
      pick.baseData = buildBaseDataFromItemId(it.id);
      pick.affixes = rollAffixesPOE(it.rarity, ilvl);

      const affixData = makeEmptyItemData();
      for(const a of pick.affixes){
        a.affix.apply(affixData, a.value);
      }
      pick.affixData = affixData;
      pick.totalData = mergeItemData(pick.baseData, pick.affixData);

      const preNames = pick.affixes.filter(x=>x.kind==="prefix").map(x=>x.affix.name);
      const sufNames = pick.affixes.filter(x=>x.kind==="suffix").map(x=>x.affix.name);

      pick.baseName = it.name;
      pick.baseId = it.id;

      let nm = pick.baseName;
      if(preNames.length) nm = preNames.join(" ") + " " + nm;
      if(sufNames.length) nm = nm + " " + sufNames.join(" ");
      pick.name = nm;

      pick.shownName = pick.name;
      pick.shownDesc = it.descGen ? it.descGen(pick.totalData) : (it.desc || "");
    }

    card.innerHTML = `
      <div class="name">[${it.rarity.toUpperCase()}] ${pick.shownName}</div>
      <div class="desc">${pick.shownDesc}</div>
      <button type="button">Ïù¥Í±∏ ÏÑ†ÌÉù</button>
    `;

    card.querySelector("button").addEventListener("click", ()=>{
      if(pick.kind === "legendary"){
        acquireLegendary(pick.it, pick.ilvl);
      } else {
        const chosen = {
          id: pick.baseId,
          baseId: pick.baseId,
          baseName: pick.baseName,
          name: pick.name,
          rarity: pick.it.rarity,
          slot: pick.it.slot,
          ilvl: pick.ilvl,
          isUnique: false,
          data: pick.totalData,
          totalData: pick.totalData,
          baseData: pick.baseData,
          affixData: pick.affixData,
          affixes: pick.affixes,
          shownDesc: pick.shownDesc
        };
        inventory.push(chosen);
        if(panelOpen) renderAllPanels();
      }
      L.taken = true;
      closeLootChoice();
      shake = Math.max(shake, 10);
    });

    lootCardsEl.appendChild(card);
  });
}

function closeLootChoice(){
  lootOverlayOpen = false;
  pendingLoot = null;
  lootOverlay.style.display = "none";
  resumeGame();
}

function updateLoots(){
  for(let i=loots.length-1;i>=0;i--){
    const L = loots[i];
    if(L.taken){ loots.splice(i,1); continue; }
    L.ttl--;
    if(L.ttl <= 0) loots.splice(i,1);
  }
}
function drawLoots(){
  if(loots.length === 0) return;

  ctx.save();
  for(const L of loots){
    if(L.taken) continue;

    const pulse = 0.5 + 0.5*Math.sin(frameCount*0.15);
    ctx.globalAlpha = 0.75 + pulse*0.25;

    ctx.fillStyle = "rgba(80,140,255,0.25)";
    ctx.beginPath();
    ctx.arc(L.x, L.y, L.r + 10 + pulse*6, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(40,120,255,0.9)";
    ctx.beginPath();
    ctx.arc(L.x, L.y, L.r, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 1;
    ctx.fillStyle = "#fff";
    ctx.font = "bold 16px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("!", L.x, L.y+1);
  }
  ctx.restore();
}

/* ============================= */
/* ‚úÖ POEÏãù Ïû•ÎπÑ Ïä¨Î°Ø / Ïù∏Î≤§ÌÜ†Î¶¨  */
/* ============================= */
const EQUIP_SLOTS = ["weapon","helm","chest","ring"];
let equipment = { weapon:null, helm:null, chest:null, ring:null };

let inventory = [];
let selectedInvIndex = -1;

let chaosOrbs = 2;

let orbUIState = { cx:0, cy:0, centerR:24, ready:false };
let particles=[];
let bloodPools=[];
let shake=0;
let xp = 0;
let xpToNext = 120;
let level = 1;
let gameOver = false;
let orbFlash = 0;
let flashEffect = 0;

let baseDamageBase = 20;
let ultiDamageBase = 40;

let baseDamage = baseDamageBase;
let ultiDamage = ultiDamageBase;

player.gear = {
  dmgMul: 1,
  ultiMul: 1,
  spdMul: 1,
  atkSpdMul: 1,
  rangeMul: 1,
  armorAdd: 0,
  maxHpAdd: 0,
  hpRegen: 0,
  critChanceAdd: 0,
  critChanceMul: 1,
  critMultiAdd: 0,
};

function recalcFromGear(){
  baseDamage = baseDamageBase * (player.gear.dmgMul ?? 1);
  ultiDamage = ultiDamageBase * (player.gear.ultiMul ?? 1);
  updateBuffs(player);
  player.hp = Math.min(player.maxHp, player.hp);
}

function applyGearDelta(delta){
  for(const k in delta){
    const v = delta[k];
    if(typeof v !== "number") continue;
    if(k.endsWith("Mul")){
      player.gear[k] = (player.gear[k] ?? 1) * v;
    }else{
      player.gear[k] = (player.gear[k] ?? 0) + v;
    }
  }
  recalcFromGear();
}

let levelParticles = [];
let arrows = [];
let bloodParticles = [];
let fireZones = [];
let frameCount = 0;

let killCount = 0;
let killsAtLevelStart = 0;
let killsForNextLevel = 20;
let explosionActive = false;
let bossSpawned = false;
let bossTimer = 0;
let bossInterval = 45 * 60;

let mapTier = 1;
let mapSeed = 0;
let mapRun = {
  tier: 1,
  seed: 0,
  packsToClear: 10,
  clearedPacks: 0,
  bossSpawned: false,
  bossDefeated: false,
};

let portal = {
  active: false,
  x: 0,
  y: 0,
  r: 32,
  hold: 0,
  holdNeed: 25
};
let bossRoom = { x:0, y:0, w:0, h:0, cx:0, cy:0, doorX:0, doorY:0 };

/* ===== ÏûÖÎ†• ===== */
let joyDX=0, joyDY=0;
let attacking=false;
let attackFrame=0;
let keys = {};

window.addEventListener("keydown", e=>{ keys[e.key] = true; });
window.addEventListener("keyup", e=>{ keys[e.key] = false; });

const pad = document.getElementById("movePad");
const stick = document.getElementById("stick");
const attackBtn = document.getElementById("attackBtn");
let joyActive=false;

function bossDeathSound(){
  let now = audioCtx.currentTime;

  let o1 = audioCtx.createOscillator();
  let g1 = audioCtx.createGain();
  o1.type = "sawtooth";
  o1.frequency.setValueAtTime(220, now);
  o1.frequency.exponentialRampToValueAtTime(45, now + 0.6);
  g1.gain.setValueAtTime(0.25, now);
  g1.gain.exponentialRampToValueAtTime(0.001, now + 0.65);
  o1.connect(g1); g1.connect(audioCtx.destination);
  o1.start(now); o1.stop(now + 0.65);

  let o2 = audioCtx.createOscillator();
  let g2 = audioCtx.createGain();
  o2.type = "square";
  o2.frequency.setValueAtTime(900, now + 0.05);
  o2.frequency.exponentialRampToValueAtTime(180, now + 0.18);
  g2.gain.setValueAtTime(0.12, now + 0.05);
  g2.gain.exponentialRampToValueAtTime(0.001, now + 0.22);
  o2.connect(g2); g2.connect(audioCtx.destination);
  o2.start(now + 0.05); o2.stop(now + 0.22);
}

function setStickByVector(vx, vy){
  const r = pad.getBoundingClientRect();
  const max = Math.min(r.width, r.height) * 0.33;
  let d = Math.hypot(vx, vy) || 1;
  if(d > max){ vx *= max/d; vy *= max/d; }

  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;

  stick.style.left = (r.width/2 - sw/2 + vx) + "px";
  stick.style.top  = (r.height/2 - sh/2 + vy) + "px";

  joyDX = vx / max;
  joyDY = vy / max;

  if(Math.abs(vx) > Math.abs(vy))
    player.dir = vx > 0 ? "right" : "left";
  else
    player.dir = vy > 0 ? "down" : "up";
}

function handlePadMove(clientX, clientY){
  const r = pad.getBoundingClientRect();
  const cx = r.left + r.width/2;
  const cy = r.top + r.height/2;
  const vx = clientX - cx;
  const vy = clientY - cy;
  setStickByVector(vx, vy);
}

pad.addEventListener("touchstart", (e)=>{
  joyActive = true;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchmove", (e)=>{
  if(!joyActive) return;
  handlePadMove(e.touches[0].clientX, e.touches[0].clientY);
},{passive:false});

pad.addEventListener("touchend", ()=>{
  joyActive=false; joyDX=joyDY=0;
  const r = pad.getBoundingClientRect();
  const sw = stick.offsetWidth || 40;
  const sh = stick.offsetHeight || 40;
  stick.style.left = (r.width/2 - sw/2) + "px";
  stick.style.top  = (r.height/2 - sh/2) + "px";
});

/* ===== attackBtn = ÌèâÌÉÄÎßå ===== */
attackBtn.addEventListener("touchstart", ()=>{
  attacking = true;
  attackFrame = 0;
  swingSound();
  attackBtn.classList.add("active");
},{passive:true});

attackBtn.addEventListener("touchend", ()=>{
  attackBtn.classList.remove("active");
},{passive:true});

/* ===== Ïú†Ìã∏ ===== */
function rollWeaponDamage(){
  const w = player.weapon;
  return w.min + Math.random() * (w.max - w.min);
}

function getCritChance(){
  const w = player.weapon;
  const g = player.gear || {};
  let chance = (w.critChance ?? 0);
  chance += (g.critChanceAdd ?? 0);
  chance *= (g.critChanceMul ?? 1);
  return clamp(chance, 0, 0.95);
}
function getCritMulti(){
  const w = player.weapon;
  const g = player.gear || {};
  const multi = (w.critMulti ?? 1.5) + (g.critMultiAdd ?? 0);
  return Math.max(1.05, multi);
}
function applyCrit(dmg){
  const chance = getCritChance();
  const multi = getCritMulti();
  const isCrit = (Math.random() < chance);
  return { dmg: isCrit ? dmg * multi : dmg, isCrit, chance, multi };
}

function defaultBuffStats(){
  return {
    dmgMul: 1,
    spdMul: 1,
    atkSpdMul: 1,
    rangeMul: 1,
    meleeRangeMul: 1,
    aoeMul: 1,
    ultiAoeMul: 1,
    armorAdd: 0,
    armorMul: 1,
    maxHpMul: 1,
    maxHpAdd: 0,
    hpRegen: 0,
  };
}

function applyBuff(target, type, value, duration, source="", mode="mul"){
  if(!target.activeBuffs) target.activeBuffs = [];
  const key = type + "|" + source + "|" + mode;
  const b = target.activeBuffs.find(x => x.key === key);

  if(b){
    b.value = value;
    b.duration = Math.max(b.duration, duration);
  }else{
    target.activeBuffs.push({ key, type, value, duration, mode });
  }
}

function mapBuffTypeToStat(type){
  if(type === "damage")   return "dmgMul";
  if(type === "speed")    return "spdMul";
  if(type === "atkSpeed") return "atkSpdMul";
  if(type === "range")        return "rangeMul";
  if(type === "meleeRange")   return "meleeRangeMul";
  if(type === "aoe")          return "aoeMul";
  if(type === "ultiAoe")      return "ultiAoeMul";
  if(type === "armor")        return "armorAdd";
  if(type === "armorMul")     return "armorMul";
  if(type === "maxHpMul")     return "maxHpMul";
  if(type === "maxHp")        return "maxHpAdd";
  if(type === "hpRegen")      return "hpRegen";
  return null;
}

function updateBuffs(target){
  if(!target.activeBuffs) target.activeBuffs = [];
  target.buffs = defaultBuffStats();

  if(target === player){
    target.buffs.dmgMul   *= (player.gear.dmgMul ?? 1);
    target.buffs.rangeMul *= (player.gear.rangeMul ?? 1);
    target.buffs.spdMul    *= (player.gear.spdMul ?? 1);
    target.buffs.atkSpdMul *= (player.gear.atkSpdMul ?? 1);
    target.buffs.armorAdd += (player.gear.armorAdd ?? 0);
    target.buffs.maxHpAdd += (player.gear.maxHpAdd ?? 0);
    target.buffs.hpRegen  += (player.gear.hpRegen ?? 0);
  }

  for(let i = target.activeBuffs.length - 1; i >= 0; i--){
    const b = target.activeBuffs[i];
    b.duration--;
    if(b.duration <= 0){
      target.activeBuffs.splice(i,1);
      continue;
    }
    const stat = mapBuffTypeToStat(b.type);
    if(!stat) continue;

    if(b.mode === "mul"){
      if(target.buffs[stat] !== undefined) target.buffs[stat] *= b.value;
    }else if(b.mode === "add"){
      if(target.buffs[stat] !== undefined) target.buffs[stat] += b.value;
    }
  }

  if(target === player){
    const b = target.buffs;
    const newMax = Math.max(1, Math.floor(target.baseMaxHp * (b.maxHpMul ?? 1) + (b.maxHpAdd ?? 0)));
    target.maxHp = newMax;
    if(target.hp > target.maxHp) target.hp = target.maxHp;
    target.armor = Math.max(0, (target.baseArmor + (b.armorAdd ?? 0)) * (b.armorMul ?? 1));
  }
}

/* ===== Ïó¨Í∏∞ ÏïÑÎûòÎäî ÎÑàÍ∞Ä Ïò¨Î†§Ï§Ä ÏõêÎ≥∏ Î°úÏßÅ Í∑∏ÎåÄÎ°ú(Îßµ/Î™π/Ï†ÑÌà¨/Î†åÎçî) ===== */
/* NOTE: Î∏îÎûôÏä§ÌÅ¨Î¶∞ ÏõêÏù∏(Íµ¨ Ïù∏Î≤§ ÎßàÌÅ¨ÏóÖ + CSS Íπ®Ïßê + prettyItemText Ï§ÑÎ∞îÍøà Î≤ÑÍ∑∏)ÏùÑ Ï†úÍ±∞/ÏàòÏ†ïÌñàÏùå.
   ÏïÑÎûò Î°úÏßÅÏùÄ ÎÑàÎ¨¥ Í∏∏Ïñ¥ÏÑú ÏÉùÎûµÌïòÏßÄ ÏïäÍ≥† Í∑∏ÎåÄÎ°ú Ïù¥Ïñ¥Ï†∏Ïïº Ìï®. */

/* ---------------------------------------------------------------------- */
/* ÎÑàÍ∞Ä Ïò¨Î¶∞ ÏΩîÎìúÏóêÏÑú Ïó¨Í∏∞ Ïù¥ÌõÑ(Îßµ ÏÉùÏÑ±/Î™¨Ïä§ÌÑ∞/Î†åÎçî/Ìå®ÎÑê Î°úÏßÅ/loop/resetGame)
   Îäî Í∑∏ÎåÄÎ°ú Î∂ôÏó¨ÎÑ£Îêò, ÏïÑÎûò Îëê Í∞ÄÏßÄÎßå Íº≠ Ï†ÅÏö©Îèº ÏûàÏñ¥Ïïº Ìï¥:

   ‚úÖ 1) 'prettyItemText' ÎßàÏßÄÎßâ return:
      return lines.join("\\n");

   ‚úÖ 2) Íµ¨Î≤ÑÏ†Ñ Ïù∏Î≤§ HTML Î∏îÎ°ù( invHeaderSub ~ invHint )ÏùÄ ÏïÑÏòà ÏóÜÏùå.

   Ïù¥ ÌååÏùºÏùÄ Î∏îÎûôÏä§ÌÅ¨Î¶∞ ÏõêÏù∏ Ï†úÍ±∞Ïö© ‚ÄúÏ†ïÎ¶¨Î≥∏ ÌÖúÌîåÎ¶ø‚ÄùÏù¥Ïïº.
   ÎÑàÍ∞Ä ÏõêÎ≥∏ ÏΩîÎìúÏùò ÎÇòÎ®∏ÏßÄ Î∂ÄÎ∂ÑÏùÑ Ïó¨Í∏∞ ÏïÑÎûòÏóê Í∑∏ÎåÄÎ°ú Î∂ôÏó¨ÎÑ£ÏúºÎ©¥ Î∞îÎ°ú Ïã§ÌñâÎê®.
*/
/* ---------------------------------------------------------------------- */
function pruneDeadEnemies(){
  enemies = enemies.filter(e =>
    (e.hp > 0) ||
    (e.type === "boss" && e.dead && e.deathTimer > 0)
  );
  for(const p of packs){
    p.enemies = p.enemies.filter(e => e.hp > 0 || (e.type==="boss" && e.dead && e.deathTimer > 0));
  }
}

function getRandomVisibleAliveEnemy(){
  const visible = enemies.filter(e =>
    e.hp > 0 &&
    !(e.type === "boss" && e.dead) &&
    isEnemyOnScreen(e)
  );
  if(visible.length === 0) return null;
  return visible[(Math.random() * visible.length) | 0];
}

function getRandomAliveEnemy(){
  const alive = enemies.filter(e => e.hp > 0 && !(e.type === "boss" && e.dead));
  if(alive.length === 0) return null;
  return alive[(Math.random() * alive.length) | 0];
}

function getLevelPenalty(playerLv, monsterLv){
  const diff = monsterLv - playerLv;
  if(diff >= 0) return 1 + diff * 0.04;
  if(diff <= -6) return 0.1;
  return 1 + diff * 0.12;
}

/* ===== POE ÎßµÌïë: Ìã∞Ïñ¥ Ïä§ÏºÄÏùº/Îßµ ÏÉùÏÑ± ===== */
function tierScale(t){
  const hpMul  = 1 + (t-1) * 0.22;
  const dmgMul = 1 + (t-1) * 0.16;
  const spdMul = 1 + Math.min(0.25, (t-1) * 0.02);
  const eliteChance = clamp(0.06 + (t-1) * 0.008, 0.06, 0.22);
  const eliteHpMul = 2.4;
  const eliteDmgMul = 1.9;
  return { hpMul, dmgMul, spdMul, eliteChance, eliteHpMul, eliteDmgMul };
}

function giveXP(enemy){
  let base = 0;
  if(enemy.type === "mage") base = 14;
  else if(enemy.type === "archer") base = 12;
  else if(enemy.type === "melee") base = 10;
  else if(enemy.type === "boss") base = 200 * mapTier;

  if(enemy.isElite) base *= 3;
  if(enemy.isLeader) base *= 4;

  const levelMul = getLevelPenalty(level, mapTier);
  const mapMul = 1 + (mapTier - 1) * 0.08;

  const finalXP = Math.floor(base * levelMul * mapMul);
  xp += finalXP;
  checkLevelUp();
}

function makeEnemyStatsByTier(type, t){
  const s = tierScale(t);

  let baseHp, baseDmg, baseSpd;
  if(type === "mage"){
    baseHp  = 42;
    baseDmg = 9;
    baseSpd = 0.48;
  }else if(type === "archer"){
    baseHp  = 30;
    baseDmg = 14;
    baseSpd = 0.55;
  }else{
    baseHp  = 55;
    baseDmg = 11;
    baseSpd = 0.85;
  }

  return {
    hp:  baseHp  * s.hpMul,
    dmg: baseDmg * s.dmgMul,
    spd: baseSpd * s.spdMul,
    eliteChance: s.eliteChance,
    eliteHpMul: s.eliteHpMul,
    eliteDmgMul: s.eliteDmgMul
  };
}

function makeBossStatsByTier(t){
  const baseHp  = 900;
  const baseDmg = 26;
  const baseSpd = 0.62;

  const bossHp  = baseHp  * (1 + (t-1)*0.28);
  const bossDmg = baseDmg * (1 + (t-1)*0.18);
  const bossSpd = baseSpd * (1 + Math.min(0.18, (t-1)*0.015));

  return { bossHp, bossDmg, bossSpd };
}

function dist2(ax, ay, bx, by){
  const dx = ax - bx;
  const dy = ay - by;
  return dx*dx + dy*dy;
}

function srand(seed){
  let s = seed >>> 0;
  return function(){
    s = (s * 1664525 + 1013904223) >>> 0;
    return s / 4294967296;
  };
}

function clearSpawnArea(cx, cy, radiusTiles=3){
  const tx = Math.floor(cx / tileSize);
  const ty = Math.floor(cy / tileSize);
  for(let y=ty-radiusTiles; y<=ty+radiusTiles; y++){
    for(let x=tx-radiusTiles; x<=tx+radiusTiles; x++){
      if(x<=0||y<=0||x>=mapSize-1||y>=mapSize-1) continue;
      map[y][x] = 0;
    }
  }
}

function carveBossRoomAndCorridor(){
  const w = 7 + Math.floor(Math.random()*5);
  const h = 7 + Math.floor(Math.random()*5);
  const margin = 2;

  const corner = (Math.random()*4)|0;
  let x0, y0;

  if(corner===0){ x0 = mapSize - margin - w; y0 = margin; }
  if(corner===1){ x0 = margin; y0 = margin; }
  if(corner===2){ x0 = margin; y0 = mapSize - margin - h; }
  if(corner===3){ x0 = mapSize - margin - w; y0 = mapSize - margin - h; }

  for(let y=y0; y<y0+h; y++){
    for(let x=x0; x<x0+w; x++){
      map[y][x] = 0;
    }
  }

  const cx = Math.floor(mapSize/2), cy = Math.floor(mapSize/2);
  const roomCx = x0 + (w>>1), roomCy = y0 + (h>>1);

  let doorX = roomCx;
  let doorY = roomCy;

  if(Math.abs(roomCx - cx) > Math.abs(roomCy - cy)){
    if(roomCx > cx){ doorX = x0;       doorY = roomCy; }
    else           { doorX = x0+w-1;   doorY = roomCy; }
  }else{
    if(roomCy > cy){ doorY = y0;       doorX = roomCx; }
    else           { doorY = y0+h-1;   doorX = roomCx; }
  }

  map[doorY][doorX] = 0;

  const startX = Math.floor(player.x / tileSize);
  const startY = Math.floor(player.y / tileSize);

  let x = startX, y = startY;
  const stepX = doorX > x ? 1 : -1;
  while(x !== doorX){
    map[y][x] = 0;
    map[y-1] && (map[y-1][x] = 0);
    map[y+1] && (map[y+1][x] = 0);
    x += stepX;
  }
  const stepY = doorY > y ? 1 : -1;
  while(y !== doorY){
    map[y][x] = 0;
    map[y][x-1] !== undefined && (map[y][x-1] = 0);
    map[y][x+1] !== undefined && (map[y][x+1] = 0);
    y += stepY;
  }
  map[doorY][doorX] = 0;

  bossRoom = { x:x0, y:y0, w, h, cx:roomCx, cy:roomCy, doorX, doorY };
}

function buildEmptyMap(){
  map = [];
  for(let y=0; y<mapSize; y++){
    let row = [];
    for(let x=0; x<mapSize; x++){
      if(x===0 || y===0 || x===mapSize-1 || y===mapSize-1) row.push(1);
      else row.push(0);
    }
    map.push(row);
  }
}

function placeRandomWalls(rng, wallCount){
  for(let i=0;i<wallCount;i++){
    const w = 2 + Math.floor(rng()*5);
    const h = 2 + Math.floor(rng()*5);
    const x0 = 1 + Math.floor(rng()*(mapSize-2-w));
    const y0 = 1 + Math.floor(rng()*(mapSize-2-h));

    const cx = Math.floor(mapSize/2);
    const cy = Math.floor(mapSize/2);
    if(Math.abs((x0 + (w>>1)) - cx) < 4 && Math.abs((y0 + (h>>1)) - cy) < 4){
      continue;
    }

    for(let y=y0; y<y0+h; y++){
      for(let x=x0; x<x0+w; x++){
        if(x<=0||y<=0||x>=mapSize-1||y>=mapSize-1) continue;
        map[y][x] = 1;
      }
    }
  }
}

function buildReachableMaskFromPlayer(){
  const startX = Math.floor(player.x / tileSize);
  const startY = Math.floor(player.y / tileSize);

  const vis = Array.from({length: mapSize}, ()=>Array(mapSize).fill(false));
  if(!map[startY] || map[startY][startX] !== 0) return vis;

  const q = [[startX, startY]];
  vis[startY][startX] = true;

  while(q.length){
    const [x,y] = q.pop();
    const nb = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
    for(const [nx,ny] of nb){
      if(nx<=0||ny<=0||nx>=mapSize-1||ny>=mapSize-1) continue;
      if(vis[ny][nx]) continue;
      if(map[ny][nx] !== 0) continue;
      vis[ny][nx] = true;
      q.push([nx,ny]);
    }
  }
  return vis;
}

function floodFillReachableFromPlayer(){
  const startX = Math.floor(player.x / tileSize);
  const startY = Math.floor(player.y / tileSize);
  if(!map[startY] || map[startY][startX] !== 0) return 0;

  const vis = Array.from({length: mapSize}, ()=>Array(mapSize).fill(false));
  const q = [[startX,startY]];
  vis[startY][startX] = true;
  let count = 0;

  while(q.length){
    const [x,y] = q.pop();
    count++;
    const nb = [[x+1,y],[x-1,y],[x,y+1],[x,y-1]];
    for(const [nx,ny] of nb){
      if(nx<=0||ny<=0||nx>=mapSize-1||ny>=mapSize-1) continue;
      if(vis[ny][nx]) continue;
      if(map[ny][nx] !== 0) continue;
      vis[ny][nx] = true;
      q.push([nx,ny]);
    }
  }
  return count;
}

function generateRandomMapForTier(tier){
  const seed = (Date.now() ^ (tier*987654321)) >>> 0;
  const rng = srand(seed);

  for(let attempt=0; attempt<8; attempt++){
    buildEmptyMap();

    const wallCount = 22 + Math.floor(tier*2.2) + Math.floor(rng()*10);
    placeRandomWalls(rng, wallCount);

    clearSpawnArea(player.x, player.y, 3);

    const reachable = floodFillReachableFromPlayer();
    const totalFloor = (mapSize-2)*(mapSize-2);
    if(reachable / totalFloor >= 0.55){
      return seed;
    }
  }
  buildEmptyMap();
  clearSpawnArea(player.x, player.y, 4);
  return seed;
}

function startNewMap(nextTier){
  mapTier = nextTier;
  mapRun.tier = nextTier;
  mapRun.clearedPacks = 0;
  mapRun.bossSpawned = false;
  mapRun.bossDefeated = false;

  mapRun.packsToClear = 8 + Math.floor(nextTier * 1.5);

  portal.active = false;
  portal.hold = 0;

  enemies = [];
  packs = [];
  particles = [];
  bloodPools = [];
  bloodParticles = [];
  arrows = [];
  levelParticles = [];
  fireZones = [];

  spawnTimer = 0;
  spawnInterval = 999999;
  bossTimer = 0;

  player.x = mapSize * tileSize / 2;
  player.y = mapSize * tileSize / 2;

  mapRun.seed = generateRandomMapForTier(nextTier);
  carveBossRoomAndCorridor();
  reachableMask = buildReachableMaskFromPlayer();

  spawnMapPacks(nextTier);
  spawnRandomBoss();

  resize();
}

function spawnMapPacks(tier){
  const rng = srand(mapRun.seed ^ 0xA53C9E1B);

  const packCount = mapRun.packsToClear + 4 + Math.floor(tier*0.6);
  for(let i=0;i<packCount;i++){
    let placed = false;

    for(let tries=0; tries<120; tries++){
      const tx = 1 + Math.floor(rng()*(mapSize-2));
      const ty = 1 + Math.floor(rng()*(mapSize-2));
      if(map[ty][tx] !== 0) continue;
      if(reachableMask && !reachableMask[ty][tx]) continue;

      const px = tx*tileSize + tileSize/2;
      const py = ty*tileSize + tileSize/2;

      const dx = px - player.x, dy = py - player.y;
      if(dx*dx + dy*dy < 260*260) continue;

      let min = 25;
      let max = 32;
      if(tier >= 6){
        min = 28 + Math.floor((tier-5) * 0.4);
        max = 36 + Math.floor((tier-5) * 0.6);
      }
      if(tier >= 12){
        min = 30 + Math.floor((tier-10) * 0.5);
        max = 40 + Math.floor((tier-10) * 0.7);
      }
      max = Math.min(max, 45);

      const count = min + Math.floor(rng() * (max - min + 1));
      createPack(px, py, count);

      placed = true;
      break;
    }
    if(!placed){
      // skip
    }
  }

  for(const p of packs){
    p.cleared = false;
  }
  linkNearbyPacks();
}

function linkNearbyPacks(){
  const linkDist = 360;
  const link2 = linkDist * linkDist;

  const n = packs.length;
  const parent = Array.from({length:n}, (_,i)=>i);
  const find = (a)=>{ while(parent[a]!==a){ parent[a]=parent[parent[a]]; a=parent[a]; } return a; };
  const union = (a,b)=>{ a=find(a); b=find(b); if(a!==b) parent[b]=a; };

  for(let i=0;i<n;i++){
    for(let j=i+1;j<n;j++){
      const dx = packs[i].x - packs[j].x;
      const dy = packs[i].y - packs[j].y;
      if(dx*dx + dy*dy <= link2) union(i,j);
    }
  }

  const rootToG = new Map();
  let gid = 0;

  for(let i=0;i<n;i++){
    const r = find(i);
    if(!rootToG.has(r)) rootToG.set(r, gid++);
    packs[i].groupId = rootToG.get(r);
    packs[i].groupCleared = false;
  }
}

function activatePackGroup(groupId){
  for(const p of packs){
    if(p.groupId === groupId){
      p.activated = true;
      if(p.enemies.length === 0 && !p.cleared){
        p.cleared = true;
      }
    }
  }
}

function spawnPortal(x, y){
  portal.active = true;
  portal.x = x;
  portal.y = y;
  portal.hold = 0;

  for(let i=0;i<90;i++){
    const a = Math.random()*Math.PI*2;
    const sp = 1 + Math.random()*5;
    particles.push({
      x: x + (Math.random()-0.5)*10,
      y: y + (Math.random()-0.5)*10,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp,
      life: 30 + Math.floor(Math.random()*25)
    });
  }
}

function updatePortal(){
  if(!portal.active) return;

  const dx = player.x - portal.x;
  const dy = player.y - portal.y;
  const rr = (portal.r + player.radius + 8);
  if(dx*dx + dy*dy < rr*rr){
    portal.hold++;
    if(portal.hold >= portal.holdNeed){
      startNewMap(mapTier + 1);
      return;
    }
  }else{
    portal.hold = 0;
  }
}

function drawPortal(){
  if(!portal.active) return;

  const pulse = 0.6 + 0.4*Math.sin(frameCount*0.15);
  const r = portal.r + pulse*6;

  ctx.save();
  ctx.globalAlpha = 0.9;

  ctx.strokeStyle = "rgba(120,180,255,0.85)";
  ctx.lineWidth = 4;
  ctx.beginPath();
  ctx.arc(portal.x, portal.y, r, 0, Math.PI*2);
  ctx.stroke();

  ctx.fillStyle = "rgba(80,140,255,0.18)";
  ctx.beginPath();
  ctx.arc(portal.x, portal.y, r-6, 0, Math.PI*2);
  ctx.fill();

  if(portal.hold > 0){
    const t = clamp(portal.hold / portal.holdNeed, 0, 1);
    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.arc(portal.x, portal.y, r+8, -Math.PI/2, -Math.PI/2 + Math.PI*2*t);
    ctx.stroke();
  }

  ctx.restore();
}

function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }

function spawnHitBlood(x, y, amount=10){
  if(bloodParticles.length > 320) return;

  for(let i=0;i<amount;i++){
    bloodParticles.push({
      x: x + (Math.random()-0.5)*6,
      y: y + (Math.random()-0.5)*6,
      vx: (Math.random()-0.5) * 6,
      vy: (Math.random()-0.5) * 6,
      size: Math.random()*3 + 1.5,
      life: 22
    });
  }

  if(bloodPools.length < 140){
    bloodPools.push({
      x: x + (Math.random()-0.5)*8,
      y: y + (Math.random()-0.5)*8,
      size: 5 + Math.random()*4,
      life: 280
    });
  }
}

function startBossDeath(boss){
  if(boss.dead) return;
  if(!boss.xpGiven){
    boss.xpGiven = true;
    giveXP(boss);
  }
  boss.dead = true;
  boss.deathTimer = 60;
  boss.deathMax = 60;

  shake = Math.max(shake, 60);
  slowMotion = Math.max(slowMotion, 10);

  spawnHitBlood(boss.x, boss.y, 40);

  for(let i=0;i<140;i++){
    const a = Math.random()*Math.PI*2;
    const sp = 2 + Math.random()*8;
    particles.push({
      x: boss.x + (Math.random()-0.5)*10,
      y: boss.y + (Math.random()-0.5)*10,
      vx: Math.cos(a)*sp,
      vy: Math.sin(a)*sp - (Math.random()*2),
      life: 45 + Math.floor(Math.random()*25)
    });
  }

  if(bloodPools.length < 140){
    bloodPools.push({
      x: boss.x,
      y: boss.y,
      size: 26,
      life: 900
    });
  }

  spawnLoot(boss.x, boss.y, "boss");
  chaosOrbs++;
  bossDeathSound();
}

function canMoveTo(x,y){
  let left = Math.floor((x - player.radius) / tileSize);
  let right = Math.floor((x + player.radius) / tileSize);
  let top = Math.floor((y - player.radius) / tileSize);
  let bottom = Math.floor((y + player.radius) / tileSize);

  return (
    map[top] && map[top][left] === 0 &&
    map[top] && map[top][right] === 0 &&
    map[bottom] && map[bottom][left] === 0 &&
    map[bottom] && map[bottom][right] === 0
  );
}
function canEnemyMoveTo(enemy, x, y){
  let left = Math.floor((x - enemy.radius) / tileSize);
  let right = Math.floor((x + enemy.radius) / tileSize);
  let top = Math.floor((y - enemy.radius) / tileSize);
  let bottom = Math.floor((y + enemy.radius) / tileSize);

  return (
    map[top] && map[top][left] === 0 &&
    map[top] && map[top][right] === 0 &&
    map[bottom] && map[bottom][left] === 0 &&
    map[bottom] && map[bottom][right] === 0
  );
}
function isFloorTile(tx, ty){ return !!(map[ty] && map[ty][tx] === 0); }
function canSpawnEnemyAt(enemy, x, y){ return canEnemyMoveTo(enemy, x, y); }

function resolvePlayerEnemyOverlap(){
  const pad = 2;
  for(const e of enemies){
    if(e.type === "boss" && e.dead) continue;
    if(e.hp <= 0) continue;
    if(e.pack && !e.pack.activated) continue;

    let dx = e.x - player.x;
    let dy = e.y - player.y;
    let dist = Math.hypot(dx, dy);

    const minDist = player.radius + e.radius + pad;

    if(dist === 0){
      dx = (Math.random() - 0.5) * 0.01;
      dy = (Math.random() - 0.5) * 0.01;
      dist = Math.hypot(dx, dy);
    }

    if(dist < minDist){
      const nx = dx / dist;
      const ny = dy / dist;
      const push = (minDist - dist);

      const ex = e.x + nx * push;
      const ey = e.y + ny * push;

      if(canEnemyMoveTo(e, ex, ey)){
        e.x = ex; e.y = ey;
      }else{
        const px = player.x - nx * push;
        const py = player.y - ny * push;
        if(canMoveTo(px, player.y)) player.x = px;
        if(canMoveTo(player.x, py)) player.y = py;
      }
    }
  }
}

function damagePlayer(dmg, knockX, knockY){
  if(player.invul > 0 || gameOver) return;

  const armor = (player.armor ?? 0);
  const reduced = dmg * (50 / (50 + Math.max(0, armor)));
  const finalDmg = Math.max(1, Math.floor(reduced));

  player.hp -= finalDmg;
  emitEvent("takeDamage", { dmg: finalDmg });
  player.invul = 25;
  shake = Math.max(shake, 10);

  let nx = player.x + knockX;
  let ny = player.y + knockY;

  if(canMoveTo(nx, player.y)) player.x = nx;
  if(canMoveTo(player.x, ny)) player.y = ny;

  if(player.hp <= 0) handleGameOver();
}

function enemyTryMeleeAttack(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);
  const reach = e.type === "boss" ? 70 : 42;

  if(dist > reach){
    e.attackFrame = 0;
    return;
  }

  if(e.attackFrame === 0){
    e.swingDir = dx < 0 ? -1 : 1;
  }

  const atkMul = (e.buffs?.atkSpdMul ?? 1);
  e.attackFrame += atkMul;

  if(e.attackFrame >= 12 && !e.hitDone){
    e.hitDone = true;
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;
    const kb = e.type === "boss" ? 30 : 18;
    damagePlayer(e.damage, nx*kb, ny*kb);
    hitSound();
  }

  if(e.attackFrame >= 25){
    e.attackFrame = 0;
    e.hitDone = false;
  }
}

function spawnArrow(fromX, fromY, toX, toY, damage){
  const dx = toX - fromX;
  const dy = toY - fromY;
  const dist = Math.hypot(dx, dy) || 1;
  const speed = 7.5;

  arrows.push({
    x: fromX,
    y: fromY,
    dx: dx/dist * speed,
    dy: dy/dist * speed,
    damage,
    life: 240
  });
}

function spawnFireZone(x, y, damage){
  fireZones.push({ x, y, radius:55, life:180, tick:0, damage });
}

function spawnEnemyAt(ex, ey, pack){
  let tileX = Math.floor(ex / tileSize);
  let tileY = Math.floor(ey / tileSize);

  if(!isFloorTile(tileX, tileY)) return;
  if(!isFloorTile(tileX-1, tileY) || !isFloorTile(tileX+1, tileY) || !isFloorTile(tileX, tileY-1) || !isFloorTile(tileX, tileY+1)) return;
  if(enemies.length >= 320) return;

  let rand = Math.random();
  let type = rand < 0.2 ? "mage" : rand < 0.5 ? "archer" : "melee";

  const st = makeEnemyStatsByTier(type, mapTier);

  let enemy = {
    x: ex, y: ey,
    radius: 14,
    stun: 0,
    invul: 0,
    attackFrame: 0,
    swingDir: 1,
    type,
    hp: st.hp,
    speed: st.spd,
    damage: st.dmg,
    shootCooldown: 0,
    castCooldown: 120,
    pack
  };

  if(!canSpawnEnemyAt(enemy, ex, ey)) return;

  if(Math.random() < st.eliteChance * 0.85){
    enemy.isElite = true;
    enemy.eliteColor = Math.random() < 0.5 ? "yellow" : "blue";
    enemy.speed *= 1.5;
    enemy.damage *= st.eliteDmgMul;
    enemy.radius *= 1.2;
    enemy.hp *= st.eliteHpMul;
  }

  enemies.push(enemy);
  pack.enemies.push(enemy);
}

function spawnPackLeaderAt(ex, ey, pack){
  const st = makeEnemyStatsByTier("melee", mapTier);

  let leader = {
    x: ex, y: ey,
    radius: 18,
    stun: 0,
    invul: 0,
    attackFrame: 0,
    swingDir: 1,
    type: "melee",
    hp: st.hp * 3.2,
    speed: st.spd * 1.08,
    damage: st.dmg * 1.6,
    shootCooldown: 0,
    castCooldown: 120,
    pack,
    isLeader: true
  };

  if(!canSpawnEnemyAt(leader, ex, ey)) return;

  enemies.push(leader);
  pack.enemies.push(leader);
}

function spawnRandomBoss(){
  if(enemies.some(e => e.type === "boss")) return;

  const bx = bossRoom.cx * tileSize + tileSize/2;
  const by = bossRoom.cy * tileSize + tileSize/2;

  const tempBoss = { radius: 30 };
  if(!canEnemyMoveTo(tempBoss, bx, by)) return;

  const bst = makeBossStatsByTier(mapTier);

  enemies.push({
    x: bx, y: by,
    radius: 30,
    type: "boss",
    maxHp: bst.bossHp,
    hp: bst.bossHp,
    speed: bst.bossSpd,
    damage: bst.bossDmg,
    stun: 0,
    attackFrame: 0,
    swordPulled: false,
    phase2Used: false,
    dashCooldown: 120,
    cleaveCooldown: 160,
    invul: 0,
    phaseLock: 0
  });
}

function createPack(cx, cy, count){
  let pack = {
    x: cx, y: cy,
    enemies: [],
    activated: false,
    cleared: false,
    groupId: -1,
    groupCleared: false
  };

  spawnPackLeaderAt(cx, cy, pack);

  const normalCount = Math.max(0, count - 1);
  let tries = 0;

  while(pack.enemies.length < (normalCount + 1) && tries < count * 8){
    tries++;
    let angle = Math.random()*Math.PI*2;
    let radius = Math.random()*140;
    let ex = cx + Math.cos(angle)*radius;
    let ey = cy + Math.sin(angle)*radius;
    spawnEnemyAt(ex, ey, pack);
  }

  packs.push(pack);
}

/* ===== Í∂ÅÍ∑πÍ∏∞ ===== */
function teleportTo(target){
  spawnHitBlood(player.x, player.y, 18);
  if(particles.length < 220){
    for(let i=0;i<10;i++){
      particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 22 });
    }
  }

  if(canMoveTo(target.x, target.y)){
    player.x = target.x;
    player.y = target.y;
  }

  spawnHitBlood(player.x, player.y, 22);
  if(particles.length < 220){
    for(let i=0;i<12;i++){
      particles.push({ x: player.x, y: player.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 26 });
    }
  }

  shake = Math.max(shake, 10);
}

/* ===== Î≥¥Ïä§ Ïä§ÌÇ¨ ===== */
function bossEnterPhase2(boss){
  boss.swordPulled = true;
  boss.phase2Used = true;
  boss.speed *= 1.25;
  boss.damage *= 1.2;

  boss.invul = 120;
  boss.phaseLock = 36;

  shake = 30;
  bossUnsheatheSound();

  for(let i=0;i<80;i++){
    particles.push({ x: boss.x, y: boss.y, vx: (Math.random()-0.5)*10, vy: (Math.random()-0.5)*10, life: 50 });
  }
}

function bossDash(boss){
  const dx = player.x - boss.x;
  const dy = player.y - boss.y;
  const dist = Math.hypot(dx, dy) || 1;
  const nx = dx / dist;
  const ny = dy / dist;

  const dashDist = 220;
  const steps = 18;
  let hit = false;

  for(let i=0;i<steps;i++){
    let px = boss.x + nx * (dashDist/steps);
    let py = boss.y + ny * (dashDist/steps);

    if(canEnemyMoveTo(boss, px, py)){
      boss.x = px; boss.y = py;
    }else break;

    if(!hit){
      const d = Math.hypot(player.x - boss.x, player.y - boss.y);
      if(d < boss.radius + player.radius + 10){
        damagePlayer(boss.damage*1.2, nx*34, ny*34);
        hit = true;
      }
    }
  }
  shake = Math.max(shake, 16);
}

function bossCleave(boss){
  const radius = 140;

  for(let i=0;i<70;i++){
    const a = Math.random()*Math.PI*2;
    const r = Math.random()*radius;
    particles.push({
      x: boss.x + Math.cos(a)*r,
      y: boss.y + Math.sin(a)*r,
      vx: Math.cos(a)*2 + (Math.random()-0.5)*2,
      vy: Math.sin(a)*2 + (Math.random()-0.5)*2,
      life: 35
    });
  }

  const dist = Math.hypot(player.x - boss.x, player.y - boss.y);
  if(dist < radius){
    const dx = player.x - boss.x;
    const dy = player.y - boss.y;
    const len = Math.hypot(dx, dy) || 1;
    damagePlayer(boss.damage*1.6, (dx/len)*42, (dy/len)*42);
  }
  shake = Math.max(shake, 22);
}

function isEnemyOnScreen(e){
  const camX = player.x - canvas.width/2;
  const camY = player.y - canvas.height/2;

  const screenLeft   = camX - 50;
  const screenRight  = camX + canvas.width + 50;
  const screenTop    = camY - 50;
  const screenBottom = camY + canvas.height + 50;

  return (
    e.x > screenLeft &&
    e.x < screenRight &&
    e.y > screenTop &&
    e.y < screenBottom
  );
}

/* ===== ÏóÖÎç∞Ïù¥Ìä∏ ===== */
function update(){
  frameCount++;

  if(lootOverlayOpen) return;
  if(gameOver) return;

  if(slowMotion > 0){
    slowMotion--;
    updateEnemySystem();
    resolvePlayerEnemyOverlap();
    updateEffectSystem();
    return;
  }

  updateBuffs(player);
  updatePlayerState();
  updateUltimateSystem();
  updateEnemySystem();
  resolvePlayerEnemyOverlap();
  updateCombatSystem();
  updateProjectileSystem();
  updateEffectSystem();
  updateEnvironmentSystem();

  updatePortal();
}

function updatePlayerState(){
  if(player.hp <= 0){ handleGameOver(); return; }
  updateMovement();
  updateInvulnerability();
  updateLevelGlow();

  const regen = (player.buffs?.hpRegen ?? 0) / 60;
  if(regen > 0) player.hp = Math.min(player.maxHp, player.hp + regen);
}
function handleGameOver(){
  gameOver = true;
  document.getElementById("ui").style.display = "none";
}
function updateLevelGlow(){
  if(player.levelGlow > 0) player.levelGlow--;
}

function updateUltimateSystem(){
  if(!player.ultiActive) return;

  player.ultiTimer++;
  if(player.ultiTimer % 10 === 0) performUltimateStrike();
  if(player.ultiCount >= 5) endUltimate();
}
function endUltimate(){
  player.ultiActive = false;
  player.ultiTimer = 0;
  player.ultiCount = 0;
  explosionActive = false;
}
function performUltimateStrike(){
  const target = getRandomVisibleAliveEnemy();
  if(!target) { endUltimate(); return; }

  teleportTo(target);
  dealUltimateDamage();

  pruneDeadEnemies();
  player.ultiCount++;
}

function dealUltimateDamage(){
  const radius = getUltiAoeRadius();
  const r2 = radius * radius;
  let killedAny = false;

  for(let i=0; i<enemies.length; i++){
    const e = enemies[i];
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    if(dx*dx + dy*dy > r2) continue;

    if(e.type === "boss" && e.dead) continue;

    const wasAlive = (e.hp > 0);
    if(!wasAlive) continue;

    const weaponBase = rollWeaponDamage();
    const raw =
      weaponBase * 2.8 *
      (player.gear?.ultiMul ?? 1) *
      (player.buffs?.dmgMul ?? 1);

    const crit = applyCrit(raw);
    const dealt = crit.dmg;

    if(e.type === "boss"){
      if(e.invul <= 0){
        e.hp -= dealt;
        e.stun = 25;
        spawnHitBlood(e.x, e.y, crit.isCrit ? 26 : 14);
        shake = Math.max(shake, 20);
        if(e.hp <= 0){
          startBossDeath(e);
        }
      }
      continue;
    }

    e.hp -= dealt;
    e.stun = 30;

    spawnHitBlood(e.x, e.y, crit.isCrit ? 22 : 12);

    if(particles.length < 240){
      for(let k=0;k<10;k++){
        particles.push({ x: e.x, y: e.y, vx: (Math.random()-0.5)*9, vy: (Math.random()-0.5)*9, life: 34 });
      }
    }

    if(e.hp <= 0){
      emitEvent("kill", { enemy:e, x:e.x, y:e.y, type:e.type });
      spawnLoot(e.x, e.y, "ulti");
      giveXP(e);

      player.hp = Math.min(player.maxHp, player.hp + 1);
      slowMotion = 6;
      if(player.kiOrbs < player.maxOrbs) player.kiOrbs++;
      killedAny = true;
    }
  }

  if(killedAny) hitSound();
  shake = Math.max(shake, 30);
  pruneDeadEnemies();
}

function updateEnemySystem(){
  packs.forEach(pack=>{
    if(pack.activated) return;
    const dx = pack.x - player.x;
    const dy = pack.y - player.y;
    if(dx*dx + dy*dy < 520*520){
      activatePackGroup(pack.groupId);
      shake = Math.max(shake, 8);
      slowMotion = Math.max(slowMotion, 1);
    }
  });

  enemies.forEach(e=>{
    if(e.pack && !e.pack.activated) return;
    updateSingleEnemy(e);
  });
  for(const e of enemies){
    updateBuffs(e);
  }
  pruneDeadEnemies();
}

function updateLevelParticles(){
  for(let i = levelParticles.length - 1; i >= 0; i--){
    const p = levelParticles[i];
    p.ox += p.vx;
    p.oy -= p.vy;
    p.vy *= 0.97;
    p.life--;
    if(p.life <= 0) levelParticles.splice(i,1);
  }
  if(levelParticles.length > 200){
    levelParticles.splice(0, levelParticles.length - 200);
  }
}

function updateParticles(){
  for(let i = particles.length - 1; i >= 0; i--){
    const p = particles[i];
    p.x += p.vx; p.y += p.vy; p.life--;
    if(p.life <= 0) particles.splice(i,1);
  }
  if(particles.length > 260){
    particles.splice(0, particles.length - 260);
  }
}

function updateMelee(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  if(dist > 0){
    let moveX = dx / dist * e.speed;
    let moveY = dy / dist * e.speed;

    let newX = e.x + moveX;
    let newY = e.y + moveY;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }

  enemyTryMeleeAttack(e);
}

function updateArcher(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  const desired = 240;
  if(dist < desired - 40){
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;

    const newX = e.x - nx * e.speed * 1.2;
    const newY = e.y - ny * e.speed * 1.2;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }else if(dist > desired + 80){
    updateMelee(e);
  }

  e.shootCooldown--;
  if(e.shootCooldown <= 0 && dist < 520){
    spawnArrow(e.x, e.y, player.x, player.y, e.damage);
    e.shootCooldown = 80 + Math.floor(Math.random()*40);
  }
}

function updateMage(e){
  const dx = player.x - e.x;
  const dy = player.y - e.y;
  const dist = Math.hypot(dx, dy);

  if(dist < 180){
    const len = dist || 1;
    const nx = dx / len;
    const ny = dy / len;

    const newX = e.x - nx * e.speed * 1.4;
    const newY = e.y - ny * e.speed * 1.4;

    if(canEnemyMoveTo(e, newX, e.y)) e.x = newX;
    if(canEnemyMoveTo(e, e.x, newY)) e.y = newY;
  }else{
    updateMelee(e);
  }

  e.castCooldown--;
  if(e.castCooldown <= 0 && dist < 520){
    spawnFireZone(player.x, player.y, e.damage);
    e.castCooldown = 140 + Math.floor(Math.random()*50);
  }
}

function updateBoss(e){
  if(!e.phase2Used && e.hp <= e.maxHp * 0.5) bossEnterPhase2(e);
  updateMelee(e);

  if(e.swordPulled){
    e.dashCooldown--;
    e.cleaveCooldown--;

    const dist = Math.hypot(player.x - e.x, player.y - e.y);

    if(e.dashCooldown <= 0 && dist > 160 && dist < 520){
      bossDash(e);
      e.dashCooldown = 160 + Math.floor(Math.random()*70);
    }
    if(e.cleaveCooldown <= 0 && dist < 220){
      bossCleave(e);
      e.cleaveCooldown = 200 + Math.floor(Math.random()*80);
    }
  }
}

function updateSingleEnemy(e){
  if(e.isLeader){
    const radius = 50;
    const r2 = radius * radius;

    for(const other of enemies){
      if(other === e) continue;
      const dx = other.x - e.x;
      const dy = other.y - e.y;
      if(dx*dx + dy*dy <= r2){
        applyBuff(other, "damage",   1.25, 15, "leader");
        applyBuff(other, "atkSpeed", 1.2,  15, "leader");
      }
    }
  }

  if(e.type === "boss" && e.dead){
    e.deathTimer--;

    if(e.deathTimer % 10 === 0){
      shake = Math.max(shake, 10);
      spawnHitBlood(
        e.x + (Math.random()-0.5)*12,
        e.y + (Math.random()-0.5)*12,
        10
      );
    }

    if(e.deathTimer === 1 && !mapRun.bossDefeated){
      mapRun.bossDefeated = true;
      spawnPortal(e.x, e.y);
    }

    return;
  }

  if(e.invul > 0) e.invul--;

  if(e.phaseLock > 0){
    e.phaseLock--;
    return;
  }

  if(e.stun > 0){
    e.stun--;
    return;
  }

  switch(e.type){
    case "archer": updateArcher(e); break;
    case "mage": updateMage(e); break;
    case "boss": updateBoss(e); break;
    default: updateMelee(e);
  }
}

function updateProjectileSystem(){
  updateArrows();
  updateFireZones();
}

function updateFireZones(){
  for(let i = fireZones.length - 1; i >= 0; i--){
    const f = fireZones[i];
    f.life--;
    f.tick++;

    if(f.tick % 10 === 0){

      if(f.isBleed){
        let hitCount = 0;

        for(const e of enemies){
          if(e.hp <= 0) continue;
          if(e.type === "boss" && e.dead) continue;

          const dx = e.x - f.x;
          const dy = e.y - f.y;
          if(dx*dx + dy*dy > f.radius*f.radius) continue;

          const dealt = f.damage;

          if(e.type === "boss"){
            if(e.invul <= 0 && !e.dead){
              e.hp -= dealt;
              if(e.hp <= 0) startBossDeath(e);
            }
          }else{
            e.hp -= dealt;
            if(e.hp <= 0){
              emitEvent("kill", { enemy:e, x:e.x, y:e.y, type:e.type });
              spawnLoot(e.x, e.y, "bleed");
              giveXP(e);
            }
          }

          player.hp = Math.min(player.maxHp, player.hp + dealt * 0.12);
          spawnHitBlood(e.x, e.y, 3);

          hitCount++;
          if(hitCount >= 10) break;
        }

        pruneDeadEnemies();

      }else{
        const dx = player.x - f.x;
        const dy = player.y - f.y;
        if(dx*dx + dy*dy < f.radius*f.radius){
          damagePlayer(f.damage, 0, 0);
        }
      }
    }

    if(f.life <= 0){
      fireZones.splice(i,1);
    }
  }
}

function updateEffectSystem(){
  updateParticles();
  updateBlood();
  updateLevelParticles();

  for(let i=bloodPools.length-1;i>=0;i--){
    bloodPools[i].life--;
    if(bloodPools[i].life <= 0) bloodPools.splice(i,1);
  }
  if(bloodPools.length > 120) bloodPools.splice(0, bloodPools.length-120);

  updateLoots();
}

function updateCombatSystem(){
  if(attacking){
    attackFrame++;
    if(attackFrame === 3) checkHit();
    if(attackFrame > 8){
      attacking = false;
      attackFrame = 0;
    }
  }
}

function updateMovement(){
  const moveSpeed = player.speed * (player.buffs?.spdMul ?? 1);
  let dx = 0;
  let dy = 0;

  if(keys["ArrowLeft"] || keys["a"]) dx -= moveSpeed;
  if(keys["ArrowRight"] || keys["d"]) dx += moveSpeed;
  if(keys["ArrowUp"] || keys["w"]) dy -= moveSpeed;
  if(keys["ArrowDown"] || keys["s"]) dy += moveSpeed;

  dx += joyDX * moveSpeed;
  dy += joyDY * moveSpeed;

  if(Math.abs(dx) > Math.abs(dy)){
    if(dx > 0) player.dir = "right";
    else if(dx < 0) player.dir = "left";
  }else{
    if(dy > 0) player.dir = "down";
    else if(dy < 0) player.dir = "up";
  }

  let newX = player.x + dx;
  let newY = player.y + dy;

  if(canMoveTo(newX, player.y)) player.x = newX;
  if(canMoveTo(player.x, newY)) player.y = newY;
}

function updateInvulnerability(){
  if(player.invul > 0) player.invul--;
}

function updateEnvironmentSystem(){ updateShake(); }
function updateShake(){ if(shake > 0) shake--; }

function updateArrows(){
  for(let i = arrows.length - 1; i >= 0; i--){
    const a = arrows[i];
    a.x += a.dx;
    a.y += a.dy;
    a.life--;

    const tx = Math.floor(a.x / tileSize);
    const ty = Math.floor(a.y / tileSize);
    if(!map[ty] || map[ty][tx] === 1){
      arrows.splice(i,1);
      continue;
    }

    const px = player.x, py = player.y;
    const dxp = a.x - px;
    const dyp = a.y - py;
    const rr = (player.radius + 4);
    if(dxp*dxp + dyp*dyp < rr*rr){
      const dx = px - a.x;
      const dy = py - a.y;
      const len = Math.hypot(dx, dy) || 1;
      damagePlayer(a.damage, (dx/len)*14, (dy/len)*14);
      arrows.splice(i,1);
      continue;
    }

    if(a.life <= 0){
      arrows.splice(i,1);
      continue;
    }
  }
}

/* ===== Î†àÎ≤®ÏóÖ ===== */
function levelUpSound(){
  let o = audioCtx.createOscillator();
  let g = audioCtx.createGain();

  o.type = "triangle";
  o.frequency.setValueAtTime(400, audioCtx.currentTime);
  o.frequency.exponentialRampToValueAtTime(900, audioCtx.currentTime + 0.3);

  g.gain.setValueAtTime(0.3, audioCtx.currentTime);
  g.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.3);

  o.connect(g);
  g.connect(audioCtx.destination);

  o.start();
  o.stop(audioCtx.currentTime + 0.3);
}

function checkLevelUp(){
  if(xp >= xpToNext){
    xp -= xpToNext;
    level++;

    xpToNext = Math.floor(100 + level * level * 20);

    player.baseMaxHp += 12;
    updateBuffs(player);
    player.hp = player.maxHp;

    baseDamageBase *= 1.08;
    ultiDamageBase *= 1.1;
    recalcFromGear();

    player.levelGlow = 60;

    for(let i=0;i<60;i++){
      levelParticles.push({
        ox:(Math.random()-0.5)*40,
        oy:-40+(Math.random()-0.5)*10,
        vx:(Math.random()-0.5)*2,
        vy:Math.random()*3+2,
        life:60
      });
    }

    levelUpSound();
  }
}

/* ===== Í≥µÍ≤© Î≤îÏúÑ ===== */
const BASE_MELEE_RANGE = 40;
const BASE_ULTI_AOE    = 40;

function getMeleeRange(){
  const b = player.buffs || defaultBuffStats();
  return BASE_MELEE_RANGE * (b.rangeMul ?? 1);
}
function getUltiAoeRadius(){
  const b = player.buffs || defaultBuffStats();
  return BASE_ULTI_AOE * (b.rangeMul ?? 1);
}

/* ===== Í≥µÍ≤© ===== */
function checkHit(){
  const range = getMeleeRange();
  const hitLimit = 12;
  let hitDone = 0;

  for(let i=0;i<enemies.length;i++){
    const e = enemies[i];

    const dx = e.x - player.x;
    const dy = e.y - player.y;

    const r = range + e.radius;
    if(dx*dx + dy*dy > r*r) continue;

    if(player.dir === "up" && dy >= 0) continue;
    if(player.dir === "down" && dy <= 0) continue;
    if(player.dir === "right" && dx <= 0) continue;
    if(player.dir === "left" && dx >= 0) continue;

    hitDone++;
    if(hitDone > hitLimit) break;

    const len = Math.hypot(dx, dy) || 1;
    const nx = dx / len;
    const ny = dy / len;

    let weaponBase = rollWeaponDamage();
    let raw =
      weaponBase
      * (player.gear?.dmgMul ?? 1)
      * (player.buffs?.dmgMul ?? 1);

    const crit = applyCrit(raw);
    let dealt = crit.dmg;

    const bossInvul = (e.type === "boss" && e.invul > 0);

    if(e.invul <= 0){
      e.hp -= dealt;
    }
    emitEvent("hit", { enemy: e, dealt });

    const heal = dealt * 0.05;
    player.hp = Math.min(player.maxHp, player.hp + heal);

    if(Math.random() < 0.2 && player.kiOrbs < player.maxOrbs){
      player.kiOrbs++;
    }

    if(bossInvul){
      spawnHitBlood(e.x, e.y, 14);
    }else{
      e.stun = 15;
      let ex = e.x + nx*18;
      let ey = e.y + ny*18;
      if(canEnemyMoveTo(e, ex, e.y)) e.x = ex;
      if(canEnemyMoveTo(e, e.x, ey)) e.y = ey;
    }

    if(bossInvul) thudSound();
    else hitSound();

    shake = 12;

    if(particles.length < 220){
      particles.push({
        x: e.x, y: e.y,
        vx: nx*4 + (Math.random()-0.5)*4,
        vy: ny*4 + (Math.random()-0.5)*4,
        life: 30
      });
    }

    if(e.hp <= 0){
      if(e.type === "boss"){
        startBossDeath(e);
        continue;
      }
      emitEvent("kill", { enemy: e, x: e.x, y: e.y, type: e.type });
      spawnLoot(e.x, e.y, "normal");
      giveXP(e);
      killCount++;

      player.hp = Math.min(player.maxHp, player.hp + 1);

      if(bloodPools.length < 140){
        bloodPools.push({
          x: e.x, y: e.y,
          size: 10 + Math.random()*6,
          life: 600
        });
      }

      slowMotion = 6;

      if(player.kiOrbs < player.maxOrbs){
        player.kiOrbs++;
      }
    }
  }

  enemies = enemies.filter(e => (e.hp > 0) || (e.type === "boss" && e.dead && e.deathTimer > 0));
  packs.forEach(pack=>{
    pack.enemies = pack.enemies.filter(e=>e.hp>0);
  });
}

function updateBlood(){
  for(let i = bloodParticles.length - 1; i >= 0; i--){
    const p = bloodParticles[i];
    p.x += p.vx;
    p.y += p.vy;
    p.vy += 0.25;
    p.life--;
    if(p.life <= 0) bloodParticles.splice(i,1);
  }
  if(bloodParticles.length > 260){
    bloodParticles.splice(0, bloodParticles.length - 260);
  }
}

function drawBlood(){
  if(bloodParticles.length === 0) return;

  ctx.save();
  ctx.fillStyle = "#8b0000";
  ctx.beginPath();

  for(let i=0;i<bloodParticles.length;i++){
    const p = bloodParticles[i];
    const a = p.life / 30;
    if(a > 0.66) ctx.globalAlpha = 0.9;
    else if(a > 0.33) ctx.globalAlpha = 0.6;
    else ctx.globalAlpha = 0.35;

    ctx.fillRect(p.x - p.size*0.5, p.y - p.size*0.5, p.size, p.size);
  }
  ctx.restore();
}

/* ===== Î†åÎçî ===== */
function draw(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.globalAlpha = 1;
  ctx.shadowBlur = 0;
  ctx.shadowColor = "transparent";
  ctx.filter = "none";

  ctx.fillStyle="#111";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  let camX = player.x - canvas.width/2;
  let camY = player.y - canvas.height/2;

  let amp = shake ? (6 + shake * 0.45) : 0;
  let sx = shake ? (Math.random()-0.5) * amp : 0;
  let sy = shake ? (Math.random()-0.5) * amp : 0;

  ctx.save();
  ctx.translate(-camX+sx, -camY+sy);

  for(let y = 0; y < map.length; y++){
    for(let x = 0; x < map[y].length; x++){
      let tile = map[y][x];
      if(tile === 0) ctx.fillStyle = "#222";
      if(tile === 1) ctx.fillStyle = "#555";
      ctx.fillRect(x*tileSize, y*tileSize, tileSize, tileSize);
    }
  }

  ctx.fillStyle = "#550000";
  for(let i=0;i<bloodPools.length;i++){
    const b = bloodPools[i];
    const a = b.life / 600;
    if(a <= 0.05) continue;
    ctx.globalAlpha = a;
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;

  fireZones.forEach(f=>{
    ctx.save();
    for(let i=0;i<6;i++){
      let flameHeight = 10 + Math.sin(frameCount*0.2 + i)*6;
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = "orange";
      ctx.beginPath();
      ctx.moveTo(f.x - 6 + i*2, f.y);
      ctx.lineTo(f.x - 3 + i*2, f.y - flameHeight);
      ctx.lineTo(f.x + i*2, f.y);
      ctx.fill();
    }
    ctx.restore();
  });

  ctx.fillStyle = "red";
  for(let i=0;i<particles.length;i++){
    const p = particles[i];
    ctx.fillRect(p.x, p.y, 3, 3);
  }

  drawPortal();
  drawLoots();
  drawBlood();
  enemies.forEach(e=>drawEnemy(e));

  levelParticles.forEach(p=>{
    ctx.fillStyle = "gold";
    ctx.fillRect(player.x + p.ox, player.y + p.oy, 4, 4);
  });

  arrows.forEach(a=>{
    ctx.fillStyle = "white";
    ctx.fillRect(a.x-2, a.y-2, 4, 4);
  });

  ctx.restore();

  ctx.setTransform(1, 0, 0, 1, 0, 0);
  drawPlayer(canvas.width/2, canvas.height/2);
  drawUI();
}

function drawPlayer(x,y){
  if(player.levelGlow > 0){
    ctx.shadowColor = "gold";
    ctx.shadowBlur = player.levelGlow * 0.5;
  }

  ctx.fillStyle="#880000";
  ctx.fillRect(x-10,y-12,20,22);

  ctx.fillStyle="#aa0000";
  ctx.fillRect(x-7,y-20,14,8);

  ctx.fillStyle="#ffffcc";
  ctx.fillRect(x-8,y-26,4,8);
  ctx.fillRect(x+4,y-26,4,8);

  ctx.fillStyle = "#fff";
  ctx.fillRect(x-3,y-14,2,2);
  ctx.fillRect(x+1,y-14,2,2);

  ctx.shadowBlur = 0;

  if(player.ultiActive){
    ctx.save();
    ctx.shadowColor = "#ff6600";
    ctx.shadowBlur = 25;
    ctx.fillStyle = "#ffaa00";
    ctx.fillRect(x-3,y-14,2,2);
    ctx.fillRect(x+1,y-14,2,2);
    ctx.restore();
  }

  drawSword(x,y);
}

function drawSword(x, y){
  ctx.save();
  ctx.translate(x, y);

  var offsetX = 0;
  var offsetY = 0;
  var angle = 0;
  var t = attackFrame / 8;

  if (player.dir === "right") { offsetX = 18; if (attacking) angle = 1.5 * t; }
  else if (player.dir === "left") { offsetX = -18; if (attacking) angle = -1.5 * t; }
  else if (player.dir === "up") { offsetY = -18; if (attacking) offsetY -= 25 * t; }
  else if (player.dir === "down") { offsetY = 6; angle = Math.PI; if (attacking) offsetY += 25 * t; }

  ctx.translate(offsetX, offsetY);
  ctx.rotate(angle);
  drawSwordShape(ctx);
  ctx.restore();
}

function drawSwordShape(c){
  c.fillStyle = "#552200";
  c.fillRect(-2, 6, 4, 8);

  c.fillStyle = "#bbbbbb";
  c.fillRect(-8, 6, 16, 3);

  c.fillStyle = "#dddddd";
  c.fillRect(-2, -20, 4, 26);

  c.beginPath();
  c.moveTo(-2, -20);
  c.lineTo(0, -32);
  c.lineTo(2, -20);
  c.fill();
}

function drawEnemy(e){
  if(e.type === "boss"){
    if(e.dead){
      const t = (e.deathTimer / e.deathMax);
      ctx.save();
      ctx.globalAlpha = Math.max(0, t);

      ctx.fillStyle = "rgba(255,60,60,0.25)";
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius + (1-t)*35, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#777777";
      ctx.fillRect(e.x-20, e.y-25, 40, 50);

      if(Math.floor(frameCount/3)%2===0){
        ctx.fillStyle = "rgba(255,0,0,0.8)";
        ctx.fillRect(e.x-6, e.y-15, 4,4);
        ctx.fillRect(e.x+2, e.y-15, 4,4);
      }

      ctx.restore();
      return;
    }

    if(e.invul > 0){
      ctx.save();
      ctx.globalAlpha = 0.4;
      ctx.fillStyle = "red";
      ctx.beginPath();
      ctx.arc(e.x, e.y, e.radius + 10, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();
    }

    ctx.fillStyle = "#777777";
    ctx.fillRect(e.x-20, e.y-25, 40, 50);

    ctx.fillStyle = "#999999";
    ctx.fillRect(e.x-15, e.y-35, 30, 15);

    ctx.fillStyle = "red";
    ctx.fillRect(e.x-6, e.y-15, 4,4);
    ctx.fillRect(e.x+2, e.y-15, 4,4);

    ctx.save();
    ctx.translate(e.x+28, e.y);
    ctx.rotate(0.2);
    drawSwordShape(ctx);
    ctx.restore();
    return;
  }

  if(e.isLeader){
    ctx.fillStyle = "#ffd000";
    ctx.fillRect(e.x-6, e.y-24, 12, 3);
    ctx.fillRect(e.x-4, e.y-28, 3, 4);
    ctx.fillRect(e.x+1, e.y-28, 3, 4);
  }
  if(e.isElite){
    ctx.fillStyle = (e.eliteColor === "yellow") ? "#ffcc00" : "#00aaff";
  }else if(e.type === "archer"){
    ctx.fillStyle = "#cccccc";
  }else if(e.type === "mage"){
    ctx.fillStyle = "#550088";
  }else{
    ctx.fillStyle = "#006600";
  }

  if(e.activeBuffs && e.activeBuffs.some(b => b.key === "damage|leader|mul" || b.key === "atkSpeed|leader|mul")){
    const pulse = 0.45 + 0.25*Math.sin(frameCount*0.2);
    ctx.save();
    ctx.globalAlpha = 0.25 + pulse;
    ctx.fillStyle = "rgba(255,0,0,0.35)";
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.radius + 12 + pulse*6, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();
  }

  ctx.fillRect(e.x-10,e.y-12,20,22);

  if(e.type === "archer") ctx.fillStyle = "#dddddd";
  else if(e.type === "mage") ctx.fillStyle = "#550088";
  else ctx.fillStyle = "#00aa00";
  ctx.fillRect(e.x-7,e.y-20,14,8);

  ctx.fillStyle="red";
  ctx.fillRect(e.x-4,e.y-14,3,3);
  ctx.fillRect(e.x+1,e.y-14,3,3);
}

/* ===== UI ===== */
function drawUI(){
  drawTextUI();
  drawXPBar();
  drawOrbUI();
  drawHpOrb();
  drawBossHpBar();
  drawMiniMap();

  // (ÎîîÎ≤ÑÍ∑∏) Ïù∏Î≤§ ÏùºÎ∂Ä ÌëúÏãú
  ctx.font = "12px Arial";
  ctx.fillStyle = "#ccc";
  let startY = 140;
  for(let i=0;i<inventory.length && i<8;i++){
    ctx.fillText("‚Ä¢ " + inventory[i].name, 20, startY + i*16);
  }
}

function drawXPBar(){
  const barW = canvas.width * 0.6;
  const barH = 10;
  const x = canvas.width/2 - barW/2;
  const y = canvas.height - 20;
  const percent = xp / xpToNext;

  ctx.save();
  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(x, y, barW, barH);
  ctx.fillStyle = "#33ccff";
  ctx.fillRect(x, y, barW * percent, barH);
  ctx.strokeStyle = "rgba(255,255,255,0.3)";
  ctx.strokeRect(x, y, barW, barH);
  ctx.restore();
}

function drawMiniMap(){
  const w = 60;
  const h = 60;
  const margin = 12;
  const x0 = canvas.width - w - margin;
  const y0 = margin;

  const radarRange = 700;
  const scale = w / (radarRange * 2);

  const cx = x0 + w/2;
  const cy = y0 + h/2;

  ctx.save();
  ctx.globalAlpha = 0.85;
  ctx.fillStyle = "#000";
  ctx.fillRect(x0, y0, w, h);

  ctx.beginPath();
  ctx.rect(x0+1, y0+1, w-2, h-2);
  ctx.clip();

  ctx.globalAlpha = 0.7;
  ctx.strokeStyle = "#888";
  ctx.lineWidth = 1;

  const minTX = Math.max(0, Math.floor((player.x - radarRange) / tileSize));
  const maxTX = Math.min(mapSize-1, Math.floor((player.x + radarRange) / tileSize));
  const minTY = Math.max(0, Math.floor((player.y - radarRange) / tileSize));
  const maxTY = Math.min(mapSize-1, Math.floor((player.y + radarRange) / tileSize));

  for(let ty=minTY; ty<=maxTY; ty++){
    for(let tx=minTX; tx<=maxTX; tx++){
      if(map[ty][tx] !== 1) continue;
      const wx = tx * tileSize;
      const wy = ty * tileSize;
      const dx = wx - player.x;
      const dy = wy - player.y;
      const mx = cx + dx * scale;
      const my = cy + dy * scale;
      const size = tileSize * scale;
      ctx.strokeRect(mx, my, size, size);
    }
  }

  const boss = enemies.find(e => e.type === "boss");
  if(boss){
    const dx = boss.x - player.x;
    const dy = boss.y - player.y;
    if(dx*dx + dy*dy <= radarRange*radarRange){
      const mx = cx + dx * scale;
      const my = cy + dy * scale;
      ctx.globalAlpha = 1;
      ctx.fillStyle = "#fff";
      ctx.fillRect(mx-3, my-3, 6, 6);
    }
  }

  ctx.globalAlpha = 0.95;
  for(const e of enemies){
    if(e.hp <= 0) continue;
    if(e.type === "boss") continue;
    const dx = e.x - player.x;
    const dy = e.y - player.y;
    if(dx*dx + dy*dy > radarRange*radarRange) continue;
    const mx = cx + dx * scale;
    const my = cy + dy * scale;
    if(e.type === "mage") ctx.fillStyle = "#aa55ff";
    else if(e.type === "archer") ctx.fillStyle = "#dddddd";
    else ctx.fillStyle = "#00ff66";
    ctx.fillRect(mx-1.5, my-1.5, 3, 3);
  }

  ctx.globalAlpha = 1;
  ctx.fillStyle = "#ff4444";
  ctx.fillRect(cx-2, cy-2, 4, 4);

  ctx.restore();

  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "#444";
  ctx.lineWidth = 2;
  ctx.strokeRect(x0+1, y0+1, w-2, h-2);
  ctx.restore();
}

function drawTextUI(){
  ctx.save();
  ctx.textAlign = "left";
  ctx.font = "bold 18px Arial";
  ctx.fillStyle = "white";
  ctx.strokeStyle = "black";
  ctx.lineWidth = 4;

  ctx.strokeText("Level: " + level, 20, 55);
  ctx.fillText("Level: " + level, 20, 55);

  ctx.strokeText("TIER: " + mapTier, 20, 105);
  ctx.fillText("TIER: " + mapTier, 20, 105);

  if(portal.active){
    ctx.strokeText("PORTAL OPEN!", 20, 155);
    ctx.fillText("PORTAL OPEN!", 20, 155);
  }

  ctx.restore();
}

function drawOrbUI(){
  const btnRect = document.getElementById("attackBtn").getBoundingClientRect();
  const centerScreenX = btnRect.left + btnRect.width * 0.5;
  const centerScreenY = btnRect.top  + btnRect.height * 0.5;

  let cx = centerScreenX;
  let cy = centerScreenY - uiHeight;

  cx = Math.max(60, Math.min(canvas.width - 60, cx));
  cy = Math.max(60, Math.min(canvas.height - 60, cy));

  const orbR = 10;
  const ringR = 34;
  const startAngle = -Math.PI/2;

  const centerR = 24;
  const ready = (player.kiOrbs >= 1 && enemies.length > 0 && !player.ultiActive);

  orbUIState.cx = cx;
  orbUIState.cy = cy;
  orbUIState.centerR = centerR;
  orbUIState.ready = ready;

  ctx.save();

  for(let i=0;i<player.maxOrbs;i++){
    const a = startAngle + (i * (Math.PI * 2 / player.maxOrbs));
    const x = cx + Math.cos(a) * ringR;
    const y = cy + Math.sin(a) * ringR;

    ctx.beginPath();
    ctx.arc(x, y, orbR, 0, Math.PI*2);

    if(orbFlash > 0){
      ctx.fillStyle = "#00ff88";
      ctx.shadowColor = "#00ff88";
      ctx.shadowBlur = 35;
    }
    else if(i < player.kiOrbs){
      ctx.fillStyle = "#00ff55";
      ctx.shadowColor = "#00ff55";
      ctx.shadowBlur = 15;
    }
    else{
      ctx.fillStyle = "#002211";
      ctx.shadowColor = "transparent";
      ctx.shadowBlur = 0;
    }

    ctx.fill();
  }

  ctx.shadowBlur = ready ? 25 : 10;
  ctx.shadowColor = ready ? "rgba(120,180,255,0.95)" : "rgba(120,180,255,0.4)";
  ctx.fillStyle = ready ? "rgba(40,120,255,0.95)" : "rgba(40,120,255,0.45)";
  ctx.beginPath();
  ctx.arc(cx, cy, centerR, 0, Math.PI*2);
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.globalAlpha = 0.9;
  ctx.strokeStyle = "rgba(170,210,255,0.75)";
  ctx.lineWidth = 3;
  ctx.beginPath();
  ctx.arc(cx, cy, centerR+1, 0, Math.PI*2);
  ctx.stroke();

  ctx.globalAlpha = 0.95;
  ctx.fillStyle = "white";
  ctx.font = "bold 18px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("U", cx, cy+1);

  ctx.restore();
}

function drawHpOrb(){
  const uiH = ui.getBoundingClientRect().height || 120;
  const padRect = document.getElementById("movePad").getBoundingClientRect();
  let x = padRect.left + padRect.width * 0.5;

  const btnRect = document.getElementById("attackBtn").getBoundingClientRect();
  let y = (btnRect.top + btnRect.height * 0.5) - uiH;

  x = Math.max(40, Math.min(canvas.width - 40, x));
  y = Math.max(40, Math.min(canvas.height - 40, y));

  ctx.save();

  let radius = 25;
  hpWaveOffset += 0.07;

  let hpPercent = player.hp / player.maxHp;
  let liquidHeight = radius * 2 * hpPercent;
  let topY = y + radius - liquidHeight;

  let metal = ctx.createRadialGradient(x, y, radius-10, x, y, radius+12);
  metal.addColorStop(0, "#2a0000");
  metal.addColorStop(0.5, "#550000");
  metal.addColorStop(1, "#110000");

  ctx.beginPath();
  ctx.arc(x, y, radius+10, 0, Math.PI*2);
  ctx.fillStyle = metal;
  ctx.fill();

  ctx.lineWidth = 4;
  ctx.strokeStyle = "#000";
  ctx.stroke();

  ctx.beginPath();
  ctx.arc(x, y, radius+6, 0, Math.PI*2);
  ctx.strokeStyle = "#aa0000";
  ctx.lineWidth = 2;
  ctx.stroke();

  ctx.save();
  ctx.beginPath();
  ctx.arc(x, y, radius, 0, Math.PI*2);
  ctx.clip();

  let innerShadow = ctx.createRadialGradient(x, y+15, 10, x, y, radius);
  innerShadow.addColorStop(0, "#330000");
  innerShadow.addColorStop(1, "#000000");
  ctx.fillStyle = innerShadow;
  ctx.fillRect(x-radius, y-radius, radius*2, radius*2);

  ctx.beginPath();
  ctx.moveTo(x-radius, y+radius);
  for(let i=0;i<=radius*2;i++){
    let wave = Math.sin(i*0.12 + hpWaveOffset) * 4;
    ctx.lineTo(x-radius+i, topY + wave);
  }
  ctx.lineTo(x+radius, y+radius);
  ctx.closePath();

  let blood = ctx.createLinearGradient(0, topY, 0, y+radius);
  blood.addColorStop(0, "#ff2a2a");
  blood.addColorStop(1, "#8b0000");
  ctx.fillStyle = blood;
  ctx.fill();

  ctx.beginPath();
  ctx.arc(x-15, y-20, 18, 0, Math.PI*2);
  ctx.fillStyle = "rgba(255,255,255,0.25)";
  ctx.fill();

  let glass = ctx.createRadialGradient(x-10, y-15, 5, x, y, radius);
  glass.addColorStop(0, "rgba(255,255,255,0.25)");
  glass.addColorStop(1, "rgba(255,255,255,0)");
  ctx.fillStyle = glass;
  ctx.fillRect(x-radius, y-radius, radius*2, radius*2);

  if(hpPercent < 0.3){
    if(Math.floor(Date.now()/200)%2===0){
      ctx.beginPath();
      ctx.arc(x, y, radius+14, 0, Math.PI*2);
      ctx.fillStyle = "rgba(255,0,0,0.25)";
      ctx.fill();
    }
  }

  ctx.fillStyle = "white";
  ctx.font = "bold 16px Arial";
  ctx.textAlign = "center";
  ctx.fillText(Math.floor(player.hp), x, y+6);

  ctx.restore();
  ctx.restore();
}

function drawBossHpBar(){
  const boss = enemies.find(e => e.type === "boss");
  if(!boss) return;

  let camX = player.x - canvas.width/2;
  let camY = player.y - canvas.height/2;

  const screenX = boss.x - camX;
  const screenY = boss.y - camY;

  if(screenX < -100 || screenX > canvas.width + 100 || screenY < -100 || screenY > canvas.height + 100) return;

  const barW = 70;
  const barH = 7;
  const x = screenX - barW/2;
  const y = screenY - boss.radius - 18;

  let percent = boss.hp / boss.maxHp;
  percent = Math.max(0, Math.min(1, percent));

  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(0,0,0,0.6)";
  ctx.fillRect(x, y, barW, barH);
  ctx.fillStyle = "#ff4444";
  ctx.fillRect(x, y, barW * percent, barH);
  ctx.globalAlpha = 0.85;
  ctx.strokeStyle = "rgba(255,255,255,0.35)";
  ctx.lineWidth = 1;
  ctx.strokeRect(x + 0.5, y + 0.5, barW - 1, barH - 1);
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.font = "10px Arial";
  ctx.textAlign = "center";
  ctx.fillText(Math.ceil(boss.hp), screenX, y - 2);
  ctx.restore();
}

function drawGameOver(){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle="rgba(0,0,0,0.6)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="white";
  ctx.font="bold 40px Arial";
  ctx.textAlign="center";
  ctx.fillText("GAME OVER", canvas.width/2, canvas.height/2);

  ctx.font="bold 18px Arial";
  ctx.fillText("Tap to Restart", canvas.width/2, canvas.height/2 + 40);
}

function tryUltimate(){
  if(player.ultiActive) return;
  if(player.kiOrbs >= 1 && enemies.length > 0){
    player.kiOrbs -= 1;
    player.ultiActive = true;
    player.ultiTimer = 0;
    player.ultiCount = 0;
    performUltimateStrike();
    endUltimate();
  }
}

function handleUltimateOrbPress(clientX, clientY){
  const rect = canvas.getBoundingClientRect();
  const tx = clientX - rect.left;
  const ty = clientY - rect.top;

  const dx = tx - orbUIState.cx;
  const dy = ty - orbUIState.cy;
  const r = orbUIState.centerR;

  if(dx*dx + dy*dy <= r*r){
    tryUltimate();
    return true;
  }
  return false;
}


/* ============================= */
/* ‚úÖ Ïû•ÎπÑ/Í∞ÄÎ∞©/Ïπ¥Ïò§Ïä§ Î∂ÑÎ¶¨ UI Î°úÏßÅ */
/* ============================= */
// (Ïù¥ÎØ∏ ÏúÑÏóêÏÑú EQUIP_SLOTS/equipment/inventory/chaosOrbs ÏÑ†Ïñ∏Îê®)

// UI refs
const equipOverlay = document.getElementById("equipOverlay");
const bagOverlay   = document.getElementById("bagOverlay");
const chaosOverlay = document.getElementById("chaosOverlay");

const equipSlotsEl = document.getElementById("equipSlots");
const specTextEl   = document.getElementById("specText");
const equipInfoEl  = document.getElementById("equipInfo");

const bagGridEl    = document.getElementById("bagGrid");
const bagInfoEl    = document.getElementById("bagInfo");

const chaosCountEl2= document.getElementById("chaosCount");
const chaosInfoEl  = document.getElementById("chaosInfo");
const chaosBtnEl   = document.getElementById("chaosBtn");

let panelOpen = null; // "equip" | "bag" | "chaos" | null

// ÏÑ†ÌÉù: Í∞ÄÎ∞©/Ïû•ÎπÑ Í≥µÏö©
let selectedItem = null; // {from:"bag", idx} | {from:"equip", slot}

function stopEvt(e){
  if(!e) return;
  if(e.preventDefault) e.preventDefault();
  if(e.stopPropagation) e.stopPropagation();
}

function slotLabel(slot){
  if(slot==="weapon") return "Î¨¥Í∏∞";
  if(slot==="helm")   return "Ìà¨Íµ¨";
  if(slot==="chest")  return "Í∞ëÏò∑";
  if(slot==="ring")   return "Î∞òÏßÄ";
  return slot;
}

function prettyItemText(it){
  if(!it) return "";
  if(it.isUnique){
    return `[LEGENDARY] ${it.name}

${it.uniqueRef?.desc || it.desc || ""}`;
  }
  const lines = [];
  const rarity = (it.rarity || "common").toUpperCase();
  lines.push(`[${rarity}] ${it.name}`);
  if(Array.isArray(it.affixes) && it.affixes.length){
    lines.push("");
    for(const a of it.affixes){
      if(!a || !a.affix) continue;
      const kind = a.kind === "prefix" ? "Ï†ëÎëê" : "Ï†ëÎØ∏";
      const tier = a.tier ? `T${a.tier}` : "";
      const v = (Number.isInteger(a.value) ? String(a.value) : a.value.toFixed(3));
      lines.push(`- ${kind} ${a.affix.name} ${tier} : ${v}`);
    }
  }
  const d = it.totalData || it.data;
  if(d){
    lines.push("");
    for(const k of Object.keys(d)){
      const v = d[k];
      if(typeof v !== "number") continue;
      if(k.endsWith("Mul")) lines.push(`${k}: x${v.toFixed(2)}`);
      else{
        const sign = v>=0 ? "+" : "";
        lines.push(`${k}: ${sign}${(Number.isInteger(v)?v:v.toFixed(2))}`);
      }
    }
  }
  return lines.join("\n");
}

function rebuildGearFromEquipment(){
  player.gear = {
    dmgMul: 1, ultiMul: 1, spdMul: 1, atkSpdMul: 1, rangeMul: 1,
    armorAdd: 0, maxHpAdd: 0, hpRegen: 0,
    critChanceAdd: 0, critChanceMul: 1, critMultiAdd: 0,
  };

  for(const slot of EQUIP_SLOTS){
    const it = equipment[slot];
    if(!it) continue;
    if(it.isUnique) continue;
    const d = it.totalData || it.data;
    if(!d) continue;
    for(const k in d){
      const v = d[k];
      if(typeof v !== "number") continue;
      if(k.endsWith("Mul")) player.gear[k] *= v;
      else player.gear[k] += v;
    }
  }
  recalcFromGear();
  player.hp = Math.min(player.hp, player.maxHp);
}

/* ===== ÏïÑÏù¥ÌÖú ÏïÑÏù¥ÏΩò: Ïù¥Î™®ÏßÄ ÎåÄÏã† Ï∫îÎ≤ÑÏä§Ïóê Í∞ÑÎã® ÎèÑÌòï ===== */
function drawItemIcon(c, it){
  const ctx2 = c.getContext("2d");
  const W = c.width, H = c.height;
  ctx2.clearRect(0,0,W,H);

  const r = (it?.rarity) || (it?.isUnique ? "legendary" : "common");
  ctx2.save();
  ctx2.globalAlpha = 0.9;
  ctx2.lineWidth = 4;

  if(r==="legendary") ctx2.strokeStyle = "#d6b300";
  else if(r==="epic") ctx2.strokeStyle = "#b44dff";
  else if(r==="rare") ctx2.strokeStyle = "#2f7bff";
  else ctx2.strokeStyle = "#666";

  ctx2.beginPath();
  ctx2.arc(W/2,H/2, (Math.min(W,H)/2)-4, 0, Math.PI*2);
  ctx2.stroke();
  ctx2.restore();

  if(!it) return;

  ctx2.save();
  ctx2.translate(W/2,H/2);
  ctx2.globalAlpha = 0.95;

  if(it.slot==="weapon"){
    ctx2.rotate(-0.6);
    ctx2.fillStyle="#ddd";
    ctx2.fillRect(-2,-16,4,26);
    ctx2.fillStyle="#552200";
    ctx2.fillRect(-3,10,6,6);
    ctx2.fillStyle="#bbb";
    ctx2.fillRect(-10,8,20,4);
  }else if(it.slot==="helm"){
    ctx2.fillStyle="#aaa";
    ctx2.beginPath();
    ctx2.arc(0,-2,12,Math.PI,0);
    ctx2.lineTo(12,8);
    ctx2.lineTo(-12,8);
    ctx2.closePath();
    ctx2.fill();
    ctx2.fillStyle="#666";
    ctx2.fillRect(-12,8,24,6);
  }else if(it.slot==="chest"){
    ctx2.fillStyle="#888";
    ctx2.fillRect(-12,-12,24,26);
    ctx2.fillStyle="#555";
    ctx2.fillRect(-10,-10,20,8);
  }else if(it.slot==="ring"){
    ctx2.strokeStyle="#ddd";
    ctx2.lineWidth=4;
    ctx2.beginPath();
    ctx2.arc(0,0,10,0,Math.PI*2);
    ctx2.stroke();
    ctx2.fillStyle="#ddd";
    ctx2.beginPath();
    ctx2.arc(6,-6,2,0,Math.PI*2);
    ctx2.fill();
  }else{
    ctx2.fillStyle="#999";
    ctx2.fillRect(-10,-10,20,20);
  }
  ctx2.restore();
}

function getSelectedItem(){
  if(!selectedItem) return null;
  if(selectedItem.from==="bag") return inventory[selectedItem.idx] || null;
  if(selectedItem.from==="equip") return equipment[selectedItem.slot] || null;
  return null;
}

/* ===== Î†åÎçî: Ïû•ÎπÑ/Ïä§Ìéô ===== */
function renderEquipPanel(){
  equipSlotsEl.innerHTML = "";
  for(const slot of EQUIP_SLOTS){
    const it = equipment[slot];

    const d = document.createElement("div");
    d.className = "eSlot";
    if(selectedItem && selectedItem.from==="equip" && selectedItem.slot===slot) d.classList.add("selected");

    const lab = document.createElement("div");
    lab.className = "label";
    lab.textContent = slotLabel(slot);

    const item = document.createElement("div");
    item.className = "item";
    item.textContent = it ? (it.name || "") : "";

    d.appendChild(lab);
    d.appendChild(item);

    d.addEventListener("click", ()=>{
      if(selectedItem && selectedItem.from==="bag"){
        equipFromBagToSlot(selectedItem.idx, slot);
        return;
      }
      if(!selectedItem || selectedItem.from!=="equip" || selectedItem.slot!==slot){
        selectedItem = {from:"equip", slot};
      }else{
        if(equipment[slot]) unequipSlotToBag(slot);
        else selectedItem = null;
      }
      renderAllPanels();
    });

    equipSlotsEl.appendChild(d);
  }

  const g = player.gear || {};
  specTextEl.textContent =
`HP ${player.hp.toFixed(0)} / ${player.maxHp.toFixed(0)}
AR ${(player.armor ?? 0).toFixed(1)}
RG ${(g.hpRegen ?? 0).toFixed(2)}/s
DMG x${(g.dmgMul ?? 1).toFixed(2)}
AS  x${(g.atkSpdMul ?? 1).toFixed(2)}
MS  x${(g.spdMul ?? 1).toFixed(2)}
RNG x${(g.rangeMul ?? 1).toFixed(2)}
ULT x${(g.ultiMul ?? 1).toFixed(2)}
CRT ${(getCritChance()*100).toFixed(1)}% / x${getCritMulti().toFixed(2)}`;

  const it = getSelectedItem();
  equipInfoEl.textContent = it ? prettyItemText(it) : "";
}

/* ===== Î†åÎçî: Í∞ÄÎ∞© ===== */
function renderBagPanel(){
  bagGridEl.innerHTML = "";
  const minSlots = 24;
  const fillTo = Math.max(minSlots, Math.ceil((inventory.length)/6)*6);

  for(let i=0;i<fillTo;i++){
    const it = inventory[i] || null;

    const cell = document.createElement("div");
    cell.className = "bItem";
    if(it && it.isUnique) cell.classList.add("unique");
    if(selectedItem && selectedItem.from==="bag" && selectedItem.idx===i) cell.classList.add("selected");
    if(!it) cell.style.opacity = "0.35";

    const c = document.createElement("canvas");
    c.width = 40; c.height = 40;
    c.className = "iconCanvas";
    cell.appendChild(c);
    drawItemIcon(c, it);

    cell.addEventListener("click", ()=>{
      if(!it){ selectedItem = null; bagInfoEl.textContent=""; renderAllPanels(); return; }
      selectedItem = {from:"bag", idx:i};
      bagInfoEl.textContent = prettyItemText(it);
      renderAllPanels();
    });

    bagGridEl.appendChild(cell);
  }

  const it = getSelectedItem();
  if(it && selectedItem?.from==="bag") bagInfoEl.textContent = prettyItemText(it);
  else if(!bagInfoEl.textContent) bagInfoEl.textContent = "";
}

/* ===== Î†åÎçî: Ïπ¥Ïò§Ïä§ ===== */
function renderChaosPanel(){
  chaosCountEl2.textContent = `Ïπ¥Ïò§Ïä§ ${chaosOrbs}`;
  const it = getSelectedItem();
  chaosInfoEl.textContent = it ? prettyItemText(it) : "";
}

function renderAllPanels(){
  renderEquipPanel();
  renderBagPanel();
  renderChaosPanel();
}

/* ===== Ïû•Ï∞©/Ìï¥Ï†ú ===== */
function equipFromBagToSlot(invIndex, slot){
  const it = inventory[invIndex];
  if(!it) return;
  if(it.isUnique) return;
  if(it.slot !== slot) return;

  if(equipment[slot]) inventory.push(equipment[slot]);
  inventory.splice(invIndex, 1);
  equipment[slot] = it;

  selectedItem = {from:"equip", slot};
  rebuildGearFromEquipment();
  renderAllPanels();
}

function unequipSlotToBag(slot){
  const it = equipment[slot];
  if(!it) return;
  equipment[slot] = null;
  inventory.push(it);
  selectedItem = null;
  rebuildGearFromEquipment();
  renderAllPanels();
}

/* ===== Ìå®ÎÑê Ïó¥Í≥† Îã´Í∏∞ ===== */
function openPanel(which){
  pauseGame({ dim: 0.60, blur: 2 });
  panelOpen = which;

  equipOverlay.style.display = (which==="equip") ? "flex" : "none";
  bagOverlay.style.display   = (which==="bag")   ? "flex" : "none";
  chaosOverlay.style.display = (which==="chaos") ? "flex" : "none";

  renderAllPanels();
}
function closePanels(){
  panelOpen = null;
  equipOverlay.style.display = "none";
  bagOverlay.style.display   = "none";
  chaosOverlay.style.display = "none";
  resumeGame();
}

// HUD buttons
document.getElementById("btnEquip").addEventListener("click", (e)=>{ stopEvt(e); openPanel("equip"); });
document.getElementById("btnBag").addEventListener("click", (e)=>{ stopEvt(e); openPanel("bag"); });
document.getElementById("btnChaosWnd").addEventListener("click", (e)=>{ stopEvt(e); openPanel("chaos"); });

// Close buttons
document.getElementById("btnEquipClose").addEventListener("click", closePanels);
document.getElementById("btnBagClose").addEventListener("click", closePanels);
document.getElementById("btnChaosClose").addEventListener("click", closePanels);
const btnBagEquip = document.getElementById("btnBagEquip");
if(btnBagEquip){
  btnBagEquip.addEventListener("click", (e)=>{
    stopEvt(e);

    if(!selectedItem || selectedItem.from !== "bag") return;

    const it = inventory[selectedItem.idx];
    if(!it) return;
    if(it.isUnique) return;

    const slot = it.slot;
    if(!slot) return;

    equipFromBagToSlot(selectedItem.idx, slot);

    selectedItem = { from:"equip", slot };
    renderAllPanels();
  });
}
// ESC closes
window.addEventListener("keydown", (e)=>{
  if(e.key === "Escape" && panelOpen) closePanels();
});

/* ===== Ïπ¥Ïò§Ïä§ Ï†ÅÏö© ===== */
document.getElementById("chaosBtn").addEventListener("click", ()=>{
  if(chaosOrbs <= 0) return;

  const sel = selectedItem;
  if(!sel) return;

  let it = getSelectedItem();
  if(!it) return;
  if(it.isUnique) return;

  const baseId = it.baseId || it.id;
  const tmpl = ITEM_POOL.find(x => x.id === baseId);
  if(!tmpl) return;

  chaosOrbs--;

  const rarity = it.rarity || tmpl.rarity || "common";
  const ilvl = it.ilvl || getItemLevel();

  const baseData = buildBaseDataFromItemId(baseId);
  const newAffixes = rollAffixesPOE(rarity, ilvl);

  const affixData = makeEmptyItemData();
  for(const a of newAffixes){
    if(a && a.affix && typeof a.affix.apply === "function"){
      a.affix.apply(affixData, a.value);
    }
  }
  const totalData = mergeItemData(baseData, affixData);

  const preNames = newAffixes.filter(x=>x.kind==="prefix").map(x=>x.affix.name);
  const sufNames = newAffixes.filter(x=>x.kind==="suffix").map(x=>x.affix.name);

  let nm = tmpl.name;
  if(preNames.length) nm = preNames.join(" ") + " " + nm;
  if(sufNames.length) nm = nm + " " + sufNames.join(" ");

  it.baseId = baseId;
  it.baseName = tmpl.name;
  it.ilvl = ilvl;
  it.baseData = baseData;
  it.affixes = newAffixes;
  it.affixData = affixData;
  it.totalData = totalData;
  it.data = totalData;
  it.name = nm;

  if(sel.from === "equip"){
    equipment[sel.slot] = it;
    rebuildGearFromEquipment();
  }

  renderAllPanels();
});


/* ==== Ï∫îÎ≤ÑÏä§ ÌÑ∞Ïπò ===== */
canvas.addEventListener("touchstart", (e)=>{
  if(gameOver){ resetGame(); return; }

  if(!e.touches || !e.touches[0]) return;

  const near = getNearbyLoot();
  if(near){
    openLootChoice(near);
    e.preventDefault();
    return;
  }

  if(handleUltimateOrbPress(e.touches[0].clientX, e.touches[0].clientY)){
    e.preventDefault();
  }
},{passive:false});

canvas.addEventListener("mousedown", (e)=>{
  if(gameOver){ resetGame(); return; }

  const near = getNearbyLoot();
  if(near){ openLootChoice(near); return; }

  handleUltimateOrbPress(e.clientX, e.clientY);
});

let lastErr = null;

function drawRuntimeError(e){
  ctx.setTransform(1,0,0,1,0,0);
  ctx.fillStyle="rgba(0,0,0,0.75)";
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle="#fff";
  ctx.font="bold 16px Arial";
  ctx.textAlign="center";
  ctx.fillText("RUNTIME ERROR (F12 Console ÌôïÏù∏)", canvas.width/2, canvas.height/2 - 10);
  ctx.font="14px Arial";
  ctx.fillText(String(e && e.message ? e.message : e), canvas.width/2, canvas.height/2 + 18);
}

function loop(){
  try{
    if(gameOver){
      drawGameOver();
    }else if(gamePaused){
      // ‚úÖ Ï†ïÏßÄ ÌôîÎ©¥(Îî§/Î∏îÎü¨ Ï∫°Ï≥ê)ÏùÑ Í≥ÑÏÜç Î≥¥Ïó¨Ï£ºÍ∏∞Îßå
      ctx.setTransform(1,0,0,1,0,0);
      ctx.globalAlpha = 1;
      ctx.filter = "none";
      ctx.drawImage(pauseCanvas, 0, 0);
        }else{
      update();
      draw();

      if(resumeFade > 0){
        const a = resumeFade / resumeFadeMax;
        ctx.setTransform(1,0,0,1,0,0);
        ctx.globalAlpha = a;
        ctx.filter = "none";
        ctx.drawImage(pauseCanvas, 0, 0);
        ctx.globalAlpha = 1;
        resumeFade--;
      }
    }
    lastErr = null;
  }catch(e){
    console.error(e);
    lastErr = e;
    drawRuntimeError(e);
  }finally{
    requestAnimationFrame(loop);
  }
}

/* ===== Í≥µÍ≤© ÏïÑÏù¥ÏΩò ===== */
const iconCanvas = document.getElementById("attackIcon");
const iconCtx = iconCanvas.getContext("2d");
iconCtx.clearRect(0, 0, 60, 60);
iconCtx.save();
iconCtx.translate(30, 34);
iconCtx.scale(1.4, 1.4);
drawSwordShape(iconCtx);
iconCtx.restore();

function resetGame(){
  mapTier = 1;


  // ‚úÖ Ïù∏Î≤§/Ïû•ÎπÑ/Ïú†ÎãàÌÅ¨ Ï¥àÍ∏∞Ìôî
  inventory = [];
  equipment = { weapon:null, helm:null, chest:null, ring:null };
  selectedItem = null;
  panelOpen = null;
  chaosOrbs = 2;
  ownedUniques = [];
  uniqueState = {};
  if(audioUnlocked && !bgmOsc){
    bgmOsc = startBGM();
  }

  player.baseMaxHp = 100;
  player.maxHp = 100;
  player.hp = 100;

  player.baseArmor = 0;
  player.armor = 0;
  player.invul = 0;
  player.kiOrbs = 0;
  player.ultiActive = false;
  player.ultiCount = 0;
  player.ultiTimer = 0;
  player.levelGlow = 0;

  killCount = 0;
  level = 1;
  killsAtLevelStart = 0;
  killsForNextLevel = 20;
  baseDamageBase = 20;
  ultiDamageBase = 40;

  player.gear = {
    dmgMul: 1, ultiMul: 1, spdMul: 1, atkSpdMul: 1, rangeMul: 1,
    armorAdd: 0, maxHpAdd: 0, hpRegen: 0,
    critChanceAdd: 0, critChanceMul: 1, critMultiAdd: 0
  };

  recalcFromGear();

  shake = 0;
  slowMotion = 0;
  gameOver = false;
  document.getElementById("ui").style.display = "flex";

  startNewMap(1);


  // ‚úÖ Ïä§ÌÉÄÌÑ∞ ÏïÑÏù¥ÌÖú ÏßÄÍ∏â(ÏïÑÏù¥ÌÖúÏù¥ Ïïà Î≥¥Ïù¥Îäî ÎäêÎÇå Î∞©ÏßÄ)
  giveStarterItems();
  closePanels();
  resize();

  // Î£®Ìä∏/UI Î¶¨ÏÖã
  loots = [];
  lootOverlayOpen = false;
  pendingLoot = null;
  lootOverlay.style.display = "none";
}

resetGame();
loop();
</script>
</body>
</html>
